<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Just for fun</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhongyuehui.github.io/"/>
  <updated>2019-07-24T14:45:50.670Z</updated>
  <id>https://zhongyuehui.github.io/</id>
  
  <author>
    <name>zhong yuehui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Angular中的生命周期函数</title>
    <link href="https://zhongyuehui.github.io/2019/07/24/Angular%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/"/>
    <id>https://zhongyuehui.github.io/2019/07/24/Angular中的生命周期函数/</id>
    <published>2019-07-24T14:34:53.000Z</published>
    <updated>2019-07-24T14:45:50.670Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>生命周期函数通俗的讲就是组件创建、组件更新、组件销毁的时候会触发一系列的方法，也叫生命周期钩子方法。</p></blockquote><a id="more"></a><h2 id="Angular-中的生命周期函数"><a href="#Angular-中的生命周期函数" class="headerlink" title="Angular 中的生命周期函数"></a>Angular 中的生命周期函数</h2><ul><li>当 Angular 使用构造函数新建一个组件或指令后，就会按下面的顺序在特定时刻调用这些生命周期钩子方法。</li></ul><table><thead><tr><th>方法</th><th align="center">用途及时机</th></tr></thead><tbody><tr><td>constructor</td><td align="center">构造函数中除了使用简单的值对局部变量进行初始化之外，什么都不应该做。 （非生命周期函数）</td></tr><tr><td>ngOnChanges()</td><td align="center">当 Angular（重新）设置数据绑定输入属性时响应。 该方法接受当前和上一属性值的 SimpleChanges 对象。当被绑定的输入属性的值发生变化时调用，首次调用一定会发生在 ngOnInit() 之前。</td></tr><tr><td><strong><font color="red">ngOnInit()</font></strong></td><td align="center">在 Angular 第一次显示数据绑定和设置指令/组件的输入属性之后，初始化指令/组件。在第一轮 ngOnChanges() 完成之后调用，只调用一次。使用 ngOnInit() 有两个原因：<br>1、在构造函数之后马上执行复杂的初始化逻辑<br>2、在 Angular 设置完输入属性之后，对该组件进行准备.</td></tr><tr><td>ngDoCheck()</td><td align="center">检测，并在发生 Angular 无法或不愿意自己检测的变化时作出反应。在每个 Angular 变更检测周期中调用，ngOnChanges() 和 ngOnInit() 之后。</td></tr><tr><td>ngAfterContentInit()</td><td align="center">当把内容投影进组件之后调用。第一次 ngDoCheck() 之后调用，只调用一次。</td></tr><tr><td>ngAfterContentChecked()</td><td align="center">每次完成被投影组件内容的变更检测之后调用。ngAfterContentInit() 和每次 ngDoCheck() 之后调用。</td></tr><tr><td><strong><font color="red">ngAfterViewInit()</font></strong></td><td align="center">初始化完组件视图及其子视图之后调用,第一次 ngAfterContentChecked() 之后调用，只调用一次。</td></tr><tr><td>ngAfterViewChecked()</td><td align="center">每次做完组件视图和子视图的变更检测之后调用。ngAfterViewInit()和每次 ngAfterContentChecked() 之后调用。</td></tr><tr><td><strong><font color="red">ngOnDestroy()</font></strong></td><td align="center">当 Angular 每次销毁指令/组件之前调用并清扫。在这儿反订阅可观察对象和分离事件处理器，以防内存泄漏。在 Angular 销毁指令/组件之前调用。</td></tr></tbody></table><p>-</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li><p>在生命周期函数中，可以去实现接口，也可以不实现，如果实现了那么就必须按照接口的规范,每个接口都有一个对应的唯一的钩子方法</p></li><li><p>默认为 ngOnInit 启用了接口</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> &#123; Component, OnInit &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="hljs-string">'app-name'</span>,</span><br><span class="line">  templateUrl: <span class="hljs-string">'./name.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="hljs-string">'./name.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> NameComponent <span class="hljs-keyword">implements</span> OnInit &#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit(): <span class="hljs-built_in">void</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除接口</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="hljs-keyword">import</span> &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="hljs-string">'app-name'</span>,</span><br><span class="line">  templateUrl: <span class="hljs-string">'./name.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="hljs-string">'./name.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> NameComponent &#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit(): <span class="hljs-built_in">void</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>增加接口</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="hljs-keyword">import</span> &#123; Component, OnInit,ngOnChanges &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="hljs-string">'app-name'</span>,</span><br><span class="line">  templateUrl: <span class="hljs-string">'./name.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="hljs-string">'./name.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> NameComponent <span class="hljs-keyword">implements</span> OnInit,ngOnChanges &#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit(): <span class="hljs-built_in">void</span> &#123; &#125;</span><br><span class="line">  ngOnChanges()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h3><pre><code><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> &#123; Component, OnInit &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="hljs-string">'app-home'</span>,</span><br><span class="line">  templateUrl: <span class="hljs-string">'./home.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="hljs-string">'./home.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HomeComponent <span class="hljs-keyword">implements</span> OnInit &#123;</span><br><span class="line">  <span class="hljs-keyword">public</span> mes: <span class="hljs-built_in">string</span> = <span class="hljs-string">'生命周期函数的过程'</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'00构造函数执行了，--除了使用简单的值对局部变量进行初始化之外，什么都不应该做'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ngOnChanges() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'001-ngOnChanges执行了，当绑定的输入属性发生变化时调用(父子组件传值的时候会触发)'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'002ngOnInit执行了,一般在这里发送请求数据'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ngDoCheck() &#123;</span><br><span class="line">    <span class="hljs-comment">//写一些自定义的操作</span></span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'03ngDocheck执行了--检测，并在发生angular无法或不愿意自己检测的变化做出反应'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ngAfterContentInit() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'004ngAfterContentInit方法执行了，当把内容投影进组件之后调用'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  ngAfterContentChecked(): <span class="hljs-built_in">void</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'05ngAfterContentChecked执行了--每次完成被投影组件内容的变更检测之后调用'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ngAfterViewInit(): <span class="hljs-built_in">void</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'06ngAfterViewInit执行了，初始化完成组件以及子视图之后调用（DOM操作放在这里）'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ngAfterViewChecked(): <span class="hljs-built_in">void</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'07ngAfterViewChecked执行了-每次做完组件视图的变更检测之后调用'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ngOnDestroy(): <span class="hljs-built_in">void</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'08ngOnDestroy执行了'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>如果什么都不做那么它执行的顺序是这样的<br><img src="https://s2.ax1x.com/2019/07/24/eVWCIf.md.jpg" alt="生命周期函数"></p></li><li><p>如果我们将自己身上的 mes 属性渲染到页面上</p><figure class="highlight django hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-xml">//home.html</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; mes &#125;&#125;</span><span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>那么生命周期函数执行顺序是这样的<br><img src="https://s2.ax1x.com/2019/07/24/eVWii8.md.jpg" alt="增加mes生命周期函数"></p></li><li><p>如果我们定义一个函数来改变<code>mes</code>的值，它是这样的</p><figure class="highlight hsp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//home.html</span></span><br><span class="line">&lt;<span class="hljs-keyword">button</span> (click)=<span class="hljs-string">"changeMes()"</span>&gt;改变<span class="hljs-keyword">mes</span>&lt;/<span class="hljs-keyword">button</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight stylus hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//hoem.ts</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-title">changeMes</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">console.log(<span class="hljs-string">'--------------------'</span>)</span><br><span class="line">this<span class="hljs-selector-class">.mes</span> = <span class="hljs-string">'改变了mes'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/07/24/eVRzqI.md.jpg" alt="改变mes生命周期函数"></p></li></ul><hr><ul><li><p>如果我们在 app 根组件中为 home 组件定义一个 flag，再定义按钮控制 flag，这样就可以达到卸载挂载组件的效果</p><figure class="highlight arduino hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//app.html</span></span><br><span class="line">&lt;app-<span class="hljs-built_in">home</span> *ngIf=<span class="hljs-string">"flage"</span>&gt;&lt;/app-<span class="hljs-built_in">home</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;button (<span class="hljs-built_in">click</span>)=<span class="hljs-string">"removeCom()"</span>&gt;卸载组件&lt;/button&gt;</span><br></pre></td></tr></table></figure><figure class="highlight stylus hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//app.ts</span></span><br><span class="line">public flage: boolean = true</span><br><span class="line"><span class="hljs-function"><span class="hljs-title">removeCom</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">this<span class="hljs-selector-class">.flage</span> = !this.flage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/07/24/eVW9dP.md.jpg" alt="卸载组件"></p><p><img src="https://s2.ax1x.com/2019/07/24/eVWpZt.md.jpg" alt="挂载组件"></p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>如果我们创建一个父组件向子组件传值的话，那么它就会执行第一个生命周期函数</li><li>如果我们修改了视图上的数据，那么所有<code>Checked()</code>(3、5、7)函数都会执行</li><li>如果是请求数据，我们可以在<code>ngOnInit(){}</code>中进行</li><li>如果是 DOM 操作，我们可以在<code>ngAfterViewInit()</code>中进行</li><li>如果是卸载组件，那么就会执行最后一个生命周期函数<code>ngOnDestroy</code><blockquote><p>以上就是一些关于 Angular 中的生命周期函数的一些知识。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;生命周期函数通俗的讲就是组件创建、组件更新、组件销毁的时候会触发一系列的方法，也叫生命周期钩子方法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Angular" scheme="https://zhongyuehui.github.io/categories/Angular/"/>
    
    
      <category term="Angular" scheme="https://zhongyuehui.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>Angular中父子组件传值</title>
    <link href="https://zhongyuehui.github.io/2019/07/24/Angular%E4%B8%AD%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
    <id>https://zhongyuehui.github.io/2019/07/24/Angular中父子组件传值/</id>
    <published>2019-07-24T14:28:21.000Z</published>
    <updated>2019-07-26T02:40:29.843Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前我们已经看过了Angular中的DOM，现在我们来了解一下Angular中的组件之间的传值</p></blockquote><a id="more"></a><h1 id="Angular中父子组件之间的传值"><a href="#Angular中父子组件之间的传值" class="headerlink" title="Angular中父子组件之间的传值"></a>Angular中父子组件之间的传值</h1><h2 id="父子组件之间的传值"><a href="#父子组件之间的传值" class="headerlink" title="父子组件之间的传值"></a>父子组件之间的传值</h2><h3 id="父组件给子组件传值"><a href="#父组件给子组件传值" class="headerlink" title="父组件给子组件传值"></a>父组件给子组件传值</h3><ul><li><p>父组件一般是挂载到app渲染的组件，子组件一般是被父组件使用的组件</p></li><li><p>我们创建两个组件分别为父组件<strong>home</strong>和子组件<strong>header</strong>,将home组件挂载到app根组件中后，我们在home组件中想使用header组件为我们的home组件设置页面的header部分，但是内容是通过home传递过去的，代码如下</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//home.ts</span></span><br><span class="line"><span class="hljs-keyword">import</span> &#123; Component, OnInit &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="hljs-string">'app-home'</span>,</span><br><span class="line">  templateUrl: <span class="hljs-string">'./home.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="hljs-string">'./home.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HomeComponent <span class="hljs-keyword">implements</span> OnInit &#123;</span><br><span class="line">  <span class="hljs-keyword">public</span> title: <span class="hljs-built_in">string</span> = <span class="hljs-string">'首页'</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;</span><br><span class="line">  ngOnInit() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>父组件的业务逻辑里面只需要在逻辑中定义一个要传递的数据即可</p></li><li><p>使用[<strong>要传递的属性名</strong>]=”<strong>要传递的属性值</strong>“,就可以将父组件的<code>title</code>传递给header组件</p>  <figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//home.html</span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">app-header</span> [<span class="hljs-attr">title</span>]=<span class="hljs-string">"title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-header</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是home组件<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>这个时候，header组件需要接收一下home组件传过来的值。引入<code>{Input}</code>组件，定义<code>@input()装饰器</code>装饰器后面跟上传递过来的属性名就接收完成了，这个时候，我们就可以在<code>header.html</code>中直接使用了</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//header.ts</span></span><br><span class="line"><span class="hljs-keyword">import</span> &#123; Component, OnInit, Input &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="hljs-string">'app-header'</span>,</span><br><span class="line">  templateUrl: <span class="hljs-string">'./header.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="hljs-string">'./header.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HeaderComponent <span class="hljs-keyword">implements</span> OnInit &#123;</span><br><span class="line">  <span class="hljs-meta">@Input</span>() title: <span class="hljs-built_in">string</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight gauss hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//header.html</span></span><br><span class="line">&lt;<span class="hljs-built_in">header</span>&gt;&#123;&#123; <span class="hljs-built_in">title</span> &#125;&#125;&lt;/<span class="hljs-built_in">header</span>&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="父组件给子组件传递方法"><a href="#父组件给子组件传递方法" class="headerlink" title="父组件给子组件传递方法"></a>父组件给子组件传递方法</h4><ul><li><p>其实传值和传递方法是一样的，我们在home父组件组件中定义一个<code>run</code>方法</p>  <figure class="highlight stylus hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//home.ts</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    console.log(<span class="hljs-string">'这是home组件的run方法'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将方法传递过去</p>  <figure class="highlight stata hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//home.html</span></span><br><span class="line">&lt;<span class="hljs-keyword">app</span>-header [title]=<span class="hljs-string">"title"</span> [message]=<span class="hljs-string">"message"</span> [<span class="hljs-keyword">run</span>]=<span class="hljs-string">"run"</span>&gt;&lt;/<span class="hljs-keyword">app</span>-header&gt;</span><br></pre></td></tr></table></figure></li><li><p>注意：传递方法的时候也不需要加<code>()</code>，否则会执行，只需要传递方法名就可以了</p></li><li><p>在header子组件中接收该方法，并创建一个点击事件调用该方法</p>  <figure class="highlight hsp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// header.html</span></span><br><span class="line">&lt;<span class="hljs-keyword">button</span> (click)=<span class="hljs-string">"UseRun()"</span>&gt; 执行父组件的<span class="hljs-keyword">run</span>方法&lt;/<span class="hljs-keyword">button</span>&gt;</span><br></pre></td></tr></table></figure></li></ul><pre><code><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// header.ts</span></span><br><span class="line"><span class="hljs-meta">@Input()</span> run: any</span><br><span class="line"> </span><br><span class="line">UseRun() &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>我们在执行的时候需要使用<code>()</code>表示执行这个方法，因为他传递过来的就是一个函数，这个时候我们点击这个button就可以执行home组件传递过来的方法了。</p><h4 id="将整个父组件传递给子组件"><a href="#将整个父组件传递给子组件" class="headerlink" title="将整个父组件传递给子组件"></a>将整个父组件传递给子组件</h4></li><li><p>如果需要传递的数据太多了，每一个我们都传递过去，一个是太繁琐了，对开发人员不友好，于是有了将整个父组件传递给子组件的功能</p></li><li><p>其实传递父组件给子组件和普通传值都是一样的，只需要传递一个<code>this</code>即可</p>  <figure class="highlight stata hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//home.html</span></span><br><span class="line">&lt;<span class="hljs-keyword">app</span>-header [home]=<span class="hljs-string">"this"</span>&gt;&lt;/<span class="hljs-keyword">app</span>-header&gt;</span><br></pre></td></tr></table></figure></li><li><p>这样就把父组件整个对象传递过去了</p></li><li><p>接收也是和以前一样的</p>  <figure class="highlight delphi hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//header.ts</span></span><br><span class="line">  @Input() home: any</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123; &#125;</span></span></span><br><span class="line"><span class="hljs-function"></span></span><br><span class="line"><span class="hljs-function">  <span class="hljs-title">ngOnInit</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123;</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-comment">  &#125;</span></span></span><br><span class="line"><span class="hljs-function">  <span class="hljs-title">getParMes</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123;</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-comment">    console.log(this.home.message)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-comment">  &#125;</span></span></span><br><span class="line"><span class="hljs-function">  <span class="hljs-title">UseRun</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123;</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-comment">    this.home.postSonRun()</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-comment">  &#125;</span></span></span><br></pre></td></tr></table></figure></li><li><p>使用这中方式就避免了繁琐的传值。</p><h3 id="父组件获取子组件的值-Viewchild"><a href="#父组件获取子组件的值-Viewchild" class="headerlink" title="父组件获取子组件的值(@Viewchild)"></a>父组件获取子组件的值(@Viewchild)</h3></li><li><p>在DOM操作中，其实就已经说到了使用@Viewchild获取到子组件的整个DOM实例</p></li><li><p>我们创建一个news组件作为父组件，一个footer组件作为子组件</p></li></ul><hr><ul><li><p>子组件的定义属性和方法</p>  <figure class="highlight arduino hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//footer.ts</span></span><br><span class="line"><span class="hljs-keyword">public</span> mes: <span class="hljs-keyword">string</span> = <span class="hljs-string">'我是footer组件的message'</span></span><br><span class="line"><span class="hljs-built_in">run</span>() &#123;</span><br><span class="line">console.log(<span class="hljs-string">'我是footer组件的run方法'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义标识</p>  <figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//news.html</span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">app-footer</span> #<span class="hljs-attr">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-footer</span>&gt;</span></span><br><span class="line"><span class="hljs-comment">&lt;!-- 定义footer，就像id一样作为标识 --&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>这是news组件<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"getSon()"</span>&gt;</span>获取子组件的数据和方法<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>调用子组件的方法和属性</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> &#123; Component, OnInit, ViewChild &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;  <span class="hljs-comment">//引入Viewchild</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="hljs-string">'app-news'</span>,</span><br><span class="line">  templateUrl: <span class="hljs-string">'./news.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="hljs-string">'./news.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> NewsComponent <span class="hljs-keyword">implements</span> OnInit &#123;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-meta">@ViewChild</span>(<span class="hljs-string">'footer'</span>, &#123; <span class="hljs-keyword">static</span>: <span class="hljs-literal">false</span> &#125;) footer: <span class="hljs-built_in">any</span>  <span class="hljs-comment">//定义属性装饰器</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  getSon() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.footer.mes);  <span class="hljs-comment">//打印子组件的mes</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.footer.run()  <span class="hljs-comment">//调用父组件的run方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="子组件通过-Output触发父组件的方法并传值"><a href="#子组件通过-Output触发父组件的方法并传值" class="headerlink" title="子组件通过@Output触发父组件的方法并传值"></a>子组件通过@Output触发父组件的方法并传值</h3><ul><li><p>子组件引入Output组件和EvenEmitter事件驱动</p>  <figure class="highlight clean hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> &#123; Component, OnInit, Output, EventEmitter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;</span><br></pre></td></tr></table></figure></li><li><p>子组件实例化 EventEmitter</p>  <figure class="highlight aspectj hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Output</span>() <span class="hljs-keyword">public</span> getFa = <span class="hljs-keyword">new</span> EventEmitter()</span><br></pre></td></tr></table></figure></li><li><p>我们在footer子组件中定义一个button注册一个点击事件，向父组件发送数据</p>  <figure class="highlight hsp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//footer.html</span></span><br><span class="line">&lt;<span class="hljs-keyword">button</span> (click)=<span class="hljs-string">"postFa()"</span>&gt;给父组件传递方法&lt;/<span class="hljs-keyword">button</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>然后定义一下这个事件函数并传值</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//footer.ts</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> &#123; Component, OnInit, Output, EventEmitter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="hljs-string">'app-footer'</span>,</span><br><span class="line">  templateUrl: <span class="hljs-string">'./footer.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="hljs-string">'./footer.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> FooterComponent <span class="hljs-keyword">implements</span> OnInit &#123;</span><br><span class="line">  <span class="hljs-keyword">public</span> mes: <span class="hljs-built_in">string</span> = <span class="hljs-string">'我是footer组件的message'</span></span><br><span class="line">  <span class="hljs-meta">@Output</span>() <span class="hljs-keyword">public</span> getFa = <span class="hljs-keyword">new</span> EventEmitter()</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  postFa() &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.getFa.emit(<span class="hljs-keyword">this</span>.mes) <span class="hljs-comment">// 这个getFa就是实例化对象，所以我们接下来在父组件中需要使用它进行接收值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这里表示传递了子组件中的<code>mes</code>属性给父组件</p></li><li><p>父组件接收子组件的值</p>  <figure class="highlight stylus hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//news.html</span></span><br><span class="line">&lt;app-<span class="hljs-selector-tag">footer</span> <span class="hljs-selector-id">#footer</span> (getFa)=<span class="hljs-string">"run($event)"</span>&gt;&lt;/app-footer&gt;</span><br></pre></td></tr></table></figure></li><li><p>在上面，<code>()</code>内表示的是子组件传递的那个实例化对象，并且需要使用父组件的run方法，而这个<code>$event</code>参数就是子组件传递的那个参数<code>this.mes</code></p></li></ul><hr><ul><li><p>父组件接收子组件传递的值</p>  <figure class="highlight hsp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="hljs-comment">//news.ts</span></span><br><span class="line"> <span class="hljs-keyword">run</span>(<span class="hljs-keyword">mes</span>) &#123;</span><br><span class="line"> console.log(<span class="hljs-string">'我是父组件的run'</span>)</span><br><span class="line"> console.log(<span class="hljs-keyword">mes</span>)  <span class="hljs-comment">//我是footer组件的message</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其实使用@output调用父组件的方法就是创建一个实例化对象，通过这个实例化对象传递参数，然后在子组件中通过 <code>(实例化对象)=&quot;需要调用的父组件方法名(子组件需要传递的参数)&quot;</code>，然后使用父组件的这个方法逻辑处理这个参数就完成了需求。</p><h3 id="非父子组件之间的传值"><a href="#非父子组件之间的传值" class="headerlink" title="非父子组件之间的传值"></a>非父子组件之间的传值</h3></li><li><p>使用localStorage来实现非父子组件之间的通讯</p></li><li><p>使用Angular提供的服务功能实现</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3></li><li><p>使用<code>@Input()</code>–<code>[属性名]=&quot;要传递的值或方法&quot;</code>-可以通过属性传递的方式给子组件传值，可以传递方法、属性、甚至是整个父组件对象,只需要使用<code>@Input() 属性名:数据类型</code>就可以使用传递过来的值</p></li><li><p>使用<code>@VIewchild</code>–<code>#标识</code>-可以让父组件使用子组件的属性和方法，只需使用 <code>@Viewchild(&#39;标识名&#39;,{static:false}) 标识名:数据类型</code>,就可以使用(注意：第二个标识名相当于传递过来的标识名的赋值，可以任意起名字，以供后面使用)</p></li><li><p>使用<code>@Output</code>–<code>[驱动事件实例化对象]=&quot;要使用父组件的方法名(要传递给方法的参数)&quot;</code>可以使用父组件的方法并且传递参数</p><blockquote><p>以上就是Angular中的组件传值的一些知识了。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前我们已经看过了Angular中的DOM，现在我们来了解一下Angular中的组件之间的传值&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Angular" scheme="https://zhongyuehui.github.io/categories/Angular/"/>
    
    
      <category term="Angular" scheme="https://zhongyuehui.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>ES6的fetch的使用</title>
    <link href="https://zhongyuehui.github.io/2019/07/23/ES6%E7%9A%84fetch%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://zhongyuehui.github.io/2019/07/23/ES6的fetch的使用/</id>
    <published>2019-07-23T14:22:19.000Z</published>
    <updated>2019-07-23T14:39:22.081Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 React 中，我们经常使用这个方法进行数据的获取，它是基于 Promise 封装的一个 API。</p></blockquote><a id="more"></a><h2 id="fetch-的使用"><a href="#fetch-的使用" class="headerlink" title="fetch 的使用"></a>fetch 的使用</h2><ul><li>在 Vue 中，我们使用 axios 来发起数据请求，但是在 React 中，我们可以使用 ES6 中的 fetch API 来获取数据</li><li>fetch API 是基于 promise 封装的 API</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>fetch 的使用:</p><figure class="highlight vbscript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(url)</span><br><span class="line">.<span class="hljs-keyword">then</span>(<span class="hljs-built_in">response</span>=&gt;&#123;</span><br><span class="line">    console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">response</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>这样获取到的 Response 对象只是一些状态，并没有实际想要的数据</p></li><li><p>但是我们可以调用 response.json()得到一个新的 promise</p><figure class="highlight fortran hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  fetch(url)</span><br><span class="line">.<span class="hljs-keyword">then</span>(response=&gt;&#123;</span><br><span class="line">    console.<span class="hljs-built_in">log</span>(response)</span><br><span class="line">    <span class="hljs-keyword">return</span> response.json()</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="hljs-keyword">then</span>(<span class="hljs-keyword">data</span>=&gt;&#123;</span><br><span class="line">    console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">data</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>当使用 response.json()时，把他返回出去就得到一个新的 promise 对象，再.then 就可以获取到数据了</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 React 中，我们经常使用这个方法进行数据的获取，它是基于 Promise 封装的一个 API。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="ES6" scheme="https://zhongyuehui.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://zhongyuehui.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Angular的服务以及数据的持久化存储</title>
    <link href="https://zhongyuehui.github.io/2019/07/23/Angular%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/"/>
    <id>https://zhongyuehui.github.io/2019/07/23/Angular的服务以及数据的持久化存储/</id>
    <published>2019-07-23T13:58:39.000Z</published>
    <updated>2019-07-23T14:30:21.571Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为什么使用服务?在很多服务中，比如 $location 服务，它可以使用 DOM 中存在的对象，类似 window.location 对象，但 window.location 对象在 AngularJS 应用中有一定的局限性。</p></blockquote><a id="more"></a><h2 id="Angular-服务以及数据的持久化存储"><a href="#Angular-服务以及数据的持久化存储" class="headerlink" title="Angular 服务以及数据的持久化存储"></a>Angular 服务以及数据的持久化存储</h2><ul><li>使用 Angular 的服务可以在应用中使用。</li></ul><h3 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h3><ul><li>使用命令行创建服务:<code>ng g service services/storag</code></li><li>这个命令表示创建一个 services 文件夹，里面创建 storag 服务</li></ul><h3 id="引入服务"><a href="#引入服务" class="headerlink" title="引入服务"></a>引入服务</h3><ul><li>在<code>app.module.ts</code>中引入创建的服务，并且声明<figure class="highlight clean hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//引入</span></span><br><span class="line"><span class="hljs-keyword">import</span> &#123;StorageService&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./services/storage.service'</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//声明</span></span><br><span class="line"> providers: [StoragService],</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>引入服务</p><figure class="highlight clean hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> &#123;StorageService&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../../services/storage.service'</span></span><br></pre></td></tr></table></figure></li><li><p>初始化服务:</p><figure class="highlight delphi hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(<span class="hljs-keyword">public</span> storage: StoragService)</span> <span class="hljs-comment">&#123;//初始化服务</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-comment">this.storage.getData() //使用服务</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-comment">&#125;</span></span></span><br></pre></td></tr></table></figure></li><li><p>注意：服务需要在 services 下的 storage.service.ts 中自己创建，由于我创建了如下方法，才能在使用的服务的时候调用该方法</p><figure class="highlight less hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">getData</span>() &#123;</span><br><span class="line"><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(<span class="hljs-string">'😄'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们一般使用 storage 做本地数据的持久化存储的功能可以封装一下几个方法</p><figure class="highlight q hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">set</span>(<span class="hljs-built_in">key</span>: <span class="hljs-built_in">string</span>, <span class="hljs-built_in">value</span>: <span class="hljs-built_in">any</span>) &#123;  <span class="hljs-comment">//定义存储的方法</span></span><br><span class="line">   localStorage.setItem(<span class="hljs-built_in">key</span>, <span class="hljs-built_in">value</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="hljs-built_in">get</span>(<span class="hljs-built_in">key</span>:<span class="hljs-built_in">string</span>) &#123; <span class="hljs-comment">//定义获取数据的方法</span></span><br><span class="line">   return JSON.<span class="hljs-built_in">parse</span>(localStorage.getItem(<span class="hljs-built_in">key</span>))</span><br><span class="line"> &#125;</span><br><span class="line"> remove(<span class="hljs-built_in">key</span>:<span class="hljs-built_in">string</span>) &#123;  <span class="hljs-comment">//定义删除数据的方法</span></span><br><span class="line">   localStorage.removeItem(<span class="hljs-built_in">key</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>调用的时候在任何组件中初始化完毕后直接可以使用<code>this.storage.方法名</code>来使用服务中的方法</p></li><li><p>注意：因为 Angular 使用的是 Typescript 语法，所以我们尽量定义数据类型，以免引起不必要的错误。</p></li><li><p>在 Angular 中，组件与组件之间可以相互传值，不能相互调用，组件可以调用服务，但是服务不能调用组件，但是服务与服务之间是可以相互调用的。</p><blockquote><p>以上就是一些关于 Angular 数据持久化存储的一些相关使用。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;为什么使用服务?在很多服务中，比如 $location 服务，它可以使用 DOM 中存在的对象，类似 window.location 对象，但 window.location 对象在 AngularJS 应用中有一定的局限性。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Angular" scheme="https://zhongyuehui.github.io/categories/Angular/"/>
    
    
      <category term="Angular" scheme="https://zhongyuehui.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>初识Angular</title>
    <link href="https://zhongyuehui.github.io/2019/07/22/%E5%88%9D%E8%AF%86Angular/"/>
    <id>https://zhongyuehui.github.io/2019/07/22/初识Angular/</id>
    <published>2019-07-22T03:01:27.000Z</published>
    <updated>2019-07-23T14:24:39.153Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Angular是web前端三大框架之一，和React、Vue相比，在中大型企业中，更具优势</p></blockquote><a id="more"></a><h2 id="初识Angular"><a href="#初识Angular" class="headerlink" title="初识Angular"></a>初识Angular</h2><blockquote><p>Angular是一款来自谷歌的开源web框架，诞生于2009年，是一款优秀的JS框架，由Misko Hevery等人创建，后被Google收购</p><ul><li>根据项目统计angular是现在网上使用量最大的框架</li></ul></blockquote><h3 id="Angular适用的场景"><a href="#Angular适用的场景" class="headerlink" title="Angular适用的场景"></a>Angular适用的场景</h3><ul><li>Angular基于Typescript和React、Vue相比，更适合中大型企业级项目<h3 id="环境搭建步骤"><a href="#环境搭建步骤" class="headerlink" title="环境搭建步骤"></a>环境搭建步骤</h3></li><li>需要安装Nodejs，这个是框架开发必备的环境了，就不多说了-&gt;<a href="http://nodejs.cn/" target="_blank" rel="noopener">Nodejs官网</a></li><li>由于国内网络问题，尽量使用<code>cnpm</code>淘宝镜像</li><li>安装Angular脚手架<code>cnpm i -g @angular/cli</code></li><li>查看是否安装成功<code>ng v</code></li><li>创建angular项目:例如创建以一个名为my-app的项目：<code>ng new my-app</code>,你也可以使用<code>ng new my-app --skip-install</code>跳过npm安装</li><li>安装完之后会问你是否需要路由，可以按需选择，然后选择预处理器<code>LESS</code>和<code>SCSS</code>，也可以不选，直接选择<code>CSS</code>,选择后回车</li><li>这个时候如果使用<code>ng new my-app</code>会自动安装依赖，我们直接Ctrl+C停止，因为npm安装容易被墙安装失败，我们使用<code>cnpm i</code>即可安装，当然，如果你的电脑安装了<code>yarn</code>也可以直接使用<code>yarn</code>命令进行安装，如果使用<code>ng new my-app --skip-install</code>，则直接使用<code>cnpm i</code></li><li>安装完毕之后<code>cd my-app</code>使用<code>ng serve --open</code>即可打开这个项目</li><li>使用cnpm安装：<br><img src="https://s2.ax1x.com/2019/07/22/eCcReJ.jpg" alt="cnpm"></li><li>使用yarn安装:<br><img src="https://s2.ax1x.com/2019/07/22/eCcNLQ.jpg" alt="yarn"></li><li>启动项目<br><img src="https://s2.ax1x.com/2019/07/22/eCctsg.jpg" alt="启动"><br><img src="https://s2.ax1x.com/2019/07/22/eCcSr4.jpg" alt="启动完成"></li><li><strong>注意</strong>：IE版本较低的浏览器不支持，如果默认是IE浏览器可以修改默认浏览器或者黏贴网址到其他浏览器打开<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4></li><li>有时候我们经常因为依赖包安装出错导致项目不能运行，这个时候需要删除<code>node_modules</code>，如果直接删除因为目录层级太深，需要好久，在这里我们只需要使用如下步骤即可超快删除</li><li>安装<code>cnpm install rimraf -g</code></li><li>使用：cd到你要删除的文件夹运行<code>rimraf 你要删除的文件或者文件夹</code></li><li>当然这个包功能还是很强大的,可以去官网查看其他用途 -&gt; <a href="https://www.npmjs.com/package/rimraf" target="_blank" rel="noopener">rimraf</a><h3 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h3></li><li>在src下的app创建一个文件夹名为components的news组件<code>ng g componet components/news</code>，如果不指定文件夹，就会创建到app根目录下</li><li>使用命令行创建它自动会关联组件，使用的时候只需要在根组件放置对应的标签即可，标签名在组件种的<code>组件名.component.ts</code>中的<code>selector</code>属性值，内容就是<code>组件名.component.html</code>中的内容</li><li>找到app根目录下的<code>app.component.html</code>，以标签形式放置<code>selector</code>的属性值即可展示对应组件的内容</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Angular是web前端三大框架之一，和React、Vue相比，在中大型企业中，更具优势&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Angular" scheme="https://zhongyuehui.github.io/categories/Angular/"/>
    
    
      <category term="Angular" scheme="https://zhongyuehui.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>React中绑定this并传参的几种方式</title>
    <link href="https://zhongyuehui.github.io/2019/07/16/React%E4%B8%AD%E7%BB%91%E5%AE%9Athis%E5%B9%B6%E4%BC%A0%E5%8F%82%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://zhongyuehui.github.io/2019/07/16/React中绑定this并传参的几种方式/</id>
    <published>2019-07-16T02:58:17.000Z</published>
    <updated>2019-07-16T03:03:28.971Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在React中，由于函数的this指向问题，我们需要绑定函数内部中的this指向，这样才能成功的调用并传递参数</p></blockquote><a id="more"></a><h2 id="React中绑定this并传参的几种方式"><a href="#React中绑定this并传参的几种方式" class="headerlink" title="React中绑定this并传参的几种方式"></a>React中绑定this并传参的几种方式</h2><blockquote><p>在React中的传参方式中，总结了一些解决函数内部的this指向问题和传参的问题。</p></blockquote><h3 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h3><ul><li><p>在事件函数处理中，直接使用bind绑定this并传参</p>  <figure class="highlight scala hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// bindThis.jsx</span></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-type">React</span> from <span class="hljs-string">"react"</span>;</span><br><span class="line">export <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BindThist</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>(props);</span><br><span class="line">    <span class="hljs-keyword">this</span>.state = &#123;</span><br><span class="line">      mes: <span class="hljs-string">"绑定this并传参"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;绑定<span class="hljs-type">This</span>传参的方式&lt;/h1&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="hljs-keyword">this</span>.changeMes.bind(<span class="hljs-keyword">this</span>, <span class="hljs-string">"🐖"</span>, <span class="hljs-string">"🐕"</span>)&#125;&gt;</span><br><span class="line">          绑定<span class="hljs-type">This</span>传参</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">        &lt;h4&gt;&#123;<span class="hljs-keyword">this</span>.state.mes&#125;&lt;/h4&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  changeMes(pig, dog) &#123;</span><br><span class="line">  <span class="hljs-comment">//这个时候因为this指向问题，所以会报错undefined，所以需要修改this的指向</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.setState(&#123;</span><br><span class="line">      mes: <span class="hljs-string">"修改了"</span> + pig + dog</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>bind</strong>的作用：为前面的函数，修改函数中的this指向，让函数内部的this，指向bind参数列表中的第一个参数</p></li><li><p><strong>bind和call/apply之间的区别</strong>:call/apply修改完this的指向后会立即调用前面的函数，bind方法的返回值是改变了this指向的原函数的拷贝，但是不会对原函数的this进行改变</p></li><li><p><strong>注意：</strong>bind中的第一个参数，是用来修改this指向的，第一个参数后面所有的参数，都会当作将来调用前面函数时的参数</p><h3 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h3></li><li><p>在constructor中改变函数this</p>  <figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BindThist</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>(props);</span><br><span class="line">    <span class="hljs-comment">/*因为函数执行必然会执行constructor函数，所以我们在这对函数的this进行修改</span></span><br><span class="line"><span class="hljs-comment">    注意：bind方法并不会修改原函数，而是返回一个修改后的原函数拷贝，就是返回一个修改了this的函数，所以我们需要接收一下</span></span><br><span class="line"><span class="hljs-comment">    注意：这个时候我们使用原函数进行接收，这样就覆盖了没有修改this的函数</span></span><br><span class="line"><span class="hljs-comment">    */</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.changeMes = <span class="hljs-keyword">this</span>.changeMes.bind(<span class="hljs-keyword">this</span>, <span class="hljs-string">"🐖"</span>, <span class="hljs-string">"🐕"</span>);</span><br><span class="line">    <span class="hljs-keyword">this</span>.state = &#123;</span><br><span class="line">      mes: <span class="hljs-string">"绑定this并传参"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;绑定This传参的方式&lt;<span class="hljs-regexp">/h1&gt;</span></span><br><span class="line"><span class="hljs-regexp">        &#123;/</span>* 因为在上面我们已经修改过<span class="hljs-keyword">this</span>的指向了，所以在这里并不需要进行修改 *<span class="hljs-regexp">/&#125;</span></span><br><span class="line"><span class="hljs-regexp">        &lt;button onClick=&#123;this.changeMes&#125;&gt;绑定This传参&lt;/</span>button&gt;</span><br><span class="line">        &lt;h4&gt;&#123;<span class="hljs-keyword">this</span>.state.mes&#125;&lt;<span class="hljs-regexp">/h4&gt;</span></span><br><span class="line"><span class="hljs-regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  changeMes(pig, dog) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.setState(&#123;</span><br><span class="line">      mes: <span class="hljs-string">"修改了"</span> + pig + dog</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="第三种方式"><a href="#第三种方式" class="headerlink" title="第三种方式"></a>第三种方式</h3><ul><li><p>在调用时使用箭头函数</p>  <figure class="highlight scala hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-type">React</span> from <span class="hljs-string">"react"</span>;</span><br><span class="line">export <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BindThist</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>(props);</span><br><span class="line">    <span class="hljs-keyword">this</span>.state = &#123;</span><br><span class="line">      mes: <span class="hljs-string">"绑定this并传参"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;绑定<span class="hljs-type">This</span>传参的方式&lt;/h1&gt;</span><br><span class="line">        &#123;<span class="hljs-comment">/* 因为此时的this就是我们的实例，这个时候去调用函数，那么被调用函数中this就是指向这个调用者，就是实例对象 */</span>&#125;</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;() =&gt; &#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.changeMes(<span class="hljs-string">"🐖"</span>, <span class="hljs-string">"🐕"</span>);</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          绑定<span class="hljs-type">This</span>传参</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">        &lt;h4&gt;&#123;<span class="hljs-keyword">this</span>.state.mes&#125;&lt;/h4&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  changeMes(pig, dog) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.setState(&#123;</span><br><span class="line">      mes: <span class="hljs-string">"修改了"</span> + pig + dog</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>但是需要注意的是； <code>&lt;button onClick={() =&gt; {this.changeMes(&quot;🐖&quot;, &quot;🐕&quot;);}}&gt;绑定This传参&lt;/button&gt;</code>中我们不能省略<code>()=&gt;</code>写成<code>&lt;button onClick={this.changeMes(&quot;🐖&quot;, &quot;🐕&quot;);}&gt;绑定This传参&lt;/button&gt;</code>，这样的话React在解析的时候发现这个是一个函数调用，那么就会立即进行调用，如果使用的是箭头函数，它会解析成你点击的时候再来触发这个函数，这样才是我们想要的结果</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在React中，由于函数的this指向问题，我们需要绑定函数内部中的this指向，这样才能成功的调用并传递参数&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="React" scheme="https://zhongyuehui.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://zhongyuehui.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript中的装饰器</title>
    <link href="https://zhongyuehui.github.io/2019/07/09/TypeScript%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>https://zhongyuehui.github.io/2019/07/09/TypeScript中的装饰器/</id>
    <published>2019-07-09T15:34:31.000Z</published>
    <updated>2019-07-09T15:38:46.238Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>装饰器是过去几年中JavaScript最大成就之一，已是ES7的标准特性之一</p></blockquote><a id="more"></a><h2 id="TypeScript中的装饰器"><a href="#TypeScript中的装饰器" class="headerlink" title="TypeScript中的装饰器"></a>TypeScript中的装饰器</h2><ul><li>装饰器：装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，属性或参数上，可以修改类的行为</li><li><strong>常见的装饰器</strong><ul><li>类装饰器</li><li>属性装饰器</li><li>方法装饰器</li><li>参数装饰器</li></ul></li><li><strong>装饰器的写法</strong><ul><li>普通装饰器（不可传参）</li><li>工厂装饰器（可传参）<h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3></li></ul></li><li>类装饰器在类声明之前被声明(紧靠类声明)。类装饰器应用于构造函数，可以用来监视，修改或替换类定义。传入一个参数<h4 id="定义一个普通的装饰器-类装饰器"><a href="#定义一个普通的装饰器-类装饰器" class="headerlink" title="定义一个普通的装饰器(类装饰器)"></a>定义一个普通的装饰器(类装饰器)</h4></li><li>   <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>(<span class="hljs-params">params: <span class="hljs-built_in">any</span></span>) </span>&#123; <span class="hljs-comment">//普通模式是Http</span></span><br><span class="line">  params.prototype.data = <span class="hljs-string">"hello"</span>;</span><br><span class="line">  params.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"我是run"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@getData</span> <span class="hljs-comment">//这里不能使用 ; 号</span></span><br><span class="line"><span class="hljs-keyword">class</span> Http &#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> http: <span class="hljs-built_in">any</span> = <span class="hljs-keyword">new</span> Http();</span><br><span class="line"><span class="hljs-built_in">console</span>.log(http.data); <span class="hljs-comment">//hello</span></span><br><span class="line">http.run(); <span class="hljs-comment">//我是run</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="定义一个工厂装饰器"><a href="#定义一个工厂装饰器" class="headerlink" title="定义一个工厂装饰器"></a>定义一个工厂装饰器</h4><ul><li>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>(<span class="hljs-params">params: <span class="hljs-built_in">string</span></span>) </span>&#123; <span class="hljs-comment">//工厂装饰器params是传递的参数</span></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params">targe: <span class="hljs-built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(targe); <span class="hljs-comment">//[Function Http] 这个表示Http</span></span><br><span class="line">    <span class="hljs-built_in">console</span>.log(params); <span class="hljs-comment">//hh 传递的参数</span></span><br><span class="line">    targe.prototype.api = params;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@getData</span>(<span class="hljs-string">"hh"</span>)</span><br><span class="line"><span class="hljs-keyword">class</span> Http &#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> http: <span class="hljs-built_in">any</span> = <span class="hljs-keyword">new</span> Http();</span><br><span class="line"><span class="hljs-built_in">console</span>.log(http.api); <span class="hljs-comment">//hh</span></span><br></pre></td></tr></table></figure>  <figure class="highlight scala hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function getData(params: any) &#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">params</span> </span>&#123;<span class="hljs-comment">//这里的params相当于是Http 继承它</span></span><br><span class="line">    api: any = <span class="hljs-string">"我是修改后的api"</span>;</span><br><span class="line">    getdata() &#123;</span><br><span class="line">      <span class="hljs-keyword">this</span>.api = <span class="hljs-keyword">this</span>.api + <span class="hljs-string">"--"</span>;</span><br><span class="line">      console.log(<span class="hljs-keyword">this</span>.api);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@getData</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Http</span> </span>&#123;</span><br><span class="line">  public api: string | undefined;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.api = <span class="hljs-string">"我是api"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  getdata() &#123;</span><br><span class="line">    console.log(<span class="hljs-keyword">this</span>.api);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> h = <span class="hljs-keyword">new</span> <span class="hljs-type">Http</span>();</span><br><span class="line">h.getdata(); <span class="hljs-comment">//我是修改后的api</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h3><ul><li>属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数：<ul><li>一是：对于静态成员来说是类的构造函数，对于示例成员是类的原型对象</li><li>二是：成员的名字<figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 类装饰器</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logClass</span>(<span class="hljs-params">params: <span class="hljs-built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">//params 是传递的参数</span></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//target是 Htpp</span></span><br><span class="line">    <span class="hljs-built_in">console</span>.log(params); <span class="hljs-comment">// xxx</span></span><br><span class="line">    <span class="hljs-built_in">console</span>.log(target); <span class="hljs-comment">//[Function: Http]</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//属性装饰器</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logUrl</span>(<span class="hljs-params">params: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">any</span> </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(params); <span class="hljs-comment">//www.baidu.com</span></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, attr: <span class="hljs-built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(target); <span class="hljs-comment">//http&#123;&#125; 第一个参数就是成员(在这里指的是url)实例的原型对象</span></span><br><span class="line">    <span class="hljs-built_in">console</span>.log(attr); <span class="hljs-comment">//url   第二个参数打印出来的就是装饰属性的名称</span></span><br><span class="line">    target[attr] = params; <span class="hljs-comment">//因为attr是变量所以不能通过 . 的方式访问，而target是实例的原型对象，这里就相当于在实例的原型对象上添加了attr属性并且赋值</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@logClass</span>(<span class="hljs-string">"xxx"</span>)</span><br><span class="line"><span class="hljs-keyword">class</span> Http &#123;</span><br><span class="line">  <span class="hljs-meta">@logUrl</span>(<span class="hljs-string">"www.baidu.com"</span>)</span><br><span class="line">  <span class="hljs-keyword">public</span> url: <span class="hljs-built_in">any</span>;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;</span><br><span class="line">  getdata() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.url);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> h = <span class="hljs-keyword">new</span> Http();</span><br><span class="line">h.getdata(); <span class="hljs-comment">//www.baidu.com</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(h.url); <span class="hljs-comment">//www.baidu.com</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h3><ul><li><p>方法装饰器：他会被应用到方法的属性描述符上，可以用来监视，修改或者替换方法定义</p></li><li><p>方法装饰会在运行时传入三个参数</p><ul><li>1.对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li><li>2.成员的名称</li><li>3.成员的属性描述</li></ul></li><li><p>方法装饰器一：(查看一些属性)</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logMethod</span>(<span class="hljs-params">params: <span class="hljs-built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">targe: <span class="hljs-built_in">any</span>, methodName: <span class="hljs-built_in">any</span>, desc: <span class="hljs-built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//   console.log(targe); // Http &#123; getdata: [Function] &#125;</span></span><br><span class="line">    <span class="hljs-comment">// console.log(methodName); // getdata</span></span><br><span class="line">    <span class="hljs-built_in">console</span>.log(desc); <span class="hljs-comment">//&#123; value: [Function], writable: true,enumerable: true,configurable: true&#125;</span></span><br><span class="line">    targe.api = <span class="hljs-string">"www.baidu.com"</span>;</span><br><span class="line">    targe.run = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">class</span> Http &#123;</span><br><span class="line">  <span class="hljs-keyword">public</span> url: <span class="hljs-built_in">any</span>;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;</span><br><span class="line">  <span class="hljs-meta">@logMethod</span>(<span class="hljs-string">"www.baidu.com"</span>)</span><br><span class="line">  getdata() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.url);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> h: <span class="hljs-built_in">any</span> = <span class="hljs-keyword">new</span> Http();</span><br><span class="line"><span class="hljs-built_in">console</span>.log(h.api); <span class="hljs-comment">//www.baidu.com</span></span><br><span class="line">h.run(); <span class="hljs-comment">//hello</span></span><br></pre></td></tr></table></figure></li><li><p>方法装饰器二：(修改方法)</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logMethod</span>(<span class="hljs-params">params: <span class="hljs-built_in">string</span></span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">targe: <span class="hljs-built_in">any</span>, methodName: <span class="hljs-built_in">any</span>, desc: <span class="hljs-built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(desc.value); <span class="hljs-comment">//这个就是方法的函数</span></span><br><span class="line">    <span class="hljs-keyword">var</span> funDesc = desc.value; <span class="hljs-comment">//保存一下原来的方法</span></span><br><span class="line">    desc.value = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>) </span>&#123;<span class="hljs-comment">//修改方法</span></span><br><span class="line">    args = args.map(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(value); <span class="hljs-comment">//将传递的参数全部变成String类型</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(args);</span><br><span class="line">    funDesc.apply(<span class="hljs-keyword">this</span>, args); <span class="hljs-comment">//这样可以将保存到的getdata指向这个新的函数，然后传递已经处理好的数据 args</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">class</span> Http &#123;</span><br><span class="line"><span class="hljs-keyword">public</span> url: <span class="hljs-built_in">any</span>;</span><br><span class="line"><span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;</span><br><span class="line"><span class="hljs-meta">@logMethod</span>(<span class="hljs-string">"www.baidu.com"</span>)</span><br><span class="line">getdata(...args: <span class="hljs-built_in">any</span>[]) &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(args); <span class="hljs-comment">//[ 'ads', '123' ]</span></span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello"</span>); <span class="hljs-comment">//hello</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> h = <span class="hljs-keyword">new</span> Http();</span><br><span class="line">h.getdata(<span class="hljs-string">"ads"</span>, <span class="hljs-number">123</span>); <span class="hljs-comment">// [ 'ads', '123' ]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="方法参数装饰器"><a href="#方法参数装饰器" class="headerlink" title="方法参数装饰器"></a>方法参数装饰器</h3><ul><li><p>参数装饰器表达式会在运行时当作函数被调用，可与使用参数装饰器为类的原型增加一些元素数据，传入三个参数</p><ul><li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li><li>方法的名字</li><li>参数在函数参数列表中的索引</li></ul><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logMethod</span>(<span class="hljs-params">params: <span class="hljs-built_in">any</span></span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">targe: <span class="hljs-built_in">any</span>, methodName: <span class="hljs-built_in">any</span>, paramsIndex: <span class="hljs-built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(params); <span class="hljs-comment">//装饰器传入的值 xxx</span></span><br><span class="line">    <span class="hljs-built_in">console</span>.log(targe); <span class="hljs-comment">// Http &#123; getdata: [Function] &#125; 类的原型对象</span></span><br><span class="line">    <span class="hljs-built_in">console</span>.log(methodName); <span class="hljs-comment">//getdata  方法名称</span></span><br><span class="line">    <span class="hljs-built_in">console</span>.log(paramsIndex); <span class="hljs-comment">// 0 //参数索引</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">class</span> Http &#123;</span><br><span class="line"><span class="hljs-keyword">public</span> url: <span class="hljs-built_in">any</span>;</span><br><span class="line"><span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;</span><br><span class="line">getdata(<span class="hljs-meta">@logMethod</span>(<span class="hljs-string">"xxx"</span>) params: <span class="hljs-built_in">any</span>) &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(params); <span class="hljs-comment">//123</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> h = <span class="hljs-keyword">new</span> Http();</span><br><span class="line">h.getdata(<span class="hljs-number">123</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="装饰器的执行顺序"><a href="#装饰器的执行顺序" class="headerlink" title="装饰器的执行顺序"></a>装饰器的执行顺序</h3><ul><li>执行顺序：<ul><li>1.属性装饰器</li><li>2.方法装饰器</li><li>3.方法参数装饰器</li><li>4.类装饰器</li></ul></li><li><strong>注意</strong>：如果有多个同种装饰器，是从后往前执行<ul><li>如：有两个参数装饰器限制性后面的参数装饰器，如果有两个属性装饰器，限制性后面定义的属性装饰器<blockquote><p>以上就是关于TypeScript中的装饰器相关的知识。</p></blockquote></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;装饰器是过去几年中JavaScript最大成就之一，已是ES7的标准特性之一&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="https://zhongyuehui.github.io/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://zhongyuehui.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript中的模块以及命名空间</title>
    <link href="https://zhongyuehui.github.io/2019/07/09/TypeScript%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E4%BB%A5%E5%8F%8A%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    <id>https://zhongyuehui.github.io/2019/07/09/TypeScript中的模块以及命名空间/</id>
    <published>2019-07-09T15:33:30.000Z</published>
    <updated>2019-07-09T15:34:15.951Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于TypeScript中的模块化在1.5版本中发生了变化，”内部模块”现在称为”命名空间”，外部模块现在简称为”模块”</p></blockquote><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在模块化的概念中，模块(外部模块)在其自身的作用域里执行，而不是在全局作用域里，这也意味着定义一个模块的变量、函数、类等等在模块的外部都是不可见的，除非你明确地使用 export形式导出它们。相反，如果使用其他模块导出的变量、函数、接口时，必须导入，可以使用import形式导入。</p></blockquote><h2 id="TypeScript中的模块以及命名空间"><a href="#TypeScript中的模块以及命名空间" class="headerlink" title="TypeScript中的模块以及命名空间"></a>TypeScript中的模块以及命名空间</h2><ul><li><p>使用 <strong>export</strong> 导出模块</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//这是一个 db.ts文件</span></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>(<span class="hljs-params"></span>): <span class="hljs-title">any</span>[] </span>&#123; <span class="hljs-comment">//导出方法</span></span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"获取数据库"</span>);</span><br><span class="line">  <span class="hljs-keyword">return</span> [&#123; title: <span class="hljs-string">"中国美食"</span> &#125;];</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> data = <span class="hljs-string">"hello"</span>; <span class="hljs-comment">//导出变量</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <strong>import</strong> 导入模块</p>  <figure class="highlight lasso hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//这是index.ts</span></span><br><span class="line"><span class="hljs-keyword">import</span> &#123; getData, <span class="hljs-built_in">data</span> &#125; from <span class="hljs-string">"./modules/db"</span>;<span class="hljs-comment">//这里的db不需要加 ts后缀</span></span><br><span class="line">getData(); <span class="hljs-comment">//获取数据库</span></span><br><span class="line">console.<span class="hljs-keyword">log</span>(<span class="hljs-built_in">data</span>); <span class="hljs-comment">//hello</span></span><br></pre></td></tr></table></figure></li><li><p>因为在之前我们已经说过模块化的导入导出问题(<a href="http://www.zhongyuehui.cn/2019/07/09/ES6%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E4%B8%8E%E5%AF%BC%E5%87%BA/#more" target="_blank" rel="noopener"><strong>模块的导入与导出</strong></a>)</p><h3 id="命名空间和模块化的区别"><a href="#命名空间和模块化的区别" class="headerlink" title="命名空间和模块化的区别"></a>命名空间和模块化的区别</h3></li><li><p><strong>命名空间</strong>:内部模块，主要用于组织代码，避免命名冲突</p></li><li><p><strong>模块</strong>:ts的外部模块的简称，侧重代码的复用，一个模块可能会有多个命名空间</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">namespace</span> A &#123;</span><br><span class="line">  <span class="hljs-keyword">interface</span> Animal &#123;</span><br><span class="line">    name: <span class="hljs-built_in">string</span>;</span><br><span class="line">    eat(str: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">class</span> Dog <span class="hljs-keyword">implements</span> Animal &#123;</span><br><span class="line">    name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//必须定义</span></span><br><span class="line">    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    eat() &#123;</span><br><span class="line">      <span class="hljs-comment">//必须定义</span></span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;this.name&#125;</span>爱吃粮食`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">"小黑"</span>);</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(d.eat()); <span class="hljs-comment">//小黑爱吃粮食</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">class</span> Cat <span class="hljs-keyword">implements</span> Animal &#123;</span><br><span class="line">    name: <span class="hljs-built_in">string</span>;</span><br><span class="line">    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    eat(food: <span class="hljs-built_in">string</span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;this.name&#125;</span>爱吃<span class="hljs-subst">$&#123;food&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">"小花猫"</span>);</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(c.eat(<span class="hljs-string">"小老鼠"</span>)); <span class="hljs-comment">//小花猫爱吃小老鼠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">namespace</span> B &#123;</span><br><span class="line">  <span class="hljs-keyword">interface</span> Animal &#123;</span><br><span class="line">    name: <span class="hljs-built_in">string</span>;</span><br><span class="line">    eat(str: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">class</span> Dog <span class="hljs-keyword">implements</span> Animal &#123;</span><br><span class="line">    name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//必须定义</span></span><br><span class="line">    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    eat() &#123;</span><br><span class="line">      <span class="hljs-comment">//必须定义</span></span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;this.name&#125;</span>爱吃粮食`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">"小黑"</span>);</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(d.eat()); <span class="hljs-comment">//小黑爱吃粮食</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">class</span> Cat <span class="hljs-keyword">implements</span> Animal &#123;</span><br><span class="line">    name: <span class="hljs-built_in">string</span>;</span><br><span class="line">    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    eat(food: <span class="hljs-built_in">string</span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;this.name&#125;</span>爱吃<span class="hljs-subst">$&#123;food&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">"小花猫"</span>);</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(c.eat(<span class="hljs-string">"小老鼠"</span>)); <span class="hljs-comment">//小花猫爱吃小老鼠</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这样我们就可以在一个文件中定义相同的名字的数据了，但是这样的数据是私有的，如果我们像使用里面的数据。需要暴露出来</p></li><li><p>使用暴露并使用命名空间中的数据</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">namespace</span> A &#123;</span><br><span class="line">  <span class="hljs-keyword">interface</span> Animal &#123;</span><br><span class="line">    name: <span class="hljs-built_in">string</span>;</span><br><span class="line">    eat(str: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> Dog <span class="hljs-keyword">implements</span> Animal &#123;  <span class="hljs-comment">//向外暴露类</span></span><br><span class="line">    name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//必须定义</span></span><br><span class="line">    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    eat() &#123;</span><br><span class="line">      <span class="hljs-comment">//必须定义</span></span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;this.name&#125;</span>爱吃粮食`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> Cat <span class="hljs-keyword">implements</span> Animal &#123; <span class="hljs-comment">//向外暴露类</span></span><br><span class="line">    name: <span class="hljs-built_in">string</span>;</span><br><span class="line">    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    eat(food: <span class="hljs-built_in">string</span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;this.name&#125;</span>爱吃<span class="hljs-subst">$&#123;food&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> A.Cat(<span class="hljs-string">"小狼狗"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(c.eat(<span class="hljs-string">"狗粮"</span>)); <span class="hljs-comment">//小狼狗爱吃粮食</span></span><br></pre></td></tr></table></figure></li><li><p>我们还可以将命名空间封装在一个模块中，我们在使用的时候只需要导入就可以使用了，一个模块中可以有多个命名空间</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//namespace.ts文件</span></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">namespace</span> A &#123;</span><br><span class="line">  <span class="hljs-keyword">interface</span> Animal &#123;</span><br><span class="line">    name: <span class="hljs-built_in">string</span>;</span><br><span class="line">    eat(str: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> Dog <span class="hljs-keyword">implements</span> Animal &#123;</span><br><span class="line">    name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//必须定义</span></span><br><span class="line">    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    eat() &#123;</span><br><span class="line">      <span class="hljs-comment">//必须定义</span></span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;this.name&#125;</span>爱吃粮食`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> Cat <span class="hljs-keyword">implements</span> Animal &#123;</span><br><span class="line">    name: <span class="hljs-built_in">string</span>;</span><br><span class="line">    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    eat(food: <span class="hljs-built_in">string</span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;this.name&#125;</span>爱吃<span class="hljs-subst">$&#123;food&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//index.ts文件</span></span><br><span class="line"><span class="hljs-keyword">import</span> &#123; A <span class="hljs-keyword">as</span> namespaceA &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"./namespace"</span>; <span class="hljs-comment">//引入模块并重命名</span></span><br><span class="line"><span class="hljs-keyword">let</span> dog = <span class="hljs-keyword">new</span> namespaceA.Cat(<span class="hljs-string">"小黑"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(dog.eat(<span class="hljs-string">"狗粮"</span>)); <span class="hljs-comment">//小黑爱吃狗粮</span></span><br></pre></td></tr></table></figure></li><li><p>需要注意的是，模块并不能直接在浏览器中运行，如果需要，则需要使用webpack对文件进行打包生成ES5的代码浏览器才能识别，我们可以使用Nodejs的环境来运行</p></li><li><p><font color="red"><strong>总结:</strong></font></p><ul><li>模块就是封装了一些功能的代码</li><li>命名空间在模块中，且一个模块中可以有多个命名空间</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;关于TypeScript中的模块化在1.5版本中发生了变化，”内部模块”现在称为”命名空间”，外部模块现在简称为”模块”&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="https://zhongyuehui.github.io/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://zhongyuehui.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript对类型、接口、类、泛型的综合运用</title>
    <link href="https://zhongyuehui.github.io/2019/07/09/TypeScript%E5%AF%B9%E7%B1%BB%E5%9E%8B%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E7%B1%BB%E3%80%81%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%BB%BC%E5%90%88%E8%BF%90%E7%94%A8/"/>
    <id>https://zhongyuehui.github.io/2019/07/09/TypeScript对类型、接口、类、泛型的综合运用/</id>
    <published>2019-07-09T11:01:11.000Z</published>
    <updated>2019-07-12T02:48:11.896Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>定义一个操作数据库的类</p></blockquote><a id="more"></a><h2 id="Typescript对类型、接口、类、泛型的综合使用"><a href="#Typescript对类型、接口、类、泛型的综合使用" class="headerlink" title="Typescript对类型、接口、类、泛型的综合使用"></a>Typescript对类型、接口、类、泛型的综合使用</h2><ul><li><p>综合使用</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> DBI&lt;T&gt; &#123;</span><br><span class="line">  add(info: T): <span class="hljs-built_in">boolean</span>;</span><br><span class="line">  updata(info: T, id: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">boolean</span>;</span><br><span class="line">  dalete(id: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">boolean</span>;</span><br><span class="line">  <span class="hljs-keyword">get</span>(id: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">any</span>[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//定义一个操作mysql数据库的类</span></span><br><span class="line"><span class="hljs-comment">//注意：如果需要实现泛型接口时，那么这个实现泛型接口的类也需要是一个泛型类</span></span><br><span class="line"><span class="hljs-keyword">class</span> Mysqldb&lt;T&gt; <span class="hljs-keyword">implements</span> DBI&lt;T&gt; &#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">// console.log("这里可以建立和数据库的连接");</span></span><br><span class="line">  &#125;</span><br><span class="line">  add(info: T): <span class="hljs-built_in">boolean</span> &#123; <span class="hljs-comment">//添加数据，这里可以进行对数据库的增加操作</span></span><br><span class="line">    <span class="hljs-built_in">console</span>.log(info);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  updata(info: T, id: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">boolean</span> &#123; <span class="hljs-comment">//根据id更新数据，对数据库进行更新操作</span></span><br><span class="line">    <span class="hljs-built_in">console</span>.log(info);</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(id);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  dalete(id: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">boolean</span> &#123; <span class="hljs-comment">//根据id删除数据，对数据库进行删除操作</span></span><br><span class="line">    <span class="hljs-built_in">console</span>.log(id);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">get</span>(id: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">any</span>[] &#123; <span class="hljs-comment">//根据id 得到数据，对数据库进行查找操作</span></span><br><span class="line">   <span class="hljs-built_in">console</span>.log(id);</span><br><span class="line">    <span class="hljs-keyword">let</span> lits:<span class="hljs-built_in">any</span>[]=[]</span><br><span class="line">    <span class="hljs-keyword">return</span> lits</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//定义操作mssql数据库的类</span></span><br><span class="line"><span class="hljs-keyword">class</span> MssqlDB&lt;T&gt; <span class="hljs-keyword">implements</span> DBI&lt;T&gt; &#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">// console.log("这里可以建立和数据库的连接");</span></span><br><span class="line">  &#125;</span><br><span class="line">  add(info: T): <span class="hljs-built_in">boolean</span> &#123; </span><br><span class="line">    <span class="hljs-built_in">console</span>.log(info);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  updata(info: T, id: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">boolean</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(info, id);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dalete(id: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">boolean</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(id)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">get</span>(id: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">any</span>[] &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(id);</span><br><span class="line">    <span class="hljs-keyword">let</span> lits:<span class="hljs-built_in">any</span>[]=[]</span><br><span class="line">    <span class="hljs-keyword">return</span> lits</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//定义一个User数据表做数据库的映射</span></span><br><span class="line"><span class="hljs-keyword">class</span> User &#123;</span><br><span class="line">  username: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;</span><br><span class="line">  password: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">params: &#123;</span></span><br><span class="line"><span class="hljs-params">    <span class="hljs-comment">//使用构造函数传值</span></span></span><br><span class="line"><span class="hljs-params">    username: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;</span></span><br><span class="line"><span class="hljs-params">    password: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;</span></span><br><span class="line"><span class="hljs-params">  &#125;</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.password = params.password;</span><br><span class="line">    <span class="hljs-keyword">this</span>.username = params.username;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//往数据表添加数据</span></span><br><span class="line"><span class="hljs-keyword">let</span> u = <span class="hljs-keyword">new</span> User(&#123;</span><br><span class="line">  username: <span class="hljs-string">"张三"</span>,</span><br><span class="line">  password: <span class="hljs-string">"123aaa"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//操作mysql</span></span><br><span class="line"><span class="hljs-comment">// let mysql = new Mysqldb(); //如果此时没有使用定义的user作为限制，add()中参数可以是任意值，没有做类型的校验</span></span><br><span class="line"><span class="hljs-comment">// mysql.add('aaa');</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> mysql = <span class="hljs-keyword">new</span> Mysqldb&lt;User&gt;(); <span class="hljs-comment">//此时使用User类作为限制类型，那么在实例化后的add中我们只能传入User类</span></span><br><span class="line">mysql.add(u); <span class="hljs-comment">//User &#123; password: '123aaa', username: '张三' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> m = <span class="hljs-keyword">new</span> User(&#123;</span><br><span class="line">  username: <span class="hljs-string">"李四"</span>,</span><br><span class="line">  password: <span class="hljs-string">"lisi"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-comment">// 操作mssql</span></span><br><span class="line"><span class="hljs-keyword">let</span> mssql = <span class="hljs-keyword">new</span> MssqlDB&lt;User&gt;();</span><br><span class="line">mssql.add(m); <span class="hljs-comment">// User &#123; password: 'lisi', username: '李四' &#125;</span></span><br><span class="line">mssql.updata(m, <span class="hljs-number">12</span>); <span class="hljs-comment">//User &#123; password: 'lisi', username: '李四' &#125; 12</span></span><br></pre></td></tr></table></figure></li><li><p>这样我们定义一个数据库的，只需要调用对应的数据库进行数据操作，而且对不同的数据库都是兼容的。当然，这些代码还可以封装到模块里面去，每个数据库的类封装一个模块。这样我们调用的时候只需要引入模块即可进行增删改查的相关操作了。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;定义一个操作数据库的类&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="https://zhongyuehui.github.io/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://zhongyuehui.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript中的泛型</title>
    <link href="https://zhongyuehui.github.io/2019/07/09/TypeScript%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B/"/>
    <id>https://zhongyuehui.github.io/2019/07/09/TypeScript中的泛型/</id>
    <published>2019-07-09T10:57:05.000Z</published>
    <updated>2019-07-09T11:16:03.495Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>泛型：软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性，组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能</p></blockquote><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在像C#和java这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据，这样用户就可以以自己的数据类型来使用组件。</p></blockquote><h2 id="TypeScript中的泛型"><a href="#TypeScript中的泛型" class="headerlink" title="TypeScript中的泛型"></a>TypeScript中的泛型</h2><ul><li><p><strong>通俗理解:泛型就是解决类接口方法的复用性、以及对不特定数据类型的支持</strong></p></li><li><p>同时返回 string类型和number类型(但是代码冗余严重)</p>  <figure class="highlight fortran hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span></span> getData(<span class="hljs-keyword">value</span>: string): string &#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span></span> getData1(<span class="hljs-keyword">value</span>: <span class="hljs-keyword">number</span>): <span class="hljs-keyword">number</span> &#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span></span> getData3(<span class="hljs-keyword">value</span>: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">any</span> &#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (typeof <span class="hljs-keyword">value</span> === <span class="hljs-string">"string"</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> `我是$&#123;<span class="hljs-keyword">value</span>&#125;`;</span><br><span class="line">  &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> `今年$&#123;<span class="hljs-keyword">value</span>&#125;`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="hljs-built_in">log</span>(getData3(<span class="hljs-string">"张三"</span>)); //我是张三</span><br><span class="line">console.<span class="hljs-built_in">log</span>(getData3(<span class="hljs-number">12</span>)); //我今年<span class="hljs-number">12</span></span><br></pre></td></tr></table></figure></li><li><p>使用any也可以同时返回string和number类型，但是相当于放弃了类型检查</p>  <figure class="highlight fortran hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span></span> getData(<span class="hljs-keyword">value</span>:<span class="hljs-built_in">any</span>):<span class="hljs-built_in">any</span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span></span><br><span class="line">&#125;</span><br><span class="line">console.<span class="hljs-built_in">log</span>(getData(<span class="hljs-number">12</span>)); //<span class="hljs-number">12</span></span><br><span class="line">console.<span class="hljs-built_in">log</span>(getData(<span class="hljs-string">'张三'</span>));//张三</span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul><li><p>一般我们定义泛型的时候，在函数名后面使用<code>&lt;任意字母&gt;</code>表示泛型，但是为了规范我们一般使用 <strong>T</strong>表示，函数定义了泛型后传入的参数也需要定义泛型，但是函数的返回值可以任意类型</p>  <figure class="highlight qml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">value: T</span>): <span class="hljs-title">T</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(getData&lt;number&gt;(<span class="hljs-number">12</span>)); <span class="hljs-comment">//12</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(getData&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">"张三"</span>)); <span class="hljs-comment">//张三</span></span><br></pre></td></tr></table></figure></li><li><p>注意：在传入参数的时候定义的类型必须和参数类型一致</p>  <figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">value: T</span>): <span class="hljs-title">any</span> </span>&#123; <span class="hljs-comment">//当函数的返回类型是any时，可以定义任意返回值</span></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(getData(<span class="hljs-string">"zs"</span>)); <span class="hljs-comment">//hello</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><ul><li><p>普通取最小值</p>  <figure class="highlight processing hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Sort &#123;</span><br><span class="line">  <span class="hljs-keyword">public</span> list: number[] = [];</span><br><span class="line">  <span class="hljs-built_in">add</span>(num: number) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.list.push(num);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-built_in">min</span>(): number &#123;</span><br><span class="line">    let <span class="hljs-built_in">min</span> = <span class="hljs-keyword">this</span>.list[<span class="hljs-number">0</span>];</span><br><span class="line">    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-keyword">this</span>.list.length; i++) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span> &gt; <span class="hljs-keyword">this</span>.list[i]) &#123;</span><br><span class="line">        <span class="hljs-built_in">min</span> = <span class="hljs-keyword">this</span>.list[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let m = <span class="hljs-keyword">new</span> Sort();</span><br><span class="line">m.<span class="hljs-built_in">add</span>(<span class="hljs-number">10</span>);</span><br><span class="line">m.<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>);</span><br><span class="line">m.<span class="hljs-built_in">add</span>(<span class="hljs-number">20</span>);</span><br><span class="line">console.<span class="hljs-built_in">log</span>(m.<span class="hljs-built_in">min</span>()); <span class="hljs-comment">//1</span></span><br></pre></td></tr></table></figure></li><li><p>这样定义的类我们不能往数组里面添加字母，不能实现字母的排序，所以需要使用泛型</p>  <figure class="highlight processing hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Sort&lt;T&gt; &#123;</span><br><span class="line">   <span class="hljs-keyword">public</span> list: T[] = [];</span><br><span class="line">   <span class="hljs-built_in">add</span>(value: T): <span class="hljs-keyword">void</span> &#123;</span><br><span class="line">     <span class="hljs-keyword">this</span>.list.push(value);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="hljs-built_in">min</span>(): T &#123;</span><br><span class="line">     let <span class="hljs-built_in">min</span> = <span class="hljs-keyword">this</span>.list[<span class="hljs-number">0</span>];</span><br><span class="line">     <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-keyword">this</span>.list.length; i++) &#123;</span><br><span class="line">       <span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span> &gt; <span class="hljs-keyword">this</span>.list[i]) &#123;</span><br><span class="line">         <span class="hljs-built_in">min</span> = <span class="hljs-keyword">this</span>.list[i];</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> let m = <span class="hljs-keyword">new</span> Sort&lt;number&gt;(); <span class="hljs-comment">//实例化 并且指定了T代表number</span></span><br><span class="line"> m.<span class="hljs-built_in">add</span>(<span class="hljs-number">20</span>);</span><br><span class="line"> m.<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>);</span><br><span class="line"> m.<span class="hljs-built_in">add</span>(<span class="hljs-number">10</span>);</span><br><span class="line"> console.<span class="hljs-built_in">log</span>(m.<span class="hljs-built_in">min</span>()); <span class="hljs-comment">// 1</span></span><br><span class="line"> let m2 = <span class="hljs-keyword">new</span> Sort&lt;string&gt;(); <span class="hljs-comment">// 实例化 并且指定了T代表string</span></span><br><span class="line"> m2.<span class="hljs-built_in">add</span>(<span class="hljs-string">"a"</span>);</span><br><span class="line"> m2.<span class="hljs-built_in">add</span>(<span class="hljs-string">"v"</span>);</span><br><span class="line"> console.<span class="hljs-built_in">log</span>(m2.<span class="hljs-built_in">min</span>());</span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><ul><li><p>如果我们在定义一个函数接口时，无法根据传入的参数类型作为返回数据类型，不够灵活</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> Config &#123;</span><br><span class="line">  (name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">let</span> getData: Config = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">string</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> name + age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(getData(<span class="hljs-string">"张三"</span>, <span class="hljs-number">12</span>)); <span class="hljs-comment">//张三 12</span></span><br></pre></td></tr></table></figure></li><li><p>定义泛型函数接口的时候，并不是我们在函数中规定了数据的类型，而是在调用的时候传入类型，那么这个泛型就是传入的数据类型</p></li><li><p>第一种定义方法：</p>  <figure class="highlight fortran hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> Config &#123;</span><br><span class="line">  &lt;T&gt;(<span class="hljs-keyword">value</span>: T): T;</span><br><span class="line">&#125;</span><br><span class="line">let getinfo: Config = <span class="hljs-function"><span class="hljs-keyword">function</span></span>&lt;T&gt;(<span class="hljs-keyword">value</span>: T): T &#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span>;</span><br><span class="line">&#125;;</span><br><span class="line">console.<span class="hljs-built_in">log</span>(getinfo&lt;<span class="hljs-keyword">number</span>&gt;(<span class="hljs-number">12</span>)); //<span class="hljs-number">12</span></span><br></pre></td></tr></table></figure></li><li><p>此时，在这里我们传入了<strong>number</strong>，那么<strong>T</strong>就是指的<strong>number</strong></p></li><li><p>定义方式二：</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> Config&lt;T&gt; &#123;</span><br><span class="line">  <span class="hljs-comment">//定义泛型接口</span></span><br><span class="line">  (value: T): T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">value: T</span>): <span class="hljs-title">T</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">let</span> getData: Config&lt;<span class="hljs-built_in">number</span>&gt; = getinfo; <span class="hljs-comment">//给接口定义类型且getData使用这个接口</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(getData(<span class="hljs-number">12</span>)); <span class="hljs-comment">//12</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="把类作为参数类型的泛型类"><a href="#把类作为参数类型的泛型类" class="headerlink" title="把类作为参数类型的泛型类"></a>把类作为参数类型的泛型类</h3><ul><li><p>把类作为参数来约束数据传入的类型</p></li><li><p>示例1：定义User类，对数据库进行映射</p>  <figure class="highlight cs hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> &#123;</span><br><span class="line">  username: <span class="hljs-keyword">string</span> | undefined;</span><br><span class="line">  password: <span class="hljs-keyword">string</span> | undefined;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title">Mydb</span> &#123;</span><br><span class="line">  <span class="hljs-keyword">add</span>(user: User): boolean &#123;</span><br><span class="line">    console.log(user);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> u = <span class="hljs-keyword">new</span> User();</span><br><span class="line">u.username = <span class="hljs-string">"张三"</span>;</span><br><span class="line">u.password = <span class="hljs-string">"123aaa"</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> db = <span class="hljs-keyword">new</span> Mydb();</span><br><span class="line">db.<span class="hljs-keyword">add</span>(u); User&#123;username:<span class="hljs-string">'张三'</span>,password:<span class="hljs-string">'123aaa'</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>示例2：</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> ArticleCate &#123;</span><br><span class="line">  title: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;</span><br><span class="line">  desc: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;</span><br><span class="line">  status?: <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> Mydb &#123;</span><br><span class="line">  add(info: ArticleCate): <span class="hljs-built_in">boolean</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(info);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> ArticleCate();</span><br><span class="line">a.title = <span class="hljs-string">"美味中国"</span>;</span><br><span class="line">a.desc = <span class="hljs-string">"江西美食"</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> db = <span class="hljs-keyword">new</span> Mydb();</span><br><span class="line">db.add(a); <span class="hljs-comment">//ArticleCate &#123; title: '美味中国', desc: '江西美食' &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>我们可以使用不同的类作为参数进行数据的约束</p></li><li><p>示例3：<font color="red"><strong>泛型类</strong></font></p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Mydb&lt;T&gt; &#123;</span><br><span class="line">  add(info: T): <span class="hljs-built_in">boolean</span> &#123;</span><br><span class="line">    <span class="hljs-comment">//经过数据的校验，就可以将info传入数据库了</span></span><br><span class="line">    <span class="hljs-built_in">console</span>.log(info);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  updata(info: T, id: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">boolean</span> &#123;</span><br><span class="line">    <span class="hljs-comment">//更新数据，info表示更新数据的内容，id表示更新数据的id</span></span><br><span class="line">    <span class="hljs-built_in">console</span>.log(info);</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(id);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">class</span> ArticleCate &#123;</span><br><span class="line">  title: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;</span><br><span class="line">  desc: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;</span><br><span class="line">  status?: <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">params: &#123;</span></span><br><span class="line"><span class="hljs-params">    <span class="hljs-comment">//可以使用构造函数进行传参</span></span></span><br><span class="line"><span class="hljs-params">    title: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;</span></span><br><span class="line"><span class="hljs-params">    desc: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;</span></span><br><span class="line"><span class="hljs-params">    status?: <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>;</span></span><br><span class="line"><span class="hljs-params">  &#125;</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.title = params.title;</span><br><span class="line">    <span class="hljs-keyword">this</span>.desc = params.desc;</span><br><span class="line">    <span class="hljs-keyword">this</span>.status = params.status;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> ArticleCate(&#123;</span><br><span class="line">  <span class="hljs-comment">//直接传入参数</span></span><br><span class="line">  title: <span class="hljs-string">"分类"</span>,</span><br><span class="line">  desc: <span class="hljs-string">"000"</span>,</span><br><span class="line">  status: <span class="hljs-number">200</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-keyword">var</span> db = <span class="hljs-keyword">new</span> Mydb&lt;ArticleCate&gt;();</span><br><span class="line">db.add(a); <span class="hljs-comment">//ArticleCate &#123; title: '分类', desc: '000', status: 200 &#125;</span></span><br><span class="line">db.updata(a, <span class="hljs-number">12</span>); <span class="hljs-comment">//ArticleCate &#123; title: '分类', desc: '000', status: 200 &#125;  12</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>以上就是Typescript中的泛型的一些使用方法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;泛型：软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性，组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="https://zhongyuehui.github.io/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://zhongyuehui.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6中的模块导入与导出</title>
    <link href="https://zhongyuehui.github.io/2019/07/09/ES6%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E4%B8%8E%E5%AF%BC%E5%87%BA/"/>
    <id>https://zhongyuehui.github.io/2019/07/09/ES6中的模块导入与导出/</id>
    <published>2019-07-09T10:43:40.000Z</published>
    <updated>2019-07-23T14:30:04.124Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 ES6 前， 实现模块化使用的是 RequireJS 或者 seaJS（分别是基于 AMD 规范的模块化库， 和基于 CMD 规范的模块化库）。ES6 引入了模块化，其设计思想是在编译时就能确定模块的依赖关系，以及输入和输出的变量。ES6 的模块化分为导出（export） @与导入（import）两个模块</p></blockquote><a id="more"></a><h2 id="导入与导出模块"><a href="#导入与导出模块" class="headerlink" title="导入与导出模块"></a>导入与导出模块</h2><ul><li>在 Nodejs 中，提供了<code>module.exports</code>和<code>exports</code>向暴露(导出)成员接口，使用<code>require(&#39;&#39;)</code>使用导入的对象</li></ul><h3 id="ES6-中的导入"><a href="#ES6-中的导入" class="headerlink" title="ES6 中的导入"></a>ES6 中的导入</h3><ul><li>在 ES6 中，也规定了<code>导入</code>和<code>导出</code>模块</li><li>ES6 中导入模块使用 <code>import 模块名称 from &#39;模块标识符&#39;</code>的方式导入 或 <code>import &#39;标识路径&#39;</code></li></ul><h3 id="ES6-中的导出"><a href="#ES6-中的导出" class="headerlink" title="ES6 中的导出"></a>ES6 中的导出</h3><ul><li>在 ES6 中，使用<strong>export default</strong> 和 <strong>export</strong>来暴露成员</li></ul><h3 id="两者导出的区别"><a href="#两者导出的区别" class="headerlink" title="两者导出的区别"></a>两者导出的区别</h3><ul><li>使用<strong>export default:</strong> 来暴露成员时，在全局中，只允许定义一个<strong>export default</strong></li><li>使用<strong>export</strong>来暴露成员时，可以定义多个<strong>export</strong></li></ul><h3 id="两者导入的区别"><a href="#两者导入的区别" class="headerlink" title="两者导入的区别"></a>两者导入的区别</h3><ul><li><p>在<code>import 模块名称 from &#39;模块标识符&#39;</code> 导入模块时，我们需要注意以下模块中是否同时使用了使用<strong>export default</strong> 和 <strong>export</strong>来暴露成员，如果只使用了<code>export default</code> 那么我们只需要自定义一个模块名称来接收数据即可</p><figure class="highlight arduino hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="hljs-keyword">export</span> <span class="hljs-built_in">default</span> &#123; <span class="hljs-comment">//导出</span></span><br><span class="line"> name: <span class="hljs-string">'张三'</span>,</span><br><span class="line"> age: <span class="hljs-number">16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight clean hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> test <span class="hljs-keyword">from</span> <span class="hljs-string">'test'</span> <span class="hljs-comment">//引入</span></span><br></pre></td></tr></table></figure></li><li><p>如果使用了<strong>export</strong>来暴露成员时，不管有没有使用<strong>export default</strong> 暴露成员，我们导出模块定义的成员名字和导入模块引入的名字<strong>必须</strong>一致，否则会出错</p></li><li><p>如果仅使用 export 暴露，我们只需要将成员名使用 <strong>{ }</strong> 包括起来即可，且不能省略<strong>{ }</strong></p><figure class="highlight arduino hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> a = <span class="hljs-string">'text中的export'</span> <span class="hljs-comment">//导出</span></span><br></pre></td></tr></table></figure><figure class="highlight clean hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> &#123; a &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./test'</span> <span class="hljs-comment">//引入 ，不能省略 &#123; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>如果我们同时使用了两种暴露方式或使用 export 定义了多个成员，只要按需导出即可</p><figure class="highlight arduino hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-built_in">default</span> &#123;</span><br><span class="line">name: <span class="hljs-string">'张三'</span>,</span><br><span class="line">age: <span class="hljs-number">16</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> test = <span class="hljs-string">'text中的export'</span></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> test2 = <span class="hljs-string">'text2中的export'</span></span><br></pre></td></tr></table></figure><figure class="highlight clean hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> test,&#123; test&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./text'</span> <span class="hljs-comment">//虽然定义了test2，但是我们可以根据需要不导出，导出在&#123;&#125;中加入即可</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="export-导出时修改名称"><a href="#export-导出时修改名称" class="headerlink" title="export 导出时修改名称"></a>export 导出时修改名称</h3><ul><li><p>我们发现使用<strong>export default</strong> 暴露时没有导入名称的规定，但是使用<strong>export</strong>暴露必须使用定义时的名字，其实我们可以使用 <strong>as</strong> 进行修改</p><figure class="highlight clean hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> test,&#123; test <span class="hljs-keyword">as</span> a,test2 <span class="hljs-keyword">as</span> b&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./text'</span></span><br></pre></td></tr></table></figure></li><li><p><font color="red"><strong>注意:</strong></font></p><ul><li>ES6 的模块自动开启严格模式，不管你有没有在模块头部加上 <code>use strict</code>。</li><li>模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等</li><li>每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域</li><li>每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 ES6 前， 实现模块化使用的是 RequireJS 或者 seaJS（分别是基于 AMD 规范的模块化库， 和基于 CMD 规范的模块化库）。ES6 引入了模块化，其设计思想是在编译时就能确定模块的依赖关系，以及输入和输出的变量。ES6 的模块化分为导出（export） @与导入（import）两个模块&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="ES6" scheme="https://zhongyuehui.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://zhongyuehui.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript中的接口</title>
    <link href="https://zhongyuehui.github.io/2019/07/08/TypeScript%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3/"/>
    <id>https://zhongyuehui.github.io/2019/07/08/TypeScript中的接口/</id>
    <published>2019-07-08T14:20:04.000Z</published>
    <updated>2019-07-09T11:24:05.404Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>接口的作用，在面向对象编程中接口是一种规范的定义，它定义了行为和动作规范，在程序设计里面，接口起到了一种限制和规范的作用。接口定义了某一批类所需要遵守的规则，接口不关心这些类的内部状态数据，也不关心这些类里的方法细节，它只规定这批类里必须提供某些方法，提供这些方法的的类就可以满足实际需要，typescript的接口类似于Java，同时还增加了许多更灵活的接口类型，它包括属性、函数，可索引和类定义标准</p></blockquote><a id="more"></a><h2 id="TypeScript中的接口"><a href="#TypeScript中的接口" class="headerlink" title="TypeScript中的接口"></a>TypeScript中的接口</h2><ul><li><p>对传入的参数进行约束</p>  <figure class="highlight actionscript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span><span class="hljs-params">(label:string)</span>: void </span>&#123;</span><br><span class="line">  console.log(<span class="hljs-string">"getinfo"</span>);</span><br><span class="line">&#125;</span><br><span class="line">getinfo(); <span class="hljs-comment">//报错，提示需要传递一个参数</span></span><br></pre></td></tr></table></figure></li><li><p>其实这个就是约束，就是规则</p></li><li><p>自定义方法传入参数对json进行约束</p>  <figure class="highlight lua hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span><span class="hljs-params">(label: &#123; name: string &#125;)</span></span>: void &#123;</span><br><span class="line">  console.<span class="hljs-built_in">log</span>(<span class="hljs-string">"getinfo"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">getinfo</span>(&#123; name: <span class="hljs-string">"zs"</span> &#125;); //传入一个对象，且对象中第一个参数是name，还要<span class="hljs-built_in">string</span>类型的数据</span><br></pre></td></tr></table></figure></li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li><p>行为和动作的规范，对批量方法进行约束</p><h4 id="属性接口："><a href="#属性接口：" class="headerlink" title="属性接口："></a>属性接口：</h4></li><li>  <figure class="highlight less hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">interface</span> <span class="hljs-selector-tag">FullName</span> &#123;</span><br><span class="line">  <span class="hljs-attribute">firstName</span>: string;</span><br><span class="line">  <span class="hljs-attribute">secondName</span>: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">printName</span>(<span class="hljs-attribute">name</span>: FullName) &#123;</span><br><span class="line">  <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(name.firstName + <span class="hljs-string">"---"</span> + name.secondName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-selector-tag">printName</span>(&#123; <span class="hljs-comment">//使用这种方式传递只能传递interface定义好的属性</span></span><br><span class="line">  <span class="hljs-attribute">firstName</span>: <span class="hljs-string">"Mr"</span>,</span><br><span class="line">  <span class="hljs-attribute">secondName</span>: <span class="hljs-string">"Zhong"</span></span><br><span class="line">&#125;); <span class="hljs-comment">//输出Mr Zhong</span></span><br></pre></td></tr></table></figure></li><li>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> FullName &#123;</span><br><span class="line">  firstName: <span class="hljs-built_in">string</span>;</span><br><span class="line">  secondName: <span class="hljs-built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printName</span>(<span class="hljs-params">name: FullName</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(name.firstName + <span class="hljs-string">"---"</span> + name.secondName + <span class="hljs-string">"--"</span> + name.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">let</span> obj = &#123;</span><br><span class="line">  age: <span class="hljs-string">"12"</span>,</span><br><span class="line">  firstName: <span class="hljs-string">"Mr"</span>,</span><br><span class="line">  secondName: <span class="hljs-string">"Zhong"</span></span><br><span class="line">&#125;; <span class="hljs-comment">//使用外界定义对象传入的方式可以定义不同的属性但是必须有interface定义的属性</span></span><br><span class="line">printName(obj); <span class="hljs-comment">//输出Mr Zhong</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="接口的可选属性"><a href="#接口的可选属性" class="headerlink" title="接口的可选属性"></a>接口的可选属性</h4><ul><li>可选属性：  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> FullName &#123;</span><br><span class="line">  firstName: <span class="hljs-built_in">string</span>;</span><br><span class="line">  secondName?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//定义可选属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printName</span>(<span class="hljs-params">name: FullName</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(name.firstName + <span class="hljs-string">"---"</span> + name.secondName);</span><br><span class="line">&#125;</span><br><span class="line">printName(&#123;</span><br><span class="line">  <span class="hljs-comment">//可选属性可写可不写</span></span><br><span class="line">  firstName: <span class="hljs-string">"firstname"</span></span><br><span class="line">&#125;); <span class="hljs-comment">//输出Mr--undefined</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="属性类型封装的ajax"><a href="#属性类型封装的ajax" class="headerlink" title="属性类型封装的ajax"></a>属性类型封装的ajax</h4><ul><li>封装的ajax  <figure class="highlight lua hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">interface Config &#123;</span><br><span class="line">  url: <span class="hljs-built_in">string</span>;</span><br><span class="line">  dataType: <span class="hljs-built_in">string</span>;</span><br><span class="line">  data?: <span class="hljs-built_in">string</span>;</span><br><span class="line">  <span class="hljs-built_in">type</span>: <span class="hljs-built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ajax</span><span class="hljs-params">(config: Config)</span></span> &#123;</span><br><span class="line">  var xhr = new XMLHttpRequest();</span><br><span class="line">  xhr.<span class="hljs-built_in">open</span>(<span class="hljs-built_in">config</span>.<span class="hljs-built_in">type</span>, <span class="hljs-built_in">config</span>.url, <span class="hljs-literal">true</span>);</span><br><span class="line">  xhr.send(<span class="hljs-built_in">config</span>.data);</span><br><span class="line">  xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (xhr.<span class="hljs-built_in">status</span> === <span class="hljs-number">200</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">config</span>.dataType == <span class="hljs-string">"json"</span>) &#123;</span><br><span class="line">          console.<span class="hljs-built_in">log</span>(JSON.parse(xhr.responseText));</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">          console.<span class="hljs-built_in">log</span>(xhr.responseXML);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">ajax(&#123;</span><br><span class="line">  url: <span class="hljs-string">"http://a.itying.com/api/productlist"</span>, //这个是api接口</span><br><span class="line">  dataType: <span class="hljs-string">"json"</span>,</span><br><span class="line">  <span class="hljs-built_in">type</span>: <span class="hljs-string">"get"</span>,</span><br><span class="line">  data: <span class="hljs-string">"name=zhangsan"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="函数类型的接口"><a href="#函数类型的接口" class="headerlink" title="函数类型的接口"></a>函数类型的接口</h3><ul><li>加密的函数类型接口  <figure class="highlight q hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface encrypt &#123;</span><br><span class="line">  <span class="hljs-comment">//加密的函数类型接口</span></span><br><span class="line">  (<span class="hljs-built_in">key</span>: <span class="hljs-built_in">string</span>, <span class="hljs-built_in">value</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">var</span> <span class="hljs-built_in">md5</span>: encrypt = function(<span class="hljs-built_in">key</span>: <span class="hljs-built_in">string</span>, <span class="hljs-built_in">value</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> &#123;</span><br><span class="line">  return <span class="hljs-built_in">key</span> + <span class="hljs-built_in">value</span>; <span class="hljs-comment">//真实的加密这里是经过一系列的算法进行加密，这里是模拟操作</span></span><br><span class="line">&#125;;</span><br><span class="line">console.log(<span class="hljs-built_in">md5</span>(<span class="hljs-string">"zhangsan"</span>, <span class="hljs-string">"14"</span>)); <span class="hljs-comment">//zhangsan14</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">var</span> info: encrypt = function(<span class="hljs-built_in">key</span>: <span class="hljs-built_in">string</span>, <span class="hljs-built_in">value</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> &#123;</span><br><span class="line">  <span class="hljs-comment">//这里继续使用加密接口</span></span><br><span class="line">  return <span class="hljs-built_in">key</span> + <span class="hljs-string">"---"</span> + <span class="hljs-built_in">value</span>;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(info(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>)); <span class="hljs-comment">//hello--world</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="可索引的接口"><a href="#可索引的接口" class="headerlink" title="可索引的接口"></a>可索引的接口</h3><ul><li><p>对数组、对象的约束(不常用)</p></li><li><p>对数组:</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> UserArr &#123;</span><br><span class="line">  [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//下标是number，值是string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> arr: UserArr = [<span class="hljs-string">"aaa"</span>, <span class="hljs-string">"bbb"</span>];</span><br><span class="line"><span class="hljs-built_in">console</span>.log(arr[<span class="hljs-number">0</span>]); <span class="hljs-comment">//aaa</span></span><br></pre></td></tr></table></figure></li><li><p>对对象：</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> UserArr &#123;</span><br><span class="line">  [index: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> arr: UserArr = &#123; name: <span class="hljs-string">"张三"</span> &#125;;<span class="hljs-comment">//name属性双引号可写可不写</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(arr[<span class="hljs-string">"name"</span>]); <span class="hljs-comment">//张三</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="类类型接口"><a href="#类类型接口" class="headerlink" title="类类型接口"></a>类类型接口</h3><ul><li><p>类类型接口</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> Animal &#123;</span><br><span class="line">  name: <span class="hljs-built_in">string</span>;</span><br><span class="line">  eat(str: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">class</span> Dog <span class="hljs-keyword">implements</span> Animal &#123;</span><br><span class="line">  name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//必须定义</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="hljs-comment">//必须定义</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;this.name&#125;</span>爱吃粮食`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">"小黑"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(d.eat()); <span class="hljs-comment">//小黑爱吃粮食</span></span><br></pre></td></tr></table></figure></li><li>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> Animal &#123;</span><br><span class="line">  name: <span class="hljs-built_in">string</span>;</span><br><span class="line">  eat(str: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">class</span> Dog <span class="hljs-keyword">implements</span> Animal &#123;</span><br><span class="line">  name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//必须定义</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="hljs-comment">//必须定义</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;this.name&#125;</span>爱吃粮食`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">"小黑"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(d.eat()); <span class="hljs-comment">//小黑爱吃粮食</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> Cat <span class="hljs-keyword">implements</span> Animal &#123;</span><br><span class="line">  name: <span class="hljs-built_in">string</span>;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  eat(food: <span class="hljs-built_in">string</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;this.name&#125;</span>爱吃<span class="hljs-subst">$&#123;food&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">"小花猫"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(c.eat(<span class="hljs-string">"小老鼠"</span>)); <span class="hljs-comment">//小花猫爱吃小老鼠</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="接口的扩展"><a href="#接口的扩展" class="headerlink" title="接口的扩展"></a>接口的扩展</h3><ul><li><p>继承接口：</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> Animal &#123;</span><br><span class="line">  eat(): <span class="hljs-built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">interface</span> Person <span class="hljs-keyword">extends</span> Animal &#123;</span><br><span class="line">  work(): <span class="hljs-built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">class</span> Web <span class="hljs-keyword">implements</span> Person &#123;</span><br><span class="line">  name: <span class="hljs-built_in">string</span>;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;this.name&#125;</span>喜欢吃馒头`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  work() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;this.name&#125;</span>是程序员`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> Web(<span class="hljs-string">"张三"</span>);</span><br><span class="line">m.eat(); <span class="hljs-comment">//张三喜欢吃馒头</span></span><br><span class="line">m.work(); <span class="hljs-comment">//张三是程序员</span></span><br></pre></td></tr></table></figure></li><li><p>继承类和继承接口</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> &#123; closeSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"fs"</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">interface</span> Animal &#123;</span><br><span class="line">  eat(): <span class="hljs-built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">interface</span> Person <span class="hljs-keyword">extends</span> Animal &#123;</span><br><span class="line">  work(): <span class="hljs-built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">class</span> Programmer &#123;</span><br><span class="line">  <span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span>;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  coding(code: <span class="hljs-built_in">string</span>) &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name + code);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">class</span> Web <span class="hljs-keyword">extends</span> Programmer <span class="hljs-keyword">implements</span> Person &#123;</span><br><span class="line">  <span class="hljs-comment">//即继承programmer类 又使用继承的Person接口</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;this.name&#125;</span>喜欢吃馒头`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  work() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;this.name&#125;</span>是程序员`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> Web(<span class="hljs-string">"张三"</span>);</span><br><span class="line">m.eat(); <span class="hljs-comment">//张三喜欢吃馒头</span></span><br><span class="line">m.work(); <span class="hljs-comment">//张三是程序员</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>这些就是在Typescript中的接口的一些使用和说明。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;接口的作用，在面向对象编程中接口是一种规范的定义，它定义了行为和动作规范，在程序设计里面，接口起到了一种限制和规范的作用。接口定义了某一批类所需要遵守的规则，接口不关心这些类的内部状态数据，也不关心这些类里的方法细节，它只规定这批类里必须提供某些方法，提供这些方法的的类就可以满足实际需要，typescript的接口类似于Java，同时还增加了许多更灵活的接口类型，它包括属性、函数，可索引和类定义标准&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="https://zhongyuehui.github.io/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://zhongyuehui.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript中的类</title>
    <link href="https://zhongyuehui.github.io/2019/07/08/TypeScript%E4%B8%AD%E7%9A%84%E7%B1%BB/"/>
    <id>https://zhongyuehui.github.io/2019/07/08/TypeScript中的类/</id>
    <published>2019-07-08T08:19:25.000Z</published>
    <updated>2019-07-09T11:23:57.298Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 typescript 中，类的定义与 ES6的语法 稍有些差别，但是与 java,C++等更加相像了</p></blockquote><a id="more"></a><h2 id="Typescript-中的类"><a href="#Typescript-中的类" class="headerlink" title="Typescript 中的类"></a>Typescript 中的类</h2><ul><li><p>在 Typescript 中使用<font color="red"><strong>class</strong></font>关键字定义类</p><h3 id="使用-class-定义类："><a href="#使用-class-定义类：" class="headerlink" title="使用 class 定义类："></a>使用 class 定义类：</h3>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> Person &#123;</span><br><span class="line">name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//属性</span></span><br><span class="line">age: <span class="hljs-built_in">number</span>;</span><br><span class="line"><span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;</span><br><span class="line"><span class="hljs-comment">//构造函数 实例化的时候触发的方法,相当于对实例化时传递的参数进行赋值</span></span><br><span class="line"><span class="hljs-keyword">this</span>.name = name;</span><br><span class="line"><span class="hljs-keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">run() &#123;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">"---"</span> + <span class="hljs-keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"张三"</span>, <span class="hljs-number">12</span>);</span><br><span class="line">p.run(); <span class="hljs-comment">//张三</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="修改属性值"><a href="#修改属性值" class="headerlink" title="修改属性值"></a>修改属性值</h3><ul><li>修改类中的属性值</li></ul><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    <span class="hljs-keyword">class</span> Person &#123;</span><br><span class="line">    name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//属性</span></span><br><span class="line">    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    getName(): <span class="hljs-built_in">void</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    setName(name: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"张三"</span>);</span><br><span class="line">    p.getName(); <span class="hljs-comment">//张三</span></span><br><span class="line">    p.setName(<span class="hljs-string">"李四"</span>); <span class="hljs-comment">//修改 name 的值</span></span><br><span class="line">    p.getName(); <span class="hljs-comment">//李四</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-string">``</span><span class="hljs-string">`</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">### 继承</span></span><br><span class="line"><span class="hljs-string">- 继承父类</span></span><br><span class="line"><span class="hljs-string"> `</span><span class="hljs-string">``</span></span><br><span class="line">  <span class="hljs-keyword">class</span> Person &#123;</span><br><span class="line">    name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//属性</span></span><br><span class="line">    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    run() &#123;</span><br><span class="line">      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"张三"</span>);</span><br><span class="line">  <span class="hljs-keyword">class</span> Web <span class="hljs-keyword">extends</span> Person &#123;&#125; <span class="hljs-comment">//如果直接继承，那么就是相当于复制了Person，继承了他的构造函数</span></span><br><span class="line">  <span class="hljs-keyword">var</span> w = <span class="hljs-keyword">new</span> Web(<span class="hljs-string">"李四"</span>);</span><br><span class="line">  w.run(); <span class="hljs-comment">//李四</span></span><br></pre></td></tr></table></figure><ul><li><p>方法的继承</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//属性</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  run(): <span class="hljs-built_in">void</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"张三"</span>);</span><br><span class="line"><span class="hljs-keyword">class</span> Web <span class="hljs-keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>(name); <span class="hljs-comment">//这里表示继承父类的构造器，初始化自己的构造函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  run(): <span class="hljs-built_in">void</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`我是：<span class="hljs-subst">$&#123;this.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> w = <span class="hljs-keyword">new</span> Web(<span class="hljs-string">"李四"</span>);</span><br><span class="line">w.run(); <span class="hljs-comment">//我是李四，当子类和父类都有同一个方法时，子类会调用自己的</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="类的修饰符"><a href="#类的修饰符" class="headerlink" title="类的修饰符"></a>类的修饰符</h3><ul><li>typescript 中定义属性给我们提供了三种修饰符<ul><li><font color="red"><strong>public</strong></font>:表示公有 在类里面、子类、类外面都可以进行访问</li><li><font color="red"><strong>protected</strong></font>：保护类型 在类里面、子类里面可以访问，在类外部没法访问</li><li><font color="red"><strong>private</strong></font>：私有 在类里面可以进行访问，子类、类外部都不能进行访问</li></ul></li><li><font color="red"><strong>注意：</strong></font>属性如果不加修饰符，默认就是公有的(<strong>public</strong>)</li></ul><h4 id="公有属性-public"><a href="#公有属性-public" class="headerlink" title="公有属性(public)"></a>公有属性(public)</h4><ul><li><p>在类外部访问</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Person &#123;</span><br><span class="line">  <span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//公有属性</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"张三"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(p.name); <span class="hljs-comment">//张三</span></span><br></pre></td></tr></table></figure></li><li><p>在类内部和子类内部访问</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Person &#123;</span><br><span class="line">  <span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//公有属性</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  run(): <span class="hljs-built_in">string</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"张三"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(p.run()); <span class="hljs-comment">//张三</span></span><br><span class="line"><span class="hljs-keyword">class</span> Web <span class="hljs-keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  work(): <span class="hljs-built_in">string</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;this.name&#125;</span>在工作`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> w = <span class="hljs-keyword">new</span> Web(<span class="hljs-string">"李四"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(w.work()); <span class="hljs-comment">//李四在工作</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="保护属性-protected"><a href="#保护属性-protected" class="headerlink" title="保护属性(protected)"></a>保护属性(protected)</h4><ul><li><p>在类内部和子类内部访问</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Person &#123;</span><br><span class="line">  <span class="hljs-keyword">protected</span> name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//保护类型</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  run(): <span class="hljs-built_in">string</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;this.name&#125;</span>在上班`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"张三"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(p.run()); <span class="hljs-comment">//张三在上班</span></span><br><span class="line"><span class="hljs-keyword">class</span> Web <span class="hljs-keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  work() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;this.name&#125;</span>在工作`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> w = <span class="hljs-keyword">new</span> Web(<span class="hljs-string">"李四"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(w.work()); <span class="hljs-comment">//李四在工作</span></span><br></pre></td></tr></table></figure></li><li><p>在类外部访问和子类外部访问</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Person &#123;</span><br><span class="line">  <span class="hljs-keyword">protected</span> name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//保护类型</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  run(): <span class="hljs-built_in">string</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;this.name&#125;</span>在上班`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"张三"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(p.name); <span class="hljs-comment">//报错，name受保护</span></span><br><span class="line"><span class="hljs-keyword">class</span> Web <span class="hljs-keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  work() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;this.name&#125;</span>在工作`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> w = <span class="hljs-keyword">new</span> Web(<span class="hljs-string">"李四"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(w.name); <span class="hljs-comment">//报错，name受保护</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="私有类型-private"><a href="#私有类型-private" class="headerlink" title="私有类型(private)"></a>私有类型(private)</h3><ul><li><p>在类外部访问</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Person &#123;</span><br><span class="line">  <span class="hljs-keyword">private</span> name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//公有属性</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  run(): <span class="hljs-built_in">string</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"张三"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(p.name); <span class="hljs-comment">//报错，私有属性只能在内部中访问</span></span><br></pre></td></tr></table></figure></li><li><p>在子类内部和外部访问</p><figure class="highlight scala hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">private</span> name: string; <span class="hljs-comment">//公有属性</span></span><br><span class="line">  constructor(name: string) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  run(): string &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(<span class="hljs-string">"张三"</span>);</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Web</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;</span><br><span class="line">  constructor(name: string) &#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  work(): string &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> `$&#123;<span class="hljs-keyword">this</span>.name&#125;在工作`; <span class="hljs-comment">//在这里就报错了，只能在Person内部中访问，所以外部没有试验的必要了</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> w = <span class="hljs-keyword">new</span> <span class="hljs-type">Web</span>(<span class="hljs-string">"李四"</span>);</span><br></pre></td></tr></table></figure></li><li><p>在类内部访问</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Person &#123;</span><br><span class="line">  <span class="hljs-keyword">private</span> name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//公有属性</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  run(): <span class="hljs-built_in">string</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"张三"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(p.run()); <span class="hljs-comment">//张三</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a><font color="red" size="+2">总结:</font></h4><ul><li>在类的定义中： + 公有的类里面，在当前类里面、子类、类外面都可以访问 + 在保护类里面，在当前类、子类里面都可以访问，在类外面不能访问 + 在私有类里面，在当前类里面可以访问，在子类，类外面都不能进行访问<blockquote><p>一上就是在 TypeScript 中的类的相关知识。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 typescript 中，类的定义与 ES6的语法 稍有些差别，但是与 java,C++等更加相像了&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="https://zhongyuehui.github.io/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://zhongyuehui.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript中的函数</title>
    <link href="https://zhongyuehui.github.io/2019/07/08/TypeScript%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"/>
    <id>https://zhongyuehui.github.io/2019/07/08/TypeScript中的函数/</id>
    <published>2019-07-08T02:40:48.000Z</published>
    <updated>2019-07-09T11:16:01.461Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>函数在 Javascript 中是一等一的公民</p></blockquote><a id="more"></a><h1 id="Typescript-中的函数"><a href="#Typescript-中的函数" class="headerlink" title="Typescript 中的函数"></a>Typescript 中的函数</h1><h2 id="TypeScript-中定义函数"><a href="#TypeScript-中定义函数" class="headerlink" title="TypeScript 中定义函数"></a>TypeScript 中定义函数</h2><h3 id="ES5-中定义函数的方式"><a href="#ES5-中定义函数的方式" class="headerlink" title="ES5 中定义函数的方式"></a>ES5 中定义函数的方式</h3><ul><li><figure class="highlight dust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-xml"><span class="hljs-comment">&lt;!--函数声明--&gt;</span></span></span><br><span class="line"><span class="hljs-xml">function getinfo() </span><span class="hljs-template-variable">&#123;</span></span><br><span class="line"><span class="hljs-template-variable">return 'hello-world'</span></span><br><span class="line"><span class="hljs-template-variable">&#125;</span><span class="hljs-xml"></span></span><br></pre></td></tr></table></figure><figure class="highlight dust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-xml"><span class="hljs-comment">&lt;!--匿名函数--&gt;</span></span></span><br><span class="line"><span class="hljs-xml">var getinfo = function () </span><span class="hljs-template-variable">&#123;</span></span><br><span class="line"><span class="hljs-template-variable">return 'hello-world'</span></span><br><span class="line"><span class="hljs-template-variable">&#125;</span><span class="hljs-xml"></span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="ts-中的定义函数的方式"><a href="#ts-中的定义函数的方式" class="headerlink" title="ts 中的定义函数的方式"></a>ts 中的定义函数的方式</h3><ul><li><p>使用函数声明的方式，只定义函数的返回值类型</p><figure class="highlight lua hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span><span class="hljs-params">()</span></span>:<span class="hljs-built_in">string</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">'This is getinfo'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">getinfo</span>()</span><br></pre></td></tr></table></figure></li><li><p>注意：这样定义函数时，返回值的数据类型必须是 string,否则会报错</p></li><li><p>函数表达式的方式定义函数(匿名函数)</p><figure class="highlight lua hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var <span class="hljs-built_in">getinfo</span>=<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>:<span class="hljs-built_in">string</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">'This is getinfo'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">getinfo</span>()</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="ts-中传递参数"><a href="#ts-中传递参数" class="headerlink" title="ts 中传递参数"></a>ts 中传递参数</h3><ul><li><p>使用函数声明定义函数，需要定义参数的类型和函数的返回值类型，且形参和实参类型与数据一一对应</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">name:<span class="hljs-built_in">string</span>,age:<span class="hljs-built_in">number</span></span>):<span class="hljs-title">string</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>----<span class="hljs-subst">$&#123;age&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">let</span> value = getinfo(<span class="hljs-string">'张三'</span>,<span class="hljs-number">12</span>)</span><br><span class="line"><span class="hljs-built_in">console</span>.log(value);</span><br></pre></td></tr></table></figure></li><li><p>使用函数表达式(匿名函数)定义函数，传递参数，规则与使用函声明定义函数一样</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> getinfo= <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name:<span class="hljs-built_in">string</span>,age:<span class="hljs-built_in">number</span></span>):<span class="hljs-title">string</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>----<span class="hljs-subst">$&#123;age&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">let</span> value = getinfo(<span class="hljs-string">'张三'</span>,<span class="hljs-number">40</span>)</span><br><span class="line"><span class="hljs-built_in">console</span>.log(value);</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="定义没有返回值的方法"><a href="#定义没有返回值的方法" class="headerlink" title="定义没有返回值的方法"></a>定义没有返回值的方法</h3><ul><li><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">name:<span class="hljs-built_in">string</span>,age:<span class="hljs-built_in">number</span></span>):<span class="hljs-title">void</span> </span>&#123;</span><br><span class="line">   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>----<span class="hljs-subst">$&#123;age&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">getinfo(<span class="hljs-string">'张三'</span>,<span class="hljs-number">30</span>)</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="定义可选参数"><a href="#定义可选参数" class="headerlink" title="定义可选参数"></a>定义可选参数</h3><ul><li><p>在 ES5 中，我们如果定义普通的形参时，形参个数和实参个数可以不一致，但是在 ts 中，不允许这样做</p><figure class="highlight delphi hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span><span class="hljs-params">(<span class="hljs-keyword">name</span>:<span class="hljs-keyword">string</span>,age:number)</span>:</span>void <span class="hljs-comment">&#123;</span></span><br><span class="line"><span class="hljs-comment">console.log(`$&#123;name&#125;</span>----年龄保密);</span><br><span class="line">&#125;  <span class="hljs-comment">//这里提示报错了，没有将模板字符串写完</span></span><br><span class="line">getinfo(<span class="hljs-string">'张三'</span>)</span><br></pre></td></tr></table></figure></li><li><p>所以我们可以看到，如果写了形参，没有传递实参，就会编译错误,但是有时候我们并不传递，但是可以先定义预留位置</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">name:<span class="hljs-built_in">string</span>,age?:<span class="hljs-built_in">number</span></span>):<span class="hljs-title">void</span> </span>&#123;</span><br><span class="line">   age? <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>----<span class="hljs-subst">$&#123;age&#125;</span>`</span>): <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>---年龄保密`</span>)</span><br><span class="line">&#125;</span><br><span class="line">getinfo(<span class="hljs-string">'张三'</span>,<span class="hljs-number">12</span>)</span><br></pre></td></tr></table></figure></li><li><p>在形参名后面加上 <code>?</code> 表示对实参进行判断，如果有就使用，没有就不使用</p></li></ul><h3 id="定义默认参数"><a href="#定义默认参数" class="headerlink" title="定义默认参数"></a>定义默认参数</h3><ul><li><p>定义默认参数我们也可以不传递定义了默认值的参数</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">name:<span class="hljs-built_in">string</span>,age:<span class="hljs-built_in">number</span>=12</span>):<span class="hljs-title">void</span> </span>&#123;</span><br><span class="line">age? <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>----<span class="hljs-subst">$&#123;age&#125;</span>`</span>): <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>---年龄保密`</span>)</span><br><span class="line">&#125;</span><br><span class="line">getinfo(<span class="hljs-string">'张三'</span>)  <span class="hljs-comment">//输出 张三 12</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">name:<span class="hljs-built_in">string</span>,age:<span class="hljs-built_in">number</span>=12</span>):<span class="hljs-title">void</span> </span>&#123;</span><br><span class="line">age? <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>----<span class="hljs-subst">$&#123;age&#125;</span>`</span>): <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>---年龄保密`</span>)</span><br><span class="line">&#125;</span><br><span class="line">getinfo(<span class="hljs-string">'张三'</span>,<span class="hljs-number">45</span>) <span class="hljs-comment">//输出 张三 45</span></span><br></pre></td></tr></table></figure></li><li><p>总结：</p><ul><li>如果我们在形参中定义了默认的值的时候，你调用函数时可以不传递这个设有默认值的参数，他会使用默认值输出</li><li>如果我们在形参中定义了默认的值的时候，你调用函数时传递这个设有默认值的参数，他会使用你传递的值作为输出</li></ul></li></ul><hr><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><ul><li><p>当我们想要计算多个参数的值时，如下定义每一个参数会显得非常麻烦，所以我们需要换一种方式来解决这个累赘的定义</p><figure class="highlight fortran hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span></span> <span class="hljs-built_in">sum</span>(a:<span class="hljs-keyword">number</span>,b:<span class="hljs-keyword">number</span>,c:<span class="hljs-keyword">number</span>,d:<span class="hljs-keyword">number</span>):<span class="hljs-keyword">number</span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> a+b+c+d</span><br><span class="line">&#125;</span><br><span class="line">var sun  = <span class="hljs-built_in">sum</span>(<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">12</span>,<span class="hljs-number">14</span>)</span><br><span class="line">console.<span class="hljs-built_in">log</span>(sun);</span><br></pre></td></tr></table></figure></li><li><p>使用 ES6 中的三点运算符</p><figure class="highlight actionscript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span><span class="hljs-params">(a:number,b:number,<span class="hljs-rest_arg">...result</span>:number[])</span>:number</span>&#123;</span><br><span class="line"><span class="hljs-keyword">var</span> sum =a+b</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; result.length; i++) &#123;</span><br><span class="line">        sum+=result[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> add = sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span><br><span class="line">console.log(add);</span><br></pre></td></tr></table></figure></li><li><p>这样就不会有太多的重复代码</p></li></ul><hr><h3 id="ts-函数重载"><a href="#ts-函数重载" class="headerlink" title="ts 函数重载"></a>ts 函数重载</h3><ul><li><p>拓展：</p><ul><li>java 中方法的重载：重载指的是两个或者两个以上同名函数，但是它们的参数不一样，这时候会出现重载的情况</li><li>typescript 中的重载：通过为同一个函数提供多个函数类型定义来实现多种功能的目的</li><li>ts 中为了兼容 ES5 以及 ES6，重载的写法与 Java 有所区别</li></ul><figure class="highlight dust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-xml"><span class="hljs-comment">&lt;!--在ES5中，如果出现了同名的方法，下面的会替换掉上面的--&gt;</span></span></span><br><span class="line"><span class="hljs-xml">function a() </span><span class="hljs-template-variable">&#123;</span></span><br><span class="line"><span class="hljs-template-variable">console.log('a')</span></span><br><span class="line"><span class="hljs-template-variable">&#125;</span><span class="hljs-xml"></span></span><br><span class="line"><span class="hljs-xml"></span></span><br><span class="line"><span class="hljs-xml">function a() </span><span class="hljs-template-variable">&#123;</span></span><br><span class="line"><span class="hljs-template-variable">    console.log('b')</span></span><br><span class="line"><span class="hljs-template-variable">&#125;</span><span class="hljs-xml"></span></span><br><span class="line"><span class="hljs-xml">a()  //输出 b</span></span><br></pre></td></tr></table></figure></li><li><p>示例 1：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">age:number</span>):<span class="hljs-title">number</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-title">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">name:string</span>):<span class="hljs-title">string</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-title">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">str:any</span>):<span class="hljs-title">any</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> str ===<span class="hljs-string">'string'</span>)&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">`我是:<span class="hljs-subst">$&#123;str&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">`我今年 <span class="hljs-subst">$&#123;str&#125;</span>岁`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(getinfo(<span class="hljs-string">'张三'</span>)) <span class="hljs-comment">//我是张三</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">age:number</span>):<span class="hljs-title">number</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-title">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">name:string</span>):<span class="hljs-title">string</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-title">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">str:any</span>):<span class="hljs-title">any</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> str ===<span class="hljs-string">'string'</span>)&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">`我是:<span class="hljs-subst">$&#123;str&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">`我今年 <span class="hljs-subst">$&#123;str&#125;</span>岁`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(getinfo(<span class="hljs-number">18</span>)) <span class="hljs-comment">//我今年18岁</span></span><br></pre></td></tr></table></figure></li><li><p>示例 1 中，前面两个函数才是作为运行的方法，最后这个函数是判断调用哪个函数，判断的依据就是你传入的参数的数据类型和哪个方法中的形参的数据类型一致，那么他就调用哪个，如果传入的实参数据类型没有定义则报错</p></li><li><p>示例 2:</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">string</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age?: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">any</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (age) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">`我叫<span class="hljs-subst">$&#123;name&#125;</span>，我今年：<span class="hljs-subst">$&#123;age&#125;</span>岁`</span>;</span><br><span class="line">  &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">`我叫:<span class="hljs-subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(getinfo(<span class="hljs-string">"张三"</span>)) <span class="hljs-comment">//张三</span></span><br><span class="line"><span class="hljs-comment">// getinfo(12) //报错，因为name是string ，只能在第二个参数传入number型数据</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(getinfo(<span class="hljs-string">"张三"</span>, <span class="hljs-number">12</span>)); <span class="hljs-comment">//我叫张三，我今年12岁</span></span><br></pre></td></tr></table></figure></li><li><p>示例 2 中，我们定义了一个可选参数，当我们只有一个参数时他就调用第一个方法，如果有两个参数时，调用第二个方法</p></li></ul><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ul><li>在 ES6 中，箭头函数的 this 指向的是上下文,但是在 ts 编译中采用的是严格模式，严格模式中禁止函数中的 this 指向 window<br><code>setTimeout(() =&gt; { console.log(&quot;run&quot;); }, 3000)</code><blockquote><p>以上就是我在学习中总结的一些关于函数的相关知识。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;函数在 Javascript 中是一等一的公民&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="https://zhongyuehui.github.io/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://zhongyuehui.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript中的数据类型</title>
    <link href="https://zhongyuehui.github.io/2019/07/07/TypeScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://zhongyuehui.github.io/2019/07/07/TypeScript中的数据类型/</id>
    <published>2019-07-07T14:03:04.000Z</published>
    <updated>2019-07-09T11:17:02.468Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。这里主要介绍前五种原始数据类型和一些其他的TypeScript的数据类型</p></blockquote><a id="more"></a><h1 id="Typescript中的数据类型"><a href="#Typescript中的数据类型" class="headerlink" title="Typescript中的数据类型"></a>Typescript中的数据类型</h1><h2 id="布尔类型-boolean"><a href="#布尔类型-boolean" class="headerlink" title="布尔类型(boolean)"></a>布尔类型(boolean)</h2><pre><code><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">&lt;!--在ES5中--&gt;</span></span><br><span class="line">var flag= true</span><br><span class="line">    flag=123</span><br><span class="line">    console.log(flag) //123</span><br></pre></td></tr></table></figure><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">&lt;!--在Typescript中--&gt;</span></span><br><span class="line">var flag= true</span><br><span class="line">    flag=123    //在这里时，编译器已经报错了</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">&lt;!--正确的写法--&gt;</span></span><br><span class="line">var flag:boolean= true</span><br><span class="line">    flag=false</span><br><span class="line">    console.log(flag) //false</span><br></pre></td></tr></table></figure></code></pre><hr><h2 id="数字类型-number"><a href="#数字类型-number" class="headerlink" title="数字类型(number)"></a>数字类型(number)</h2><ul><li>  <figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">&lt;!--在ES5中--&gt;</span></span><br><span class="line">var num=123</span><br><span class="line">    num='aa'</span><br><span class="line">    console.log(num) //aa</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">&lt;!--在typesctipt--&gt;</span></span><br><span class="line">var num:number=123</span><br><span class="line">    num='str'// 编译器报错</span><br><span class="line">    </span><br><span class="line"><span class="hljs-comment">&lt;!--正确的写法--&gt;</span></span><br><span class="line">var num:number = 123</span><br><span class="line">    num=456</span><br><span class="line">    console/log(num) //num</span><br></pre></td></tr></table></figure></li><li><p>根据前两个我们已经可以看的出来.只要规定了该变量是什么类型或者是第一个赋值该变量的数据是什么类型的,这个变量就是什么类型的数据,并且赋值只能赋值相同的类型数据,否则直接报错</p><h2 id="字符串类型-string"><a href="#字符串类型-string" class="headerlink" title="字符串类型(string)"></a>字符串类型(string)</h2></li><li>  <figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">&lt;!--在typescript中--&gt;</span></span><br><span class="line">let str:string = 'string'</span><br><span class="line">    str = 'hello'</span><br><span class="line">    console.log(str) //hello</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="数组类型-array"><a href="#数组类型-array" class="headerlink" title="数组类型(array)"></a>数组类型(array)</h2><h3 id="定义方式一"><a href="#定义方式一" class="headerlink" title="定义方式一:"></a>定义方式一:</h3><ul><li>在变量名后面跟上数组的类型  <figure class="highlight makefile hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let arr:number[]= [12,11]</span><br><span class="line"></span><br><span class="line">arr=[<span class="hljs-string">"123"</span>,123] //这样就报错了</span><br><span class="line">arr=[123,456] //这样是正确的</span><br></pre></td></tr></table></figure></li></ul><h3 id="定义方式二"><a href="#定义方式二" class="headerlink" title="定义方式二:"></a>定义方式二:</h3><ul><li>在变量名定义数组的时候在<code>&lt;&gt;</code>中定义数组的类型  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> arr:<span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt;=[<span class="hljs-number">12</span>,<span class="hljs-number">123</span>]</span><br><span class="line"><span class="hljs-built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure></li></ul><h3 id="定义方式三"><a href="#定义方式三" class="headerlink" title="定义方式三:"></a>定义方式三:</h3><ul><li>在下面有<code>any</code>类型的讲解  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> arr:<span class="hljs-built_in">any</span>[]=[<span class="hljs-string">'123'</span>,<span class="hljs-number">456</span>,<span class="hljs-literal">false</span>]</span><br><span class="line"><span class="hljs-built_in">console</span>.log(arr)  <span class="hljs-comment">//输出: [ '123', 456, false ]</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="元祖类型-tuple"><a href="#元祖类型-tuple" class="headerlink" title="元祖类型(tuple)"></a>元祖类型(tuple)</h2><ul><li>属于数组中的一种,可以定义多种数据类型,但是必须一一对应  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> arr:[<span class="hljs-built_in">number</span>,<span class="hljs-built_in">string</span>]=[<span class="hljs-number">123</span>,<span class="hljs-string">"123"</span>]</span><br><span class="line">arr=[<span class="hljs-string">"123"</span>,<span class="hljs-number">123</span>] <span class="hljs-comment">//这样是错误的,值必须与数据类型一一对应</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="枚举类型-enum"><a href="#枚举类型-enum" class="headerlink" title="枚举类型(enum)"></a>枚举类型(enum)</h2><ul><li>  <figure class="highlight crystal hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Flag</span>&#123;</span></span><br><span class="line">    success=<span class="hljs-number">200</span>,</span><br><span class="line">    error=<span class="hljs-number">500</span></span><br><span class="line">&#125;</span><br><span class="line">let <span class="hljs-symbol">s:</span>Flag=Flag.success</span><br><span class="line">console.log(s)  /<span class="hljs-regexp">/输出:200 如果赋值了那么打印的就是你赋值的数字</span></span><br></pre></td></tr></table></figure>  <figure class="highlight crystal hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Flag</span>&#123;</span></span><br><span class="line">    success=<span class="hljs-number">1</span>,</span><br><span class="line">    error=<span class="hljs-number">2</span></span><br><span class="line">&#125;</span><br><span class="line">let <span class="hljs-symbol">s:</span>Flag=Flag.success</span><br><span class="line">console.log(s) /<span class="hljs-regexp">/输出:0 如果没有赋值那么输出的结果就是对应的下标,从  0 开始</span></span><br></pre></td></tr></table></figure>  <figure class="highlight crystal hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Flag</span>&#123;</span></span><br><span class="line">    success,</span><br><span class="line">    <span class="hljs-string">'error'</span>=<span class="hljs-number">3</span>,</span><br><span class="line">    number</span><br><span class="line">&#125;</span><br><span class="line">let <span class="hljs-symbol">s:</span>Flag=Flag.number</span><br><span class="line">console.log(s)  /<span class="hljs-regexp">/输出: 4,相当于前面的error=3赋值的是数组的下标,后面的值没有定义的话就是默认前面的下标+1</span></span><br></pre></td></tr></table></figure></li><li><p>为了详细一点,我们在看一下这个代码就清楚了</p>  <figure class="highlight sqf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="hljs-built_in">Flag</span>&#123;</span><br><span class="line">    <span class="hljs-string">'success'</span>=-<span class="hljs-number">1</span>,</span><br><span class="line">    <span class="hljs-string">'error'</span>=<span class="hljs-number">999</span>,</span><br><span class="line">    number</span><br><span class="line">&#125;</span><br><span class="line">let s:<span class="hljs-built_in">Flag</span>=<span class="hljs-built_in">Flag</span>.number</span><br><span class="line">console.<span class="hljs-built_in">log</span>(s) <span class="hljs-comment">//输出 1000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enum <span class="hljs-built_in">Flag</span>&#123;</span><br><span class="line">    <span class="hljs-string">'success'</span>=-<span class="hljs-number">10</span>,</span><br><span class="line">    <span class="hljs-string">'error'</span>=-<span class="hljs-number">15</span>,</span><br><span class="line">    number</span><br><span class="line">&#125;</span><br><span class="line">let s:<span class="hljs-built_in">Flag</span>=<span class="hljs-built_in">Flag</span>.number</span><br><span class="line">console.<span class="hljs-built_in">log</span>(s)  <span class="hljs-comment">//输出 -14</span></span><br></pre></td></tr></table></figure></li><li><p>注意:</p><ul><li>在这个Flag中定义的名称可以加 <strong>‘ ‘</strong>,也可以不加 <strong>‘ ‘</strong>,但是值一定不能加<strong>‘ ‘</strong>,并且只能是数字,否则报错</li></ul></li></ul><hr><h2 id="任意类型-any"><a href="#任意类型-any" class="headerlink" title="任意类型(any)"></a>任意类型(any)</h2><pre><code><figure class="highlight livecodeserver hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let <span class="hljs-built_in">num</span>:<span class="hljs-keyword">any</span>[]=[<span class="hljs-string">'123'</span>,<span class="hljs-number">123</span>]</span><br><span class="line"><span class="hljs-built_in">num</span>=[<span class="hljs-string">'a'</span>,<span class="hljs-number">45</span>]</span><br><span class="line">console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">num</span>);<span class="hljs-comment"> // 输出: ['a',45]</span></span><br></pre></td></tr></table></figure></code></pre><ul><li><p><code>any</code>可以是任意的类型,但是我们在平时定义数据时不要随意使用<code>any</code>,不然其他的数据类型设计就没有意义了</p></li><li><p><code>any</code>的正确用法:</p>  <figure class="highlight stylus hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let app = document.getElementById(<span class="hljs-string">'app'</span>)</span><br><span class="line">app<span class="hljs-selector-class">.style</span><span class="hljs-selector-class">.color</span>= <span class="hljs-string">'red'</span> <span class="hljs-comment">//报错了,对象可能为空</span></span><br></pre></td></tr></table></figure></li><li><p>在Typescript中,并没有Object类型,所以无论定义什么具体类型,都会报错,这个时候我们就需要加入<code>any</code></p>  <figure class="highlight stylus hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let app:any = document.getElementById(<span class="hljs-string">'app'</span>)</span><br><span class="line">app<span class="hljs-selector-class">.style</span><span class="hljs-selector-class">.color</span>= <span class="hljs-string">'red'</span></span><br></pre></td></tr></table></figure></li><li><p>这样我们就完美的解决了这个错误</p></li></ul><hr><h2 id="null和undefined-其他数据类型的子类型"><a href="#null和undefined-其他数据类型的子类型" class="headerlink" title="null和undefined 其他数据类型的子类型"></a>null和undefined 其他数据类型的子类型</h2><ul><li><p>示例:</p>  <figure class="highlight livecodeserver hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let <span class="hljs-built_in">num</span>:<span class="hljs-built_in">number</span></span><br><span class="line">console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">num</span>)<span class="hljs-comment"> //报错,在赋值前使用了num</span></span><br></pre></td></tr></table></figure></li><li><p>这说明number类型的数据在赋值前都不能使用</p>  <figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> num:<span class="hljs-literal">undefined</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(num)  <span class="hljs-comment">//输出: undedined</span></span><br></pre></td></tr></table></figure></li><li><p>有时候我们不管这个存不存在,存在的话就是number类型,不存在就是undefined类型</p><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3>  <figure class="highlight livecodeserver hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var  <span class="hljs-built_in">num</span>:undefined | <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span></span><br><span class="line"><span class="hljs-built_in">num</span>=<span class="hljs-number">123</span></span><br><span class="line">console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">num</span>)<span class="hljs-comment"> //输出 123 并且不报错</span></span><br></pre></td></tr></table></figure>  <figure class="highlight livecodeserver hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var  <span class="hljs-built_in">num</span>:undefined | <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span></span><br><span class="line">console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">num</span>)<span class="hljs-comment"> //输出:undefined ,就算是没有赋值也不会报错</span></span><br></pre></td></tr></table></figure>  <figure class="highlight livecodeserver hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var  <span class="hljs-built_in">num</span>:undefined | <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span></span><br><span class="line"><span class="hljs-built_in">num</span>=<span class="hljs-literal">null</span></span><br><span class="line">console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">num</span>)<span class="hljs-comment"> //输出 null</span></span><br></pre></td></tr></table></figure></li><li><p>这样就相当于有值就是number类型,没有值就是undefined,赋值为null就是null,因为undefined只能赋值为undefined,null只能赋值为null</p></li></ul><hr><h2 id="viod-类型"><a href="#viod-类型" class="headerlink" title="viod 类型"></a>viod 类型</h2><ul><li><p>在typescript中,viod类型表示没有任何类型,一般定义没有返回值的方法</p></li><li><p>示例:</p>  <figure class="highlight dust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-xml"><span class="hljs-comment">&lt;!--在ES5中--&gt;</span></span></span><br><span class="line"><span class="hljs-xml">function run():void</span><span class="hljs-template-variable">&#123;</span></span><br><span class="line"><span class="hljs-template-variable">    console.log('hello world')</span></span><br><span class="line"><span class="hljs-template-variable">&#125;</span><span class="hljs-xml"></span></span><br><span class="line"><span class="hljs-xml">run()  //正常输出</span></span><br></pre></td></tr></table></figure>  <figure class="highlight actionscript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>:undefined</span>&#123;</span><br><span class="line">    console.log(<span class="hljs-string">'aaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line">run() <span class="hljs-comment">//报错,声明类型如果不是 viod 或者 any ,必须要有返回值</span></span><br></pre></td></tr></table></figure>  <figure class="highlight actionscript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>:undefined</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">run() <span class="hljs-comment">//报错,不能返回数据类型不同的数据</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="never类型"><a href="#never类型" class="headerlink" title="never类型"></a>never类型</h2><ul><li><p>never类型其他类型(包括了null,undefined)的子类型,代表从来不会出现的值,怎么理解呢?</p>  <figure class="highlight stylus hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let <span class="hljs-selector-tag">a</span>:never</span><br><span class="line">a=<span class="hljs-number">123</span> <span class="hljs-comment">//报错</span></span><br><span class="line"></span><br><span class="line">let <span class="hljs-selector-tag">b</span>:never</span><br><span class="line">b=null <span class="hljs-comment">//报错</span></span><br></pre></td></tr></table></figure></li><li><p>这就说明了它不能是任意我们可以有的值,必须是没有的数据类型</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> err:never</span><br><span class="line">err= <span class="hljs-function">(<span class="hljs-params">(<span class="hljs-params"></span>)=&gt;&#123;</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-params">'error'</span>)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">&#125;</span>)<span class="hljs-params">()</span></span></span><br></pre></td></tr></table></figure></li><li><p>当我们使用never定义自执行函数抛出错误时,那么就可以使用never了,但是使用场景并不是很多,很多时候我们使用<code>any</code>来代替</p></li></ul><hr><h2 id="总结的一些问题"><a href="#总结的一些问题" class="headerlink" title="总结的一些问题:"></a>总结的一些问题:</h2><ul><li><p>类型的推断</p>  <figure class="highlight dart hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let <span class="hljs-built_in">num</span>;</span><br><span class="line"><span class="hljs-built_in">num</span>=<span class="hljs-string">'45'</span>,</span><br><span class="line"><span class="hljs-built_in">num</span>=<span class="hljs-number">123</span></span><br><span class="line">console.log(<span class="hljs-built_in">num</span>) <span class="hljs-comment">//123</span></span><br></pre></td></tr></table></figure></li><li><p>我们可以推断,如果一开始没有给变量赋值,那么我们推断它默认就是 <code>any</code> 类型,可以赋任意值,和变量没有指定数据类型赋值一样,我们推断它是使用第一个赋值的数据类型作为该变量数据类型</p></li><li><p>在viod类型中,函数如果没有返回值那么使用 viod定义,如果有返回值,那么返回数据类型必须和定义函数的数据类型保持一致</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。这里主要介绍前五种原始数据类型和一些其他的TypeScript的数据类型&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="https://zhongyuehui.github.io/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://zhongyuehui.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Node中的path路径模块</title>
    <link href="https://zhongyuehui.github.io/2019/07/07/Node%E4%B8%AD%E7%9A%84path%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97/"/>
    <id>https://zhongyuehui.github.io/2019/07/07/Node中的path路径模块/</id>
    <published>2019-07-07T05:36:24.000Z</published>
    <updated>2019-07-09T11:18:03.370Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在Node中，有许多的模块,但是Node.js path 模块提供了一些用于处理文件路径的小工具</p></blockquote><a id="more"></a><h2 id="Path模块"><a href="#Path模块" class="headerlink" title="Path模块"></a>Path模块</h2><ul><li><p>引入<br>  <code>const path = require(&#39;path&#39;)</code></p><h3 id="path的一些方法"><a href="#path的一些方法" class="headerlink" title="path的一些方法"></a>path的一些方法</h3><h3 id="path-basename"><a href="#path-basename" class="headerlink" title="path.basename():"></a>path.basename():</h3></li><li><p>只有一个参数时<br><img src="https://s2.ax1x.com/2019/07/07/ZBYSYV.png" alt="path.basename"></p></li><li><p>有两个参数时，且参数的后缀名相同时<br><img src="https://s2.ax1x.com/2019/07/07/ZBYCSU.png" alt="path.basename2"></p></li><li><p>有两个参数时，且参数的后缀名不相同时<br><img src="https://s2.ax1x.com/2019/07/07/ZBYiy4.png" alt="path.basename3"></p></li><li><p><strong>总结</strong>：</p><ul><li>一个参数时直接输出带后缀名的文件名</li><li>两个参数时第二个参数为第一个参数的后缀名时输出为不带后缀名的文件名</li><li>两个参数时第二个参数不是第一个参数的后缀名时输出仍是带后缀名的文件名<h3 id="path-dirname"><a href="#path-dirname" class="headerlink" title="path.dirname()"></a>path.dirname()</h3><img src="https://s2.ax1x.com/2019/07/07/ZBJjwn.png" alt="path.dirname"></li></ul></li><li><p>只输出目录</p><h3 id="path-extname"><a href="#path-extname" class="headerlink" title="path.extname()"></a>path.extname()</h3><p><img src="https://s2.ax1x.com/2019/07/07/ZBYFOJ.png" alt="pathextname"></p></li><li><p>只输出后缀名</p><h3 id="path-isAbsolute"><a href="#path-isAbsolute" class="headerlink" title="path.isAbsolute()"></a>path.isAbsolute()</h3><p><img src="https://s2.ax1x.com/2019/07/07/ZBYEwR.png" alt="path.isAbsolute"></p></li><li><p>判断是否为绝对路径，返回一个布尔值</p></li><li><p><strong>注意：</strong>文件路径前不能有空格 否则直接返回<code>flase</code></p></li><li><p>拓展：绝对路径的两种方式</p><ul><li>如：c:/a/b/c/index.js ，有磁盘符，相对于磁盘符的绝对路径</li><li>如：/a/b/c/index.js ，没有磁盘符，相对于当前磁盘下的绝对路径<h3 id="path-parse"><a href="#path-parse" class="headerlink" title="path.parse()"></a>path.parse()</h3><img src="https://s2.ax1x.com/2019/07/07/ZBYnfK.png" alt="parse"></li></ul></li><li><p>查看文件的详细信息</p><h3 id="path-join"><a href="#path-join" class="headerlink" title="path.join()"></a>path.join()</h3><p><img src="https://s2.ax1x.com/2019/07/07/ZBYMlD.png" alt="path.join"></p></li><li><p>路径拼接 </p><blockquote><p>在Node中，许多时候我们都需要用到路径模块，对文件路径的判断做出相应的响应</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在Node中，有许多的模块,但是Node.js path 模块提供了一些用于处理文件路径的小工具&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Nodejs" scheme="https://zhongyuehui.github.io/categories/Nodejs/"/>
    
    
      <category term="nodejs" scheme="https://zhongyuehui.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Vuex的使用</title>
    <link href="https://zhongyuehui.github.io/2019/07/05/Vuex%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://zhongyuehui.github.io/2019/07/05/Vuex的使用/</id>
    <published>2019-07-05T14:02:22.000Z</published>
    <updated>2019-07-09T11:18:26.942Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>vuex是什么？Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p></blockquote><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>我们在进行一些复杂的父子组件之间的传值的时候，尤其是组件嵌套传值时尤其麻烦，读取值不方便，如果有异步操作，还需要对值监听，这样获取一些值得时候对我们开发人员不友好，所以诞生了Vuex</p></blockquote><h1 id="Vuex的使用"><a href="#Vuex的使用" class="headerlink" title="Vuex的使用"></a>Vuex的使用</h1><h2 id="vuex的安装配置"><a href="#vuex的安装配置" class="headerlink" title="vuex的安装配置"></a>vuex的安装配置</h2><ul><li><p>安装:<code>npm install vuex -S</code></p></li><li><p>如果使用<code>&lt;script&gt;&lt;/script&gt;</code>标签引入的<code>vue</code>，那么自己会安装有<code>vuex</code></p></li><li><p>安装插件：</p>  <figure class="highlight clean hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span></span><br><span class="line"><span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure></li><li><p>配置:</p>  <figure class="highlight pf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  <span class="hljs-keyword">state</span>: &#123;  //这个就是相当于 vue中的 data，用来存放数据的</span><br><span class="line">    count: <span class="hljs-number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;  //这个相当于 vue 中的 methods ，存放了些方法</span><br><span class="line">    increment (<span class="hljs-keyword">state</span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">state</span>.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>使用:实现一个小案例，官方也是这个案例来说明的：</p></li><li><p><code>main.js</code></p>  <figure class="highlight pf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 入口文件</span><br><span class="line">import Vue <span class="hljs-keyword">from</span> 'vue'</span><br><span class="line">// 配置vuex的步骤</span><br><span class="line">// <span class="hljs-number">1</span>. 运行 cnpm i vuex -S </span><br><span class="line">// <span class="hljs-number">2</span>. 导入包</span><br><span class="line">import Vuex <span class="hljs-keyword">from</span> 'vuex'</span><br><span class="line">// <span class="hljs-number">3</span>. 注册vuex到vue中</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line">    // <span class="hljs-number">4</span>. new Vuex.Store() 实例，得到一个 数据仓储对象</span><br><span class="line">var store = new Vuex.Store(&#123;</span><br><span class="line">    <span class="hljs-keyword">state</span>: &#123;</span><br><span class="line">        // 大家可以把 <span class="hljs-keyword">state</span> 想象成 组件中的 data ,专门用来存储数据的</span><br><span class="line">        // 如果在 组件中，想要访问，store 中的数据，只能通过 this.<span class="hljs-variable">$store</span>.<span class="hljs-keyword">state</span>.*** 来访问</span><br><span class="line">        count: <span class="hljs-number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">mutations: &#123;</span><br><span class="line">    // 注意： 如果要操作 store 中的 <span class="hljs-keyword">state</span> 值，只能通过 调用 mutations 提供的方法，才能操作对应的数据，不推荐直接操作 <span class="hljs-keyword">state</span> 中的数据，因为 万一导致了数据的紊乱，不能快速定位到错误的原因，因为，每个组件都可能有操作数据的方法；</span><br><span class="line">    increment(<span class="hljs-keyword">state</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">state</span>.count++</span><br><span class="line">    &#125;,</span><br><span class="line">    // 注意： 如果组件想要调用 mutations 中的方法，只能使用 this.<span class="hljs-variable">$store</span>.commit('方法名')</span><br><span class="line">    // 这种 调用 mutations 方法的格式，和 this.<span class="hljs-variable">$emit</span>('父组件中方法名')</span><br><span class="line">    subtract(<span class="hljs-keyword">state</span>, obj) &#123;</span><br><span class="line">        // 注意： mutations 的 函数参数列表中，最多支持两个参数，其中，参数<span class="hljs-number">1</span>： 是 <span class="hljs-keyword">state</span> 状态； 参数<span class="hljs-number">2</span>： 通过 commit 提交过来的参数；</span><br><span class="line">        console.<span class="hljs-keyword">log</span>(obj)</span><br><span class="line">        <span class="hljs-keyword">state</span>.count -= (obj.c + obj.d)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">getters: &#123;</span><br><span class="line">    // 注意：这里的 getters， 只负责 对外提供数据，不负责 修改数据，如果想要修改 <span class="hljs-keyword">state</span> 中的数据，请 去找 mutations</span><br><span class="line">    optCount: function(<span class="hljs-keyword">state</span>) &#123;</span><br><span class="line">            return '当前最新的count值是：' + <span class="hljs-keyword">state</span>.count</span><br><span class="line">        &#125;</span><br><span class="line">        // 经过咱们回顾对比，发现 getters 中的方法， 和组件中的过滤器比较类似，因为 过滤器和 getters 都没有修改原数据， 都是把原数据做了一层包装，提供给了 调用者；</span><br><span class="line">        // 其次， getters 也和 computed 比较像， 只要 <span class="hljs-keyword">state</span> 中的数据发生变化了，那么，如果 getters 正好也引用了这个数据，那么 就会立即触发 getters 的重新求值；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">import App <span class="hljs-keyword">from</span> './App.vue'</span><br><span class="line"></span><br><span class="line">const vm = new Vue(&#123;</span><br><span class="line">    el: '<span class="hljs-comment">#app',</span></span><br><span class="line">    render: h =&gt; h(App),</span><br><span class="line">    store // <span class="hljs-number">5</span>. 将 vuex 创建的 store 挂载到 VM 实例上， 只要挂载到了 vm 上，任何组件都能使用 store 来存取数据</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>counter.vue</code>文件内容</p> <figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"减少"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"remove"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"增加"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"add"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"$store.state.count"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"><span class="hljs-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="hljs-actionscript">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-comment">// count: 0</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    add() &#123;</span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-comment">// 不要这样使用，不符合 vuex 的设计理念，因为这样直接操作了state</span></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-comment">// this.$store.state.count++;</span></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-keyword">this</span>.$store.commit(<span class="hljs-string">"increment"</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    remove() &#123;</span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-keyword">this</span>.$store.commit(<span class="hljs-string">"subtract"</span>, &#123; c: <span class="hljs-number">3</span>, d: <span class="hljs-number">1</span> &#125;);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed:&#123;</span><br><span class="line">    fullname: &#123;</span><br><span class="line"><span class="hljs-javascript">      <span class="hljs-keyword">get</span>()&#123;&#125;,</span></span><br><span class="line"><span class="hljs-javascript">      <span class="hljs-keyword">set</span>()&#123;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"scss"</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>amount.vue</code>文件内容：</p>  <figure class="highlight django hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml">    <span class="hljs-comment">&lt;!-- &lt;h3&gt;</span></span><span class="hljs-template-variable">&#123;&#123; $store.state.count &#125;&#125;</span><span class="hljs-xml"><span class="hljs-comment">&lt;/h3&gt; --&gt;</span></span></span><br><span class="line"><span class="hljs-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; $store.getters.optCount &#125;&#125;</span><span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml">    </span></span><br><span class="line"><span class="hljs-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml"></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml"></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"scss"</span> <span class="hljs-attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml"></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>这样，这两个兄弟节点，就可以通过<code>state</code>读写数据了，不需要进行组件之间的传值</p></li><li><p>总结：</p><ol><li><code>state</code>中的数据，不能直接修改，如果想要修改，必须通过 <code>mutations</code>,不然的话就违背了<code>vuex</code>的设计初衷</li><li>如果组件想要直接 从 state 上获取数据： 需要 <code>this.$store.state.***</code></li><li>如果 组件，想要修改数据，必须使用 mutations 提供的方法，需要通过 <code>this.$store.commit(&#39;方法的名称&#39;， 唯一的一个参数)</code></li><li>如果 <code>store</code> 中 <code>state</code> 上的数据， 在对外提供的时候，需要做一层包装，那么 ，推荐使用 <code>getters</code>, 如果需要使用 <code>getters</code> ,则用 <code>this.$store.getters.***</code></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;vuex是什么？Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://zhongyuehui.github.io/categories/Vue/"/>
    
    
      <category term="vuex" scheme="https://zhongyuehui.github.io/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vs code中Git工具的使用</title>
    <link href="https://zhongyuehui.github.io/2019/07/02/Vs%20code%E4%B8%ADGit%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://zhongyuehui.github.io/2019/07/02/Vs code中Git工具的使用/</id>
    <published>2019-07-02T02:25:57.000Z</published>
    <updated>2019-07-09T11:18:49.523Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在一些开发工具中，集成了许多的功能，在我喜欢的vscode中，就集成了git的一些功能，非常方便我们使用</p></blockquote><a id="more"></a><h2 id="vscode中的Git工具"><a href="#vscode中的Git工具" class="headerlink" title="vscode中的Git工具"></a>vscode中的Git工具</h2><ul><li>当我们在对一些推送到远程的项目进行修改时，我们在VS code中发现修改的内容在侧边会有标记<ul><li><font color="red">红色</font>的箭头标识表示这里删除了一些东西</li><li><font color="green">绿色</font>标识表示这里修改了一些东西</li><li><font color="blue">蓝色</font>标识标识增加了一些东西</li></ul></li><li>当然，我们要说的并不是只有这些，最主要的是我们修改的文件内容后需要推送到远程，再也不需要<code>git add &#39;&#39;、git commit -m &#39;&#39; ，git push</code>了，我们在侧边栏找到这个工具<br><img src="https://s2.ax1x.com/2019/07/02/ZGB7s1.png" alt="git工具"></li><li>在这里工具会显示你修改了几个文件，而在更多这里显示你修改了哪些文件，鼠标指针放在修改的文件可以对文件进行一些操作，比如撤回修改</li><li>我们继续往下看，在这里有一个 <code>message</code>这里需要添加的是你提交的描述，和<code>git commit -m &#39;&#39;</code> 这里的一致，添加消息后点击 <strong>√</strong>就可以保存到暂存区了</li><li>如果需要推送到远程，点击推送即可<br><img src="https://s2.ax1x.com/2019/07/02/ZGDuyn.png" alt="推送到远程">、</li><li><strong>注意：</strong>如果你关联了多个远程，那么直接点击推送可能会报错，因为它不知道你需要推送到哪一个，所以选择<code>推送到...</code>然后选择即可<br><img src="https://s2.ax1x.com/2019/07/02/ZGDwex.png" alt="选择仓库"></li><li>这样我们在以后的开发中可以减少一点工作量</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在一些开发工具中，集成了许多的功能，在我喜欢的vscode中，就集成了git的一些功能，非常方便我们使用&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="开发工具" scheme="https://zhongyuehui.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="vs code" scheme="https://zhongyuehui.github.io/tags/vs-code/"/>
    
  </entry>
  
  <entry>
    <title>关联多个远程仓库</title>
    <link href="https://zhongyuehui.github.io/2019/07/02/%E5%85%B3%E8%81%94%E5%A4%9A%E4%B8%AA%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <id>https://zhongyuehui.github.io/2019/07/02/关联多个远程仓库/</id>
    <published>2019-07-02T01:21:36.000Z</published>
    <updated>2019-07-09T11:19:17.606Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们在日常的开发中，由于GitHub是外国的服务器，所以上传速度较慢，但是我们国内也有托管的网站，比如码云</p></blockquote><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><ul><li>在实际的开发过程中，团队协作开发项目是必不可少的，我们将项目托管到远程仓库上，就是为了解决多人合作开发和代码托管备份的作用，而有时候我们需要将一个项目托管到多个仓库中，现在我们就一起来学习一下如何操作</li></ul><hr><h2 id="使用码云"><a href="#使用码云" class="headerlink" title="使用码云"></a>使用码云</h2><hr><ul><li>要想使用码云现需要注册</li><li>注册成功后在个人中心，配置ssh，因为我们在github中，已经生成了ssh，所以我们直接拿公钥即可<br><img src="https://s2.ax1x.com/2019/07/02/ZGtnfI.png" alt="ssh公钥"></li><li>然后在个人中心旁边有个 + 号 新建仓库即可<br><img src="https://s2.ax1x.com/2019/07/02/ZGtNhn.png" alt="仓库"><h2 id="关联github和码云"><a href="#关联github和码云" class="headerlink" title="关联github和码云"></a>关联github和码云</h2></li><li>在git的使用我们已经详细的简述了如何托管到GitHub中，现在我们讲述一下托管到GitHub和码云中</li><li><code>git remote rm origin</code>；先删除已经关联的<code>origin</code>远程仓库</li><li>git remote add github <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:ZhongYueHui/vue-001.git</li><li><strong>注意：</strong>，远程仓库名是<code>github</code>了不是<code>origin</code>了</li><li>接着关联码云的仓库</li><li>git remote add gitee <a href="mailto:git@gitee.com" target="_blank" rel="noopener">git@gitee.com</a>:zhongyuehui/vue-001.git</li><li><strong>注意：</strong>，远程仓库名是<code>gitee</code>了不是<code>origin</code>了</li><li>现在我们使用<code>git remote -v</code>就可以查看到远程库的信息了  <figure class="highlight stylus hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gitee   git@gitee<span class="hljs-selector-class">.com</span>:zhongyuehui/vue-<span class="hljs-number">001</span><span class="hljs-selector-class">.git</span> (fetch)</span><br><span class="line">gitee   git@gitee<span class="hljs-selector-class">.com</span>:zhongyuehui/vue-<span class="hljs-number">001</span><span class="hljs-selector-class">.git</span> (push)</span><br><span class="line">github  git@github<span class="hljs-selector-class">.com</span>:ZhongYueHui/vue-<span class="hljs-number">001</span><span class="hljs-selector-class">.git</span> (fetch)</span><br><span class="line">github  git@github<span class="hljs-selector-class">.com</span>:ZhongYueHui/vue-<span class="hljs-number">001</span><span class="hljs-selector-class">.git</span> (push)</span><br></pre></td></tr></table></figure></li></ul><h2 id="推送到GitHub和码云"><a href="#推送到GitHub和码云" class="headerlink" title="推送到GitHub和码云"></a>推送到GitHub和码云</h2><ul><li>推送到GitHub：<code>git push github master</code></li><li>推送到码云:<code>git push gitee master</code></li><li>这样，我们的项目将就分别在git和码云中了</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我们在日常的开发中，由于GitHub是外国的服务器，所以上传速度较慢，但是我们国内也有托管的网站，比如码云&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Git" scheme="https://zhongyuehui.github.io/categories/Git/"/>
    
    
      <category term="git" scheme="https://zhongyuehui.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git的使用</title>
    <link href="https://zhongyuehui.github.io/2019/07/01/git%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://zhongyuehui.github.io/2019/07/01/git的使用/</id>
    <published>2019-07-01T13:47:23.000Z</published>
    <updated>2019-07-09T11:17:32.230Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>git是什么？Git(读音为/gɪt/。)是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理</p></blockquote><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>我们在平时的项目开发中，难免会用到一些托管工具来托管自己的代码，这样可以更好的和别人和分享自己项目和合作开发项目，这里就简单介绍一下git的使用。</p></blockquote><hr><h1 id="git的使用"><a href="#git的使用" class="headerlink" title="git的使用"></a>git的使用</h1><h2 id="Git基本操作"><a href="#Git基本操作" class="headerlink" title="Git基本操作"></a>Git基本操作</h2><hr><h3 id="上传本地文件-工作区-到暂存区"><a href="#上传本地文件-工作区-到暂存区" class="headerlink" title="上传本地文件(工作区)到暂存区"></a>上传本地文件(工作区)到暂存区</h3><hr><ul><li><p><code>git status</code>先初始化项目(状态)，检查是否在工作区域还是暂存区</p></li><li><p><code>git add 文件名</code>将文件上传到暂存区</p></li></ul><hr><h3 id="将暂存区的文件上传到git仓库中"><a href="#将暂存区的文件上传到git仓库中" class="headerlink" title="将暂存区的文件上传到git仓库中"></a>将暂存区的文件上传到git仓库中</h3><hr><ul><li><p><code>git status</code>初始化暂存区的项目，查看是否含有相同的内容</p></li><li><p><code>git commit -m &quot;提交的描述&quot;</code>，项目的说明</p></li><li><p><code>git status</code> 查看文件状态</p></li><li><p><strong>注意：</strong>使用 <code>git commit -m &#39;&#39;</code> 是一次性将文件放到分支，使用<code>git add</code>是将文件添加到暂存区(Stage), git是版本控制工具，并不是文件控制工具，我们只有使用<code>git add</code>添加到暂存区的文件，再使用<code>git commit -m &#39;&#39;</code>才能将文件提交到分支，如果你修改了文件直接提交到分支，这个是不能修改的，不信你可以使用<code>git diff HEAD -- &#39;文件名&#39;</code>查看工作区和版面本库中最新版本的区别 ，没有使用<code>git add &#39;&#39;</code> 的文件内容没有并没有添加到版本库(commit)中</p></li></ul><hr><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ul><li>基本流程图<br><img src="https://s2.ax1x.com/2019/06/30/Z39gFP.png" alt="GitHub基本流程"></li></ul><hr><h2 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h2><hr><ul><li><strong>设置用户名</strong>:<code>git config --global user.name &#39;GitHub的用户名&#39;</code></li><li><strong>设置用户名的邮箱</strong>：<code>git config --global user.email &#39;设置用户名的邮箱&#39;</code></li></ul><hr><h2 id="初始化新的git仓库"><a href="#初始化新的git仓库" class="headerlink" title="初始化新的git仓库"></a>初始化新的git仓库</h2><hr><ul><li>创建新的文件夹 也可以在命令行 <code>mkdir 文件夹名字</code>进行创建</li><li>进入文件夹 ，命令行<code>cd 文件夹名</code></li><li>初始化仓库, 命令行 <code>git init</code> ，会生成一个<code>.git</code>的文件夹，若没有在文件夹下点击查看，打开显示隐藏的项目<br><img src="https://s2.ax1x.com/2019/06/30/Z3iPxO.png" alt="查看隐藏文件"></li></ul><hr><h2 id="项目的管理"><a href="#项目的管理" class="headerlink" title="项目的管理"></a>项目的管理</h2><hr><h3 id="上传文件项目-使用流程"><a href="#上传文件项目-使用流程" class="headerlink" title="上传文件项目(使用流程)"></a>上传文件项目(使用流程)</h3><hr><ul><li>在项目文件夹中，创建文件，也可以在命令行中使用<code>touch 文件名</code></li><li><strong>注意</strong>：需要带后缀名</li><li>然后使用 <code>git status</code>可以查看文件是否在暂存区域中(没有是红色)</li><li>如果没有，使用<code>git add &#39;文件名&#39;</code>即可将文件名上传到暂存区中</li><li><code>git status</code>查看文件是否已经存在于暂存区(存在是绿色)</li></ul><hr><h3 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h3><hr><ul><li>命令行直接 <code>vi/vim 文件名</code>即可输入内容，也可以鼠标右键编辑</li><li>修改后 <code>git status</code>，发现文件更改后，又变成红色，需要重新提交</li><li><code>git diff</code>可以查看修改了什么内容</li><li><code>git add 文件名</code>提交即可</li><li><code>git status</code>发现没有文件可以提交，则提交成功</li></ul><hr><h4 id="撤销修改-例如撤回reademe-txt文件的修改"><a href="#撤销修改-例如撤回reademe-txt文件的修改" class="headerlink" title="撤销修改(例如撤回reademe.txt文件的修改)"></a>撤销修改(例如撤回reademe.txt文件的修改)</h4><hr><ul><li>我们再修改文件时可能由于出错误修改，我们可以及时的将文件返回到上一个未修改的版本，修改文件后 <code>git status</code>也可以发现git会提示你使用<code>git checkout -- &lt;file&gt;</code>可以丢弃工作区的修改</li><li>当然，命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：<ul><li>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li><li>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li></ul></li><li>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</li></ul><hr><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><hr><ul><li>在命令行<code>rm -rf 文件名</code>(强制删除，不建议使用)或者<code>rm 文件名</code>(普通删除),<code>rm -l 文件名</code>(删除三个以上提示),<code>rm -i 文件名</code>(删除前提示，可以确认删除文件是否选择正确)，或者在鼠标右键删除</li><li><strong>注意</strong>：上面的步骤是在工作区删除</li><li><code>git rm 文件名</code>:是在git中删除文件</li><li><code>git commit -m &#39;提交描述&#39;</code>，如果需要删除某个文件，则需要<code>rm 文件</code> 再 <code>git rm 文件</code> 再 <code>git commit -m &#39;提交描述&#39;</code>,这样就可以完整的删除这个文件了</li><li><strong>注意</strong>：使用<code>git log</code> 可以查看每次版本的修改历史，如果你嫌弃信息过多眼花缭乱，也可以使用<code>git log --pretty=oneline</code>查看，其中一大串的只是commit id(版本号)而已</li></ul><hr><h3 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h3><hr><ul><li>在git中，使用HEAD表示当前的版本，上个版本使用 <strong>(HEAD^)</strong>表示，上上版本使用 <strong>(HEAD^^)</strong>表示，如果是多个可以使用 <strong>(HEAD~N)</strong>表示</li><li>使用 <code>git reset --hard HEAD^</code>表示回退上一个版本，但是我们使用<code>git log</code>已经查看不到之前我们跳转过来的历史了，但是如果我们想还原，也还是有办法的，只要我们不关闭命令行窗口，找到之前的<strong>commit id</strong>,就可以回到未来的指定版本</li><li>使用<code>git reset --hard commit id</code> 后，可以查看是否回到上个版本了</li></ul><p><strong>注意：</strong> 使用commit id 时不需要全部填写 但是要精确到git能找到该文件</p><blockquote><p>如果我们回退到上一个版本后已经关闭了命令行又想回到最新版本怎么办？</p></blockquote><ul><li>在git中，提供了一个命令<code>git reflog</code>可以记录你的每一条命令</li></ul><hr><h2 id="git远程仓库"><a href="#git远程仓库" class="headerlink" title="git远程仓库"></a>git远程仓库</h2><hr><h3 id="添加远程仓库-如：test"><a href="#添加远程仓库-如：test" class="headerlink" title="添加远程仓库(如：test)"></a>添加远程仓库(如：test)</h3><hr><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><hr><h5 id="创建ssh（如果已经创建关联请忽略）"><a href="#创建ssh（如果已经创建关联请忽略）" class="headerlink" title="创建ssh（如果已经创建关联请忽略）"></a>创建ssh（如果已经创建关联请忽略）</h5><ul><li>在命令行下<code>ssh-keygen -t rsa -C &quot;898542119@qq.com&quot;</code>,然后一路回车即可</li><li>在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人</li><li>登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容即可，这样我们的关联就已经做好了</li></ul><hr><h4 id="远程添加文件到仓库中"><a href="#远程添加文件到仓库中" class="headerlink" title="远程添加文件到仓库中"></a>远程添加文件到仓库中</h4><ul><li>登陆GitHub，点击 <strong>“Create a new repo”</strong>，在<strong>Repository name</strong> 填入仓库名称，其他的默认即可</li><li>在你本地的仓库中运行如下：<code>git remote add origin git@github.com:ZhongYueHui/test.git</code>其中ZhongYueHui是GitHub的名字,test仓库的名字</li><li>然后使用 <code>git push -u origin master</code>就可以将文件提交到GitHub上了，其实就是将本地分支 master 推送到远程，这样远程的仓库和本地就一样了</li><li>从现在开始，只要你对文件做了修改，就可以使用<code>git push origin master</code>将最新的修改提交到版本库了</li><li><strong>注意：</strong>如果第一次clone或者push会弹出如下警告,输入yes即可 <figure class="highlight vbnet hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity <span class="hljs-keyword">of</span> host <span class="hljs-comment">'github.com (xx.xx.xx.xx)' can't be established.</span></span><br><span class="line">RSA <span class="hljs-keyword">key</span> fingerprint <span class="hljs-keyword">is</span> xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want <span class="hljs-keyword">to</span> <span class="hljs-keyword">continue</span> connecting (yes/no)?</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="从远程克隆仓库"><a href="#从远程克隆仓库" class="headerlink" title="从远程克隆仓库"></a>从远程克隆仓库</h3><hr><ul><li>在命令行输入<code>git clone git@github.com:ZhongYueHui/gitskills.git</code>即可克隆<code>gitskills</code>仓库</li><li><strong>注意：</strong>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆,<br>Git支持多种协议，包括<code>https</code>，但通过<code>ssh</code>支持的原生<code>git协议</code>速度最快</li></ul><hr><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><hr><h3 id="创建和合并分支"><a href="#创建和合并分支" class="headerlink" title="创建和合并分支"></a>创建和合并分支</h3><ul><li><p>创建分支:<code>git checkout -b 分支名称</code>，<code>git checkout -b dev</code>相当于创建新分支并切换，相当于如下两条命令</p>  <figure class="highlight q hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch <span class="hljs-built_in">dev</span> <span class="hljs-comment">//创建分支</span></span><br><span class="line">git checkout <span class="hljs-built_in">dev</span> <span class="hljs-comment">//切换分支</span></span><br></pre></td></tr></table></figure></li><li><p>查看分支:<code>git branch</code>,会列出所有的分支，当前的分支会使用<code>*</code>标记</p></li><li><p>我们在<code>dev</code>分支下修改的文件在切换到<code>master</code>分支查看，发现并未修改，但是我们可以使用<code>git merge dev</code>将dev分支合并到当前的分支上(<code>master</code>)</p></li><li><p>合并完之后，我们就可以将<code>dev</code>分支删除了:<code>git branch -d dev</code>，使用<code>git branch</code>查看分支就只有<code>master</code> 了</p></li><li><p><strong>小结</strong>：</p>  <figure class="highlight fortran hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">查看分支：git branch</span><br><span class="line"></span><br><span class="line">创建分支：git branch &lt;<span class="hljs-keyword">name</span>&gt;</span><br><span class="line"></span><br><span class="line">切换分支：git checkout &lt;<span class="hljs-keyword">name</span>&gt;</span><br><span class="line"></span><br><span class="line">创建+切换分支：git checkout -b &lt;<span class="hljs-keyword">name</span>&gt;</span><br><span class="line"></span><br><span class="line">合并某分支到当前分支：git <span class="hljs-built_in">merge</span> &lt;<span class="hljs-keyword">name</span>&gt;</span><br><span class="line"></span><br><span class="line">删除分支：git branch -d &lt;<span class="hljs-keyword">name</span>&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="分支之间的冲突"><a href="#分支之间的冲突" class="headerlink" title="分支之间的冲突"></a>分支之间的冲突</h3><ul><li>假设我们在创建了一个分支<strong>feature1</strong>，我们在feature1上修改reademe.txt文件，然后<code>git add  reademe.txt</code>和<code>git commit -m &#39;&#39;</code>，然后切换到<code>master</code>中同样对reademe.txt做出修改，然后<code>git add  reademe.txt</code>和`git commit -m</li><li>这样，我们想合并<strong>feature1</strong>分支就会出异常，Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改自己想要的内容和删除标记后保存：这个时候我们需要将内容统一到和<strong>feature1</strong>，然后<code>git add  reademe.txt</code>和<code>git commit -m</code>即可</li><li>我们还可以使用<code>git log --graph --pretty=oneline --abbrev-commit</code>查看分支合并情况<h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900005860592480" target="_blank" rel="noopener">分支管理策略</a></h3></li><li>合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用<code>Fastforward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息</li><li>假设我们在创建了一个分支<strong>feature1</strong>，我们在feature1上修改reademe.txt文件，然后<code>git add  reademe.txt</code>和<code>git commit -m &#39;&#39;</code>，然后切换到<code>master</code>中,准备合并<strong>feature1</strong>，使用=&gt;<code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>进行合并，注意 <code>--no-ff</code>表示的是<strong>禁用</strong><code>Fast forward</code></li><li><code>git log --graph --pretty=oneline --abbrev-commit</code>查看分支历史<figure class="highlight coq hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> *   e1e9c68 (HEAD -&gt; master) merge <span class="hljs-built_in">with</span> no-ff</span><br><span class="line">|<span class="hljs-type">\  </span></span><br><span class="line"><span class="hljs-type">| * f52c633</span> (dev) add merge</span><br><span class="line">|<span class="hljs-type">/  </span></span><br><span class="line"><span class="hljs-type">*   cf810e4</span> conflict fixed</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure></li></ul><h3 id="BUG分支"><a href="#BUG分支" class="headerlink" title="BUG分支"></a>BUG分支</h3><ul><li><p>我们可能在开发中出现一些紧急的BUG需要及时修复，你可能马上想创建一个BUG修复的文件，但是你突然发现自己手中的 工作还没做完，无法提交，这时候就需要用到Git提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作</p></li><li><p>我们使用<code>git stash</code>来暂停自己的工作现场，然后创建自己的<code>bug修复分区</code>，然后<code>git add &#39;&#39;</code>,<code>git commit -m &#39;&#39;</code>后合并到master分区中，这样BUG修复完毕了，删除bug修复分区即可（<code>git merge --no-ff -m &quot;删除描述&quot; 分区名</code>）</p></li><li><p>修复完后就可以切换到自己原来的分区继续工作了，但是我们需要使用<code>git stash list</code>查看，使用<code>git status</code>查看是干净的，然后我们可以使用<code>git stash apply</code>恢复，但是恢复后，<code>stash</code>内容并不删除，你需要用<code>git stash drop</code>来删除；<br>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容(就是暂停的记录)也删了,再使用<code>git stash list</code>就是干净的了                                                                    </p>  <figure class="highlight applescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stash@&#123;<span class="hljs-number">0</span>&#125;: WIP <span class="hljs-keyword">on</span> master: <span class="hljs-number">54</span>a255b git tracks changes</span><br></pre></td></tr></table></figure></li><li><p>你可以多次使用<code>git stash list</code>，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的<code>stash</code>，用命令：<code>git stash apply stash@{0}</code></p><h3 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h3></li><li><p>用于实验的项目功能，不能直接用于主分支，容易乱掉，所以最好新建一个分支进行实验性测试</p></li><li><p>新建一个分区后，新建一个增加功能的文件，<code>git add &#39;&#39;</code>,<code>git commit -m &#39;&#39;</code>后<code>git checkout dev</code>合并到dev中，如果此时想删除这个功能文件，我们此时就应该删除该文件<code>git branch -d feature-vulcan</code>，如果提示还没有合并，那么直接将<code>-d</code>换成<code>-D</code>即可强制删除该分区</p>  <figure class="highlight subunit hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">error: </span>The branch 'feature-vulcan' is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run 'git branch -D feature-vulcan'.</span><br></pre></td></tr></table></figure></li></ul><h3 id="远程同步分支"><a href="#远程同步分支" class="headerlink" title="远程同步分支"></a>远程同步分支</h3><ul><li>当我们需要多个人同时开发项目时，我们应该将本地的分支推送到远程分支上</li><li>当我们从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。要查看远程库的信息，用<code>git remote</code>或者<code>git remote -v</code>   <figure class="highlight stylus hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin  git@github<span class="hljs-selector-class">.com</span>:ZhongYueHui/learngit<span class="hljs-selector-class">.git</span> (fetch)</span><br><span class="line">origin  git@github<span class="hljs-selector-class">.com</span>:ZhongYueHui/learngit<span class="hljs-selector-class">.git</span> (push)</span><br></pre></td></tr></table></figure></li></ul><h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h4><ul><li><code>git push origin master</code>将本地分支推送到远程分支上</li><li>如果推送<code>dev</code>这个分区，<code>git push origin dev</code>即可</li><li><strong>说明：</strong> 并不是每个分支都需要被推送，<ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步</li><li><code>bug</code>分支只用于在本地修复bug，就没必要推到远程了，除非上级要求</li><li><code>feature</code>分支是否推到远程，取决于你是否和你的项目伙伴<h4 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h4></li></ul></li><li>如果你和你的团队再开发一个项目时，你的一个伙伴推送文件到<code>dev</code>分支上，并且推送到远程上，这个时候如果你也推送(push)<code>dev</code>到远程，这个是时候就会出错，解决办法也是和分支之间的冲突一样处理</li><li><strong>小结：</strong><ul><li>首先，可以试图用git push origin <branch-name>推送自己的修改；</branch-name></li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！</branch-name></li><li>如果git pull提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code><h4 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h4></li></ul></li><li>我们在多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后<code>push</code>的伙伴不得不先<code>pull</code>，在本地合并，然后才能<code>push</code>成功。每次合并再<code>push</code>后，分支变成的很乱</li><li>使用<code>git rebase</code>可以解决这个问题，帮我们把分支整理成一条直线<h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3></li><li>方便我们查找，虽然git有 <code>commit</code>，但是这个东西是一堆进制数，不方便我们查找，所以我们设置标签的形式，方便查找</li><li>在你想要创建标签的分支上,输入<code>git tag &lt;name&gt;</code>添加标签，使用<code>git tag</code>可以查看所有标签给git</li><li>如果之前忘记了添加标签，找到历史的<code>commit id</code>打上就可以，<code>git log --pretty=oneline --abbrev-commit</code></li><li>比方说要对<code>add merge</code>这次提交打标签，它对应的<code>commit id</code>是<code>f52c633</code>，敲入命令：<code>git tag v0.9 f52c633</code></li><li>查看所有的书签：<code>git show &lt;tagname&gt;</code><ul><li>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</li><li>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</li><li>命令<code>git tag</code>可以查看所有标签<h4 id="操作书签"><a href="#操作书签" class="headerlink" title="操作书签"></a>操作书签</h4></li></ul></li><li>修改书签：<code>git tag -d v0.1</code></li><li>将标签推送到远程：<code>git push origin &lt;tagname&gt;</code>或者<code>git push origin --tags</code>一次性将推送未推送的书签</li><li>删除远程的书签：<ul><li>先删除本地的书签：<code>git tag -d v0.9</code></li><li>再从远程删除：<code>git push origin :refs/tags/v0.9</code></li></ul></li><li><strong>总结：</strong><ul><li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li><li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li><li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li><li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签</li><li></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;git是什么？Git(读音为/gɪt/。)是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Git" scheme="https://zhongyuehui.github.io/categories/Git/"/>
    
    
      <category term="git" scheme="https://zhongyuehui.github.io/tags/git/"/>
    
  </entry>
  
</feed>
