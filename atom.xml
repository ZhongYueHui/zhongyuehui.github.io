<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Just for fun</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhongyuehui.github.io/"/>
  <updated>2019-07-08T08:31:27.838Z</updated>
  <id>https://zhongyuehui.github.io/</id>
  
  <author>
    <name>zhong yuehui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TypeScript中的类</title>
    <link href="https://zhongyuehui.github.io/2019/07/08/TypeScript%E4%B8%AD%E7%9A%84%E7%B1%BB/"/>
    <id>https://zhongyuehui.github.io/2019/07/08/TypeScript中的类/</id>
    <published>2019-07-08T08:19:25.000Z</published>
    <updated>2019-07-08T08:31:27.838Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 typescript 中，类的定义与 ES6 稍有写差别，与 java,C++等更加相像了。</p></blockquote><a id="more"></a><h2 id="Typescript-中的类"><a href="#Typescript-中的类" class="headerlink" title="Typescript 中的类"></a>Typescript 中的类</h2><ul><li>在 Typescript 中使用<font color="red"><strong>class</strong></font>关键字定义类</li></ul><h3 id="使用-class-定义类："><a href="#使用-class-定义类：" class="headerlink" title="使用 class 定义类："></a>使用 class 定义类：</h3><pre><code><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> Person &#123;</span><br><span class="line">name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//属性</span></span><br><span class="line">age: <span class="hljs-built_in">number</span>;</span><br><span class="line"><span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;</span><br><span class="line"><span class="hljs-comment">//构造函数 实例化的时候触发的方法,相当于对实例化时传递的参数进行赋值</span></span><br><span class="line"><span class="hljs-keyword">this</span>.name = name;</span><br><span class="line"><span class="hljs-keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">run() &#123;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">"---"</span> + <span class="hljs-keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"张三"</span>, <span class="hljs-number">12</span>);</span><br><span class="line">p.run(); <span class="hljs-comment">//张三</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="修改属性值"><a href="#修改属性值" class="headerlink" title="修改属性值"></a>修改属性值</h3><ul><li>修改类中的属性值</li></ul><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    <span class="hljs-keyword">class</span> Person &#123;</span><br><span class="line">    name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//属性</span></span><br><span class="line">    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    getName(): <span class="hljs-built_in">void</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    setName(name: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"张三"</span>);</span><br><span class="line">    p.getName(); <span class="hljs-comment">//张三</span></span><br><span class="line">    p.setName(<span class="hljs-string">"李四"</span>); <span class="hljs-comment">//修改 name 的值</span></span><br><span class="line">    p.getName(); <span class="hljs-comment">//李四</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-string">``</span><span class="hljs-string">`</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">### 继承</span></span><br><span class="line"><span class="hljs-string">- 继承父类</span></span><br><span class="line"><span class="hljs-string"> `</span><span class="hljs-string">``</span></span><br><span class="line">  <span class="hljs-keyword">class</span> Person &#123;</span><br><span class="line">    name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//属性</span></span><br><span class="line">    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    run() &#123;</span><br><span class="line">      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"张三"</span>);</span><br><span class="line">  <span class="hljs-keyword">class</span> Web <span class="hljs-keyword">extends</span> Person &#123;&#125; <span class="hljs-comment">//如果直接继承，那么就是相当于复制了Person，继承了他的构造函数</span></span><br><span class="line">  <span class="hljs-keyword">var</span> w = <span class="hljs-keyword">new</span> Web(<span class="hljs-string">"李四"</span>);</span><br><span class="line">  w.run(); <span class="hljs-comment">//李四</span></span><br></pre></td></tr></table></figure><ul><li><p>方法的继承</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//属性</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  run(): <span class="hljs-built_in">void</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"张三"</span>);</span><br><span class="line"><span class="hljs-keyword">class</span> Web <span class="hljs-keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>(name); <span class="hljs-comment">//这里表示继承父类的构造器，初始化自己的构造函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  run(): <span class="hljs-built_in">void</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`我是：<span class="hljs-subst">$&#123;this.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> w = <span class="hljs-keyword">new</span> Web(<span class="hljs-string">"李四"</span>);</span><br><span class="line">w.run(); <span class="hljs-comment">//我是李四，当子类和父类都有同一个方法时，子类会调用自己的</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="类的修饰符"><a href="#类的修饰符" class="headerlink" title="类的修饰符"></a>类的修饰符</h3><ul><li>typescript 中定义属性给我们提供了三种修饰符<ul><li><font color="red"><strong>public</strong></font>:表示公有 在类里面、子类、类外面都可以进行访问</li><li><font color="red"><strong>protected</strong></font>：保护类型 在类里面、子类里面可以访问，在类外部没法访问</li><li><font color="red"><strong>private</strong></font>：私有 在类里面可以进行访问，子类、类外部都不能进行访问</li></ul></li><li><font color="red"><strong>注意：</strong></font>属性如果不加修饰符，默认就是公有的(<strong>public</strong>)</li></ul><h4 id="公有属性-public"><a href="#公有属性-public" class="headerlink" title="公有属性(public)"></a>公有属性(public)</h4><ul><li><p>在类外部访问</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Person &#123;</span><br><span class="line">  <span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//公有属性</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"张三"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(p.name); <span class="hljs-comment">//张三</span></span><br></pre></td></tr></table></figure></li><li><p>在类内部和子类内部访问</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Person &#123;</span><br><span class="line">  <span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//公有属性</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  run(): <span class="hljs-built_in">string</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"张三"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(p.run()); <span class="hljs-comment">//张三</span></span><br><span class="line"><span class="hljs-keyword">class</span> Web <span class="hljs-keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  work(): <span class="hljs-built_in">string</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;this.name&#125;</span>在工作`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> w = <span class="hljs-keyword">new</span> Web(<span class="hljs-string">"李四"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(w.work()); <span class="hljs-comment">//李四在工作</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="保护属性-protected"><a href="#保护属性-protected" class="headerlink" title="保护属性(protected)"></a>保护属性(protected)</h4><ul><li><p>在类内部和子类内部访问</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Person &#123;</span><br><span class="line">  <span class="hljs-keyword">protected</span> name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//保护类型</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  run(): <span class="hljs-built_in">string</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;this.name&#125;</span>在上班`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"张三"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(p.run()); <span class="hljs-comment">//张三在上班</span></span><br><span class="line"><span class="hljs-keyword">class</span> Web <span class="hljs-keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  work() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;this.name&#125;</span>在工作`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> w = <span class="hljs-keyword">new</span> Web(<span class="hljs-string">"李四"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(w.work()); <span class="hljs-comment">//李四在工作</span></span><br></pre></td></tr></table></figure></li><li><p>在类外部访问和子类外部访问</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Person &#123;</span><br><span class="line">  <span class="hljs-keyword">protected</span> name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//保护类型</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  run(): <span class="hljs-built_in">string</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;this.name&#125;</span>在上班`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"张三"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(p.name); <span class="hljs-comment">//报错，name受保护</span></span><br><span class="line"><span class="hljs-keyword">class</span> Web <span class="hljs-keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  work() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;this.name&#125;</span>在工作`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> w = <span class="hljs-keyword">new</span> Web(<span class="hljs-string">"李四"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(w.name); <span class="hljs-comment">//报错，name受保护</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="私有类型-private"><a href="#私有类型-private" class="headerlink" title="私有类型(private)"></a>私有类型(private)</h3><ul><li><p>在类外部访问</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Person &#123;</span><br><span class="line">  <span class="hljs-keyword">private</span> name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//公有属性</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  run(): <span class="hljs-built_in">string</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"张三"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(p.name); <span class="hljs-comment">//报错，私有属性只能在内部中访问</span></span><br></pre></td></tr></table></figure></li><li><p>在子类内部和外部访问</p><figure class="highlight scala hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">private</span> name: string; <span class="hljs-comment">//公有属性</span></span><br><span class="line">  constructor(name: string) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  run(): string &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(<span class="hljs-string">"张三"</span>);</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Web</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;</span><br><span class="line">  constructor(name: string) &#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  work(): string &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> `$&#123;<span class="hljs-keyword">this</span>.name&#125;在工作`; <span class="hljs-comment">//在这里就报错了，只能在Person内部中访问，所以外部没有试验的必要了</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> w = <span class="hljs-keyword">new</span> <span class="hljs-type">Web</span>(<span class="hljs-string">"李四"</span>);</span><br></pre></td></tr></table></figure></li><li><p>在类内部访问</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Person &#123;</span><br><span class="line">  <span class="hljs-keyword">private</span> name: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//公有属性</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  run(): <span class="hljs-built_in">string</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"张三"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(p.run()); <span class="hljs-comment">//张三</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a><font color="red" size="+2">总结:</font></h4><ul><li>在类的定义中： + 公有的类里面，在当前类里面、子类、类外面都可以访问 + 在保护类里面，在当前类、子类里面都可以访问，在类外面不能访问 + 在私有类里面，在当前类里面可以访问，在子类，类外面都不能进行访问<blockquote><p>一上就是在 TypeScript 中的类的相关知识。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 typescript 中，类的定义与 ES6 稍有写差别，与 java,C++等更加相像了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="https://zhongyuehui.github.io/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://zhongyuehui.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript中的函数</title>
    <link href="https://zhongyuehui.github.io/2019/07/08/TypeScript%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"/>
    <id>https://zhongyuehui.github.io/2019/07/08/TypeScript中的函数/</id>
    <published>2019-07-08T02:40:48.000Z</published>
    <updated>2019-07-08T02:42:47.190Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>函数在 Javascript 中是一等一的公民。</p></blockquote><a id="more"></a><h1 id="Typescript-中的函数"><a href="#Typescript-中的函数" class="headerlink" title="Typescript 中的函数"></a>Typescript 中的函数</h1><h2 id="TypeScript-中定义函数"><a href="#TypeScript-中定义函数" class="headerlink" title="TypeScript 中定义函数"></a>TypeScript 中定义函数</h2><h3 id="ES5-中定义函数的方式"><a href="#ES5-中定义函数的方式" class="headerlink" title="ES5 中定义函数的方式"></a>ES5 中定义函数的方式</h3><ul><li><figure class="highlight dust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-xml"><span class="hljs-comment">&lt;!--函数声明--&gt;</span></span></span><br><span class="line"><span class="hljs-xml">function getinfo() </span><span class="hljs-template-variable">&#123;</span></span><br><span class="line"><span class="hljs-template-variable">return 'hello-world'</span></span><br><span class="line"><span class="hljs-template-variable">&#125;</span><span class="hljs-xml"></span></span><br></pre></td></tr></table></figure><figure class="highlight dust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-xml"><span class="hljs-comment">&lt;!--匿名函数--&gt;</span></span></span><br><span class="line"><span class="hljs-xml">var getinfo = function () </span><span class="hljs-template-variable">&#123;</span></span><br><span class="line"><span class="hljs-template-variable">return 'hello-world'</span></span><br><span class="line"><span class="hljs-template-variable">&#125;</span><span class="hljs-xml"></span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="ts-中的定义函数的方式"><a href="#ts-中的定义函数的方式" class="headerlink" title="ts 中的定义函数的方式"></a>ts 中的定义函数的方式</h3><ul><li><p>使用函数声明的方式，只定义函数的返回值类型</p><figure class="highlight lua hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span><span class="hljs-params">()</span></span>:<span class="hljs-built_in">string</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">'This is getinfo'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">getinfo</span>()</span><br></pre></td></tr></table></figure></li><li><p>注意：这样定义函数时，返回值的数据类型必须是 string,否则会报错</p></li><li><p>函数表达式的方式定义函数(匿名函数)</p><figure class="highlight lua hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var <span class="hljs-built_in">getinfo</span>=<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>:<span class="hljs-built_in">string</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">'This is getinfo'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">getinfo</span>()</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="ts-中传递参数"><a href="#ts-中传递参数" class="headerlink" title="ts 中传递参数"></a>ts 中传递参数</h3><ul><li><p>使用函数声明定义函数，需要定义参数的类型和函数的返回值类型，且形参和实参类型与数据一一对应</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">name:<span class="hljs-built_in">string</span>,age:<span class="hljs-built_in">number</span></span>):<span class="hljs-title">string</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>----<span class="hljs-subst">$&#123;age&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">let</span> value = getinfo(<span class="hljs-string">'张三'</span>,<span class="hljs-number">12</span>)</span><br><span class="line"><span class="hljs-built_in">console</span>.log(value);</span><br></pre></td></tr></table></figure></li><li><p>使用函数表达式(匿名函数)定义函数，传递参数，规则与使用函声明定义函数一样</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> getinfo= <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name:<span class="hljs-built_in">string</span>,age:<span class="hljs-built_in">number</span></span>):<span class="hljs-title">string</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>----<span class="hljs-subst">$&#123;age&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">let</span> value = getinfo(<span class="hljs-string">'张三'</span>,<span class="hljs-number">40</span>)</span><br><span class="line"><span class="hljs-built_in">console</span>.log(value);</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="定义没有返回值的方法"><a href="#定义没有返回值的方法" class="headerlink" title="定义没有返回值的方法"></a>定义没有返回值的方法</h3><ul><li><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">name:<span class="hljs-built_in">string</span>,age:<span class="hljs-built_in">number</span></span>):<span class="hljs-title">void</span> </span>&#123;</span><br><span class="line">   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>----<span class="hljs-subst">$&#123;age&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">getinfo(<span class="hljs-string">'张三'</span>,<span class="hljs-number">30</span>)</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="定义可选参数"><a href="#定义可选参数" class="headerlink" title="定义可选参数"></a>定义可选参数</h3><ul><li><p>在 ES5 中，我们如果定义普通的形参时，形参个数和实参个数可以不一致，但是在 ts 中，不允许这样做</p><figure class="highlight delphi hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span><span class="hljs-params">(<span class="hljs-keyword">name</span>:<span class="hljs-keyword">string</span>,age:number)</span>:</span>void <span class="hljs-comment">&#123;</span></span><br><span class="line"><span class="hljs-comment">console.log(`$&#123;name&#125;</span>----年龄保密);</span><br><span class="line">&#125;  <span class="hljs-comment">//这里提示报错了，没有将模板字符串写完</span></span><br><span class="line">getinfo(<span class="hljs-string">'张三'</span>)</span><br></pre></td></tr></table></figure></li><li><p>所以我们可以看到，如果写了形参，没有传递实参，就会编译错误,但是有时候我们并不传递，但是可以先定义预留位置</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">name:<span class="hljs-built_in">string</span>,age?:<span class="hljs-built_in">number</span></span>):<span class="hljs-title">void</span> </span>&#123;</span><br><span class="line">   age? <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>----<span class="hljs-subst">$&#123;age&#125;</span>`</span>): <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>---年龄保密`</span>)</span><br><span class="line">&#125;</span><br><span class="line">getinfo(<span class="hljs-string">'张三'</span>,<span class="hljs-number">12</span>)</span><br></pre></td></tr></table></figure></li><li><p>在形参名后面加上 <code>?</code> 表示对实参进行判断，如果有就使用，没有就不使用</p></li></ul><h3 id="定义默认参数"><a href="#定义默认参数" class="headerlink" title="定义默认参数"></a>定义默认参数</h3><ul><li><p>定义默认参数我们也可以不传递定义了默认值的参数</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">name:<span class="hljs-built_in">string</span>,age:<span class="hljs-built_in">number</span>=12</span>):<span class="hljs-title">void</span> </span>&#123;</span><br><span class="line">age? <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>----<span class="hljs-subst">$&#123;age&#125;</span>`</span>): <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>---年龄保密`</span>)</span><br><span class="line">&#125;</span><br><span class="line">getinfo(<span class="hljs-string">'张三'</span>)  <span class="hljs-comment">//输出 张三 12</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">name:<span class="hljs-built_in">string</span>,age:<span class="hljs-built_in">number</span>=12</span>):<span class="hljs-title">void</span> </span>&#123;</span><br><span class="line">age? <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>----<span class="hljs-subst">$&#123;age&#125;</span>`</span>): <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>---年龄保密`</span>)</span><br><span class="line">&#125;</span><br><span class="line">getinfo(<span class="hljs-string">'张三'</span>,<span class="hljs-number">45</span>) <span class="hljs-comment">//输出 张三 45</span></span><br></pre></td></tr></table></figure></li><li><p>总结：</p><ul><li>如果我们在形参中定义了默认的值的时候，你调用函数时可以不传递这个设有默认值的参数，他会使用默认值输出</li><li>如果我们在形参中定义了默认的值的时候，你调用函数时传递这个设有默认值的参数，他会使用你传递的值作为输出</li></ul></li></ul><hr><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><ul><li><p>当我们想要计算多个参数的值时，如下定义每一个参数会显得非常麻烦，所以我们需要换一种方式来解决这个累赘的定义</p><figure class="highlight fortran hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span></span> <span class="hljs-built_in">sum</span>(a:<span class="hljs-keyword">number</span>,b:<span class="hljs-keyword">number</span>,c:<span class="hljs-keyword">number</span>,d:<span class="hljs-keyword">number</span>):<span class="hljs-keyword">number</span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> a+b+c+d</span><br><span class="line">&#125;</span><br><span class="line">var sun  = <span class="hljs-built_in">sum</span>(<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">12</span>,<span class="hljs-number">14</span>)</span><br><span class="line">console.<span class="hljs-built_in">log</span>(sun);</span><br></pre></td></tr></table></figure></li><li><p>使用 ES6 中的三点运算符</p><figure class="highlight actionscript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span><span class="hljs-params">(a:number,b:number,<span class="hljs-rest_arg">...result</span>:number[])</span>:number</span>&#123;</span><br><span class="line"><span class="hljs-keyword">var</span> sum =a+b</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; result.length; i++) &#123;</span><br><span class="line">        sum+=result[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> add = sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span><br><span class="line">console.log(add);</span><br></pre></td></tr></table></figure></li><li><p>这样就不会有太多的重复代码</p></li></ul><hr><h3 id="ts-函数重载"><a href="#ts-函数重载" class="headerlink" title="ts 函数重载"></a>ts 函数重载</h3><ul><li><p>拓展：</p><ul><li>java 中方法的重载：重载指的是两个或者两个以上同名函数，但是它们的参数不一样，这时候会出现重载的情况</li><li>typescript 中的重载：通过为同一个函数提供多个函数类型定义来实现多种功能的目的</li><li>ts 中为了兼容 ES5 以及 ES6，重载的写法与 Java 有所区别</li></ul><figure class="highlight dust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-xml"><span class="hljs-comment">&lt;!--在ES5中，如果出现了同名的方法，下面的会替换掉上面的--&gt;</span></span></span><br><span class="line"><span class="hljs-xml">function a() </span><span class="hljs-template-variable">&#123;</span></span><br><span class="line"><span class="hljs-template-variable">console.log('a')</span></span><br><span class="line"><span class="hljs-template-variable">&#125;</span><span class="hljs-xml"></span></span><br><span class="line"><span class="hljs-xml"></span></span><br><span class="line"><span class="hljs-xml">function a() </span><span class="hljs-template-variable">&#123;</span></span><br><span class="line"><span class="hljs-template-variable">    console.log('b')</span></span><br><span class="line"><span class="hljs-template-variable">&#125;</span><span class="hljs-xml"></span></span><br><span class="line"><span class="hljs-xml">a()  //输出 b</span></span><br></pre></td></tr></table></figure></li><li><p>示例 1：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">age:number</span>):<span class="hljs-title">number</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-title">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">name:string</span>):<span class="hljs-title">string</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-title">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">str:any</span>):<span class="hljs-title">any</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> str ===<span class="hljs-string">'string'</span>)&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">`我是:<span class="hljs-subst">$&#123;str&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">`我今年 <span class="hljs-subst">$&#123;str&#125;</span>岁`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(getinfo(<span class="hljs-string">'张三'</span>)) <span class="hljs-comment">//我是张三</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">age:number</span>):<span class="hljs-title">number</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-title">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">name:string</span>):<span class="hljs-title">string</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-title">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">str:any</span>):<span class="hljs-title">any</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> str ===<span class="hljs-string">'string'</span>)&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">`我是:<span class="hljs-subst">$&#123;str&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">`我今年 <span class="hljs-subst">$&#123;str&#125;</span>岁`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(getinfo(<span class="hljs-number">18</span>)) <span class="hljs-comment">//我今年18岁</span></span><br></pre></td></tr></table></figure></li><li><p>示例 1 中，前面两个函数才是作为运行的方法，最后这个函数是判断调用哪个函数，判断的依据就是你传入的参数的数据类型和哪个方法中的形参的数据类型一致，那么他就调用哪个，如果传入的实参数据类型没有定义则报错</p></li><li><p>示例 2:</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">string</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getinfo</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age?: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">any</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (age) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">`我叫<span class="hljs-subst">$&#123;name&#125;</span>，我今年：<span class="hljs-subst">$&#123;age&#125;</span>岁`</span>;</span><br><span class="line">  &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">`我叫:<span class="hljs-subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(getinfo(<span class="hljs-string">"张三"</span>)) <span class="hljs-comment">//张三</span></span><br><span class="line"><span class="hljs-comment">// getinfo(12) //报错，因为name是string ，只能在第二个参数传入number型数据</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(getinfo(<span class="hljs-string">"张三"</span>, <span class="hljs-number">12</span>)); <span class="hljs-comment">//我叫张三，我今年12岁</span></span><br></pre></td></tr></table></figure></li><li><p>示例 2 中，我们定义了一个可选参数，当我们只有一个参数时他就调用第一个方法，如果有两个参数时，调用第二个方法</p></li></ul><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ul><li>在 ES6 中，箭头函数的 this 指向的是上下文,但是在 ts 编译中采用的是严格模式，严格模式中禁止函数中的 this 指向 window<br><code>setTimeout(() =&gt; { console.log(&quot;run&quot;); }, 3000)</code><blockquote><p>以上就是我在学习中总结的一些关于函数的相关知识。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;函数在 Javascript 中是一等一的公民。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="https://zhongyuehui.github.io/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://zhongyuehui.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript中的数据类型</title>
    <link href="https://zhongyuehui.github.io/2019/07/07/TypeScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://zhongyuehui.github.io/2019/07/07/TypeScript中的数据类型/</id>
    <published>2019-07-07T14:03:04.000Z</published>
    <updated>2019-07-07T23:37:43.994Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。这里主要介绍前五种原始数据类型和一些其他的TypeScript的数据类型。</p></blockquote><a id="more"></a><h1 id="Typescript中的数据类型"><a href="#Typescript中的数据类型" class="headerlink" title="Typescript中的数据类型"></a>Typescript中的数据类型</h1><h2 id="布尔类型-boolean"><a href="#布尔类型-boolean" class="headerlink" title="布尔类型(boolean)"></a>布尔类型(boolean)</h2><pre><code><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">&lt;!--在ES5中--&gt;</span></span><br><span class="line">var flag= true</span><br><span class="line">    flag=123</span><br><span class="line">    console.log(flag) //123</span><br></pre></td></tr></table></figure><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">&lt;!--在Typescript中--&gt;</span></span><br><span class="line">var flag= true</span><br><span class="line">    flag=123    //在这里时，编译器已经报错了</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">&lt;!--正确的写法--&gt;</span></span><br><span class="line">var flag:boolean= true</span><br><span class="line">    flag=false</span><br><span class="line">    console.log(flag) //false</span><br></pre></td></tr></table></figure></code></pre><hr><h2 id="数字类型-number"><a href="#数字类型-number" class="headerlink" title="数字类型(number)"></a>数字类型(number)</h2><ul><li>  <figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">&lt;!--在ES5中--&gt;</span></span><br><span class="line">var num=123</span><br><span class="line">    num='aa'</span><br><span class="line">    console.log(num) //aa</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">&lt;!--在typesctipt--&gt;</span></span><br><span class="line">var num:number=123</span><br><span class="line">    num='str'// 编译器报错</span><br><span class="line">    </span><br><span class="line"><span class="hljs-comment">&lt;!--正确的写法--&gt;</span></span><br><span class="line">var num:number = 123</span><br><span class="line">    num=456</span><br><span class="line">    console/log(num) //num</span><br></pre></td></tr></table></figure></li><li><p>根据前两个我们已经可以看的出来.只要规定了该变量是什么类型或者是第一个赋值该变量的数据是什么类型的,这个变量就是什么类型的数据,并且赋值只能赋值相同的类型数据,否则直接报错</p><h2 id="字符串类型-string"><a href="#字符串类型-string" class="headerlink" title="字符串类型(string)"></a>字符串类型(string)</h2></li><li>  <figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">&lt;!--在typescript中--&gt;</span></span><br><span class="line">let str:string = 'string'</span><br><span class="line">    str = 'hello'</span><br><span class="line">    console.log(str) //hello</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="数组类型-array"><a href="#数组类型-array" class="headerlink" title="数组类型(array)"></a>数组类型(array)</h2><h3 id="定义方式一"><a href="#定义方式一" class="headerlink" title="定义方式一:"></a>定义方式一:</h3><ul><li>在变量名后面跟上数组的类型  <figure class="highlight makefile hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let arr:number[]= [12,11]</span><br><span class="line"></span><br><span class="line">arr=[<span class="hljs-string">"123"</span>,123] //这样就报错了</span><br><span class="line">arr=[123,456] //这样是正确的</span><br></pre></td></tr></table></figure></li></ul><h3 id="定义方式二"><a href="#定义方式二" class="headerlink" title="定义方式二:"></a>定义方式二:</h3><ul><li>在变量名定义数组的时候在<code>&lt;&gt;</code>中定义数组的类型  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> arr:<span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt;=[<span class="hljs-number">12</span>,<span class="hljs-number">123</span>]</span><br><span class="line"><span class="hljs-built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure></li></ul><h3 id="定义方式三"><a href="#定义方式三" class="headerlink" title="定义方式三:"></a>定义方式三:</h3><ul><li>在下面有<code>any</code>类型的讲解  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> arr:<span class="hljs-built_in">any</span>[]=[<span class="hljs-string">'123'</span>,<span class="hljs-number">456</span>,<span class="hljs-literal">false</span>]</span><br><span class="line"><span class="hljs-built_in">console</span>.log(arr)  <span class="hljs-comment">//输出: [ '123', 456, false ]</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="元祖类型-tuple"><a href="#元祖类型-tuple" class="headerlink" title="元祖类型(tuple)"></a>元祖类型(tuple)</h2><ul><li>属于数组中的一种,可以定义多种数据类型,但是必须一一对应  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> arr:[<span class="hljs-built_in">number</span>,<span class="hljs-built_in">string</span>]=[<span class="hljs-number">123</span>,<span class="hljs-string">"123"</span>]</span><br><span class="line">arr=[<span class="hljs-string">"123"</span>,<span class="hljs-number">123</span>] <span class="hljs-comment">//这样是错误的,值必须与数据类型一一对应</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="枚举类型-enum"><a href="#枚举类型-enum" class="headerlink" title="枚举类型(enum)"></a>枚举类型(enum)</h2><ul><li>  <figure class="highlight crystal hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Flag</span>&#123;</span></span><br><span class="line">    success=<span class="hljs-number">200</span>,</span><br><span class="line">    error=<span class="hljs-number">500</span></span><br><span class="line">&#125;</span><br><span class="line">let <span class="hljs-symbol">s:</span>Flag=Flag.success</span><br><span class="line">console.log(s)  /<span class="hljs-regexp">/输出:200 如果赋值了那么打印的就是你赋值的数字</span></span><br></pre></td></tr></table></figure>  <figure class="highlight crystal hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Flag</span>&#123;</span></span><br><span class="line">    success=<span class="hljs-number">1</span>,</span><br><span class="line">    error=<span class="hljs-number">2</span></span><br><span class="line">&#125;</span><br><span class="line">let <span class="hljs-symbol">s:</span>Flag=Flag.success</span><br><span class="line">console.log(s) /<span class="hljs-regexp">/输出:0 如果没有赋值那么输出的结果就是对应的下标,从  0 开始</span></span><br></pre></td></tr></table></figure>  <figure class="highlight crystal hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Flag</span>&#123;</span></span><br><span class="line">    success,</span><br><span class="line">    <span class="hljs-string">'error'</span>=<span class="hljs-number">3</span>,</span><br><span class="line">    number</span><br><span class="line">&#125;</span><br><span class="line">let <span class="hljs-symbol">s:</span>Flag=Flag.number</span><br><span class="line">console.log(s)  /<span class="hljs-regexp">/输出: 4,相当于前面的error=3赋值的是数组的下标,后面的值没有定义的话就是默认前面的下标+1</span></span><br></pre></td></tr></table></figure></li><li><p>为了详细一点,我们在看一下这个代码就清楚了</p>  <figure class="highlight sqf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="hljs-built_in">Flag</span>&#123;</span><br><span class="line">    <span class="hljs-string">'success'</span>=-<span class="hljs-number">1</span>,</span><br><span class="line">    <span class="hljs-string">'error'</span>=<span class="hljs-number">999</span>,</span><br><span class="line">    number</span><br><span class="line">&#125;</span><br><span class="line">let s:<span class="hljs-built_in">Flag</span>=<span class="hljs-built_in">Flag</span>.number</span><br><span class="line">console.<span class="hljs-built_in">log</span>(s) <span class="hljs-comment">//输出 1000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enum <span class="hljs-built_in">Flag</span>&#123;</span><br><span class="line">    <span class="hljs-string">'success'</span>=-<span class="hljs-number">10</span>,</span><br><span class="line">    <span class="hljs-string">'error'</span>=-<span class="hljs-number">15</span>,</span><br><span class="line">    number</span><br><span class="line">&#125;</span><br><span class="line">let s:<span class="hljs-built_in">Flag</span>=<span class="hljs-built_in">Flag</span>.number</span><br><span class="line">console.<span class="hljs-built_in">log</span>(s)  <span class="hljs-comment">//输出 -14</span></span><br></pre></td></tr></table></figure></li><li><p>注意:</p><ul><li>在这个Flag中定义的名称可以加 <strong>‘ ‘</strong>,也可以不加 <strong>‘ ‘</strong>,但是值一定不能加<strong>‘ ‘</strong>,并且只能是数字,否则报错</li></ul></li></ul><hr><h2 id="任意类型-any"><a href="#任意类型-any" class="headerlink" title="任意类型(any)"></a>任意类型(any)</h2><pre><code><figure class="highlight livecodeserver hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let <span class="hljs-built_in">num</span>:<span class="hljs-keyword">any</span>[]=[<span class="hljs-string">'123'</span>,<span class="hljs-number">123</span>]</span><br><span class="line"><span class="hljs-built_in">num</span>=[<span class="hljs-string">'a'</span>,<span class="hljs-number">45</span>]</span><br><span class="line">console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">num</span>);<span class="hljs-comment"> // 输出: ['a',45]</span></span><br></pre></td></tr></table></figure></code></pre><ul><li><p><code>any</code>可以是任意的类型,但是我们在平时定义数据时不要随意使用<code>any</code>,不然其他的数据类型设计就没有意义了</p></li><li><p><code>any</code>的正确用法:</p>  <figure class="highlight stylus hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let app = document.getElementById(<span class="hljs-string">'app'</span>)</span><br><span class="line">app<span class="hljs-selector-class">.style</span><span class="hljs-selector-class">.color</span>= <span class="hljs-string">'red'</span> <span class="hljs-comment">//报错了,对象可能为空</span></span><br></pre></td></tr></table></figure></li><li><p>在Typescript中,并没有Object类型,所以无论定义什么具体类型,都会报错,这个时候我们就需要加入<code>any</code></p>  <figure class="highlight stylus hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let app:any = document.getElementById(<span class="hljs-string">'app'</span>)</span><br><span class="line">app<span class="hljs-selector-class">.style</span><span class="hljs-selector-class">.color</span>= <span class="hljs-string">'red'</span></span><br></pre></td></tr></table></figure></li><li><p>这样我们就完美的解决了这个错误</p></li></ul><hr><h2 id="null和undefined-其他数据类型的子类型"><a href="#null和undefined-其他数据类型的子类型" class="headerlink" title="null和undefined 其他数据类型的子类型"></a>null和undefined 其他数据类型的子类型</h2><ul><li><p>示例:</p>  <figure class="highlight livecodeserver hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let <span class="hljs-built_in">num</span>:<span class="hljs-built_in">number</span></span><br><span class="line">console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">num</span>)<span class="hljs-comment"> //报错,在赋值前使用了num</span></span><br></pre></td></tr></table></figure></li><li><p>这说明number类型的数据在赋值前都不能使用</p>  <figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> num:<span class="hljs-literal">undefined</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(num)  <span class="hljs-comment">//输出: undedined</span></span><br></pre></td></tr></table></figure></li><li><p>有时候我们不管这个存不存在,存在的话就是number类型,不存在就是undefined类型</p><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3>  <figure class="highlight livecodeserver hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var  <span class="hljs-built_in">num</span>:undefined | <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span></span><br><span class="line"><span class="hljs-built_in">num</span>=<span class="hljs-number">123</span></span><br><span class="line">console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">num</span>)<span class="hljs-comment"> //输出 123 并且不报错</span></span><br></pre></td></tr></table></figure>  <figure class="highlight livecodeserver hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var  <span class="hljs-built_in">num</span>:undefined | <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span></span><br><span class="line">console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">num</span>)<span class="hljs-comment"> //输出:undefined ,就算是没有赋值也不会报错</span></span><br></pre></td></tr></table></figure>  <figure class="highlight livecodeserver hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var  <span class="hljs-built_in">num</span>:undefined | <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span></span><br><span class="line"><span class="hljs-built_in">num</span>=<span class="hljs-literal">null</span></span><br><span class="line">console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">num</span>)<span class="hljs-comment"> //输出 null</span></span><br></pre></td></tr></table></figure></li><li><p>这样就相当于有值就是number类型,没有值就是undefined,赋值为null就是null,因为undefined只能赋值为undefined,null只能赋值为null</p></li></ul><hr><h2 id="viod-类型"><a href="#viod-类型" class="headerlink" title="viod 类型"></a>viod 类型</h2><ul><li><p>在typescript中,viod类型表示没有任何类型,一般定义没有返回值的方法</p></li><li><p>示例:</p>  <figure class="highlight dust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-xml"><span class="hljs-comment">&lt;!--在ES5中--&gt;</span></span></span><br><span class="line"><span class="hljs-xml">function run():void</span><span class="hljs-template-variable">&#123;</span></span><br><span class="line"><span class="hljs-template-variable">    console.log('hello world')</span></span><br><span class="line"><span class="hljs-template-variable">&#125;</span><span class="hljs-xml"></span></span><br><span class="line"><span class="hljs-xml">run()  //正常输出</span></span><br></pre></td></tr></table></figure>  <figure class="highlight actionscript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>:undefined</span>&#123;</span><br><span class="line">    console.log(<span class="hljs-string">'aaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line">run() <span class="hljs-comment">//报错,声明类型如果不是 viod 或者 any ,必须要有返回值</span></span><br></pre></td></tr></table></figure>  <figure class="highlight actionscript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>:undefined</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">run() <span class="hljs-comment">//报错,不能返回数据类型不同的数据</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="never类型"><a href="#never类型" class="headerlink" title="never类型"></a>never类型</h2><ul><li><p>never类型其他类型(包括了null,undefined)的子类型,代表从来不会出现的值,怎么理解呢?</p>  <figure class="highlight stylus hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let <span class="hljs-selector-tag">a</span>:never</span><br><span class="line">a=<span class="hljs-number">123</span> <span class="hljs-comment">//报错</span></span><br><span class="line"></span><br><span class="line">let <span class="hljs-selector-tag">b</span>:never</span><br><span class="line">b=null <span class="hljs-comment">//报错</span></span><br></pre></td></tr></table></figure></li><li><p>这就说明了它不能是任意我们可以有的值,必须是没有的数据类型</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> err:never</span><br><span class="line">err= <span class="hljs-function">(<span class="hljs-params">(<span class="hljs-params"></span>)=&gt;&#123;</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-params">'error'</span>)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">&#125;</span>)<span class="hljs-params">()</span></span></span><br></pre></td></tr></table></figure></li><li><p>当我们使用never定义自执行函数抛出错误时,那么就可以使用never了,但是使用场景并不是很多,很多时候我们使用<code>any</code>来代替</p></li></ul><hr><h2 id="总结的一些问题"><a href="#总结的一些问题" class="headerlink" title="总结的一些问题:"></a>总结的一些问题:</h2><ul><li><p>类型的推断</p>  <figure class="highlight dart hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let <span class="hljs-built_in">num</span>;</span><br><span class="line"><span class="hljs-built_in">num</span>=<span class="hljs-string">'45'</span>,</span><br><span class="line"><span class="hljs-built_in">num</span>=<span class="hljs-number">123</span></span><br><span class="line">console.log(<span class="hljs-built_in">num</span>) <span class="hljs-comment">//123</span></span><br></pre></td></tr></table></figure></li><li><p>我们可以推断,如果一开始没有给变量赋值,那么我们推断它默认就是 <code>any</code> 类型,可以赋任意值,和变量没有指定数据类型赋值一样,我们推断它是使用第一个赋值的数据类型作为该变量数据类型</p></li><li><p>在viod类型中,函数如果没有返回值那么使用 viod定义,如果有返回值,那么返回数据类型必须和定义函数的数据类型保持一致</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。这里主要介绍前五种原始数据类型和一些其他的TypeScript的数据类型。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="https://zhongyuehui.github.io/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://zhongyuehui.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Node中的path路径模块</title>
    <link href="https://zhongyuehui.github.io/2019/07/07/Node%E4%B8%AD%E7%9A%84path%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97/"/>
    <id>https://zhongyuehui.github.io/2019/07/07/Node中的path路径模块/</id>
    <published>2019-07-07T05:36:24.000Z</published>
    <updated>2019-07-07T06:19:22.864Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在Node中，有许多的模块,但是Node.js path 模块提供了一些用于处理文件路径的小工具</p></blockquote><a id="more"></a><h2 id="Path模块"><a href="#Path模块" class="headerlink" title="Path模块"></a>Path模块</h2><ul><li><p>引入<br>  <code>const path = require(&#39;path&#39;)</code></p><h3 id="path的一些方法"><a href="#path的一些方法" class="headerlink" title="path的一些方法"></a>path的一些方法</h3><h3 id="path-basename"><a href="#path-basename" class="headerlink" title="path.basename():"></a>path.basename():</h3></li><li><p>只有一个参数时<br><img src="https://s2.ax1x.com/2019/07/07/ZBYSYV.png" alt="path.basename"></p></li><li><p>有两个参数时，且参数的后缀名相同时<br><img src="https://s2.ax1x.com/2019/07/07/ZBYCSU.png" alt="path.basename2"></p></li><li><p>有两个参数时，且参数的后缀名不相同时<br><img src="https://s2.ax1x.com/2019/07/07/ZBYiy4.png" alt="path.basename3"></p></li><li><p><strong>总结</strong>：</p><ul><li>一个参数时直接输出带后缀名的文件名</li><li>两个参数时第二个参数为第一个参数的后缀名时输出为不带后缀名的文件名</li><li>两个参数时第二个参数不是第一个参数的后缀名时输出仍是带后缀名的文件名<h3 id="path-dirname"><a href="#path-dirname" class="headerlink" title="path.dirname()"></a>path.dirname()</h3><img src="https://s2.ax1x.com/2019/07/07/ZBJjwn.png" alt="path.dirname"></li></ul></li><li><p>只输出目录</p><h3 id="path-extname"><a href="#path-extname" class="headerlink" title="path.extname()"></a>path.extname()</h3><p><img src="https://s2.ax1x.com/2019/07/07/ZBYFOJ.png" alt="pathextname"></p></li><li><p>只输出后缀名</p><h3 id="path-isAbsolute"><a href="#path-isAbsolute" class="headerlink" title="path.isAbsolute()"></a>path.isAbsolute()</h3><p><img src="https://s2.ax1x.com/2019/07/07/ZBYEwR.png" alt="path.isAbsolute"></p></li><li><p>判断是否为绝对路径，返回一个布尔值</p></li><li><p><strong>注意：</strong>文件路径前不能有空格 否则直接返回<code>flase</code></p></li><li><p>拓展：绝对路径的两种方式</p><ul><li>如：c:/a/b/c/index.js ，有磁盘符，相对于磁盘符的绝对路径</li><li>如：/a/b/c/index.js ，没有磁盘符，相对于当前磁盘下的绝对路径<h3 id="path-parse"><a href="#path-parse" class="headerlink" title="path.parse()"></a>path.parse()</h3><img src="https://s2.ax1x.com/2019/07/07/ZBYnfK.png" alt="parse"></li></ul></li><li><p>查看文件的详细信息</p><h3 id="path-join"><a href="#path-join" class="headerlink" title="path.join()"></a>path.join()</h3><p><img src="https://s2.ax1x.com/2019/07/07/ZBYMlD.png" alt="path.join"></p></li><li><p>路径拼接 </p><blockquote><p>在Node中，许多时候我们都需要用到路径模块，对文件路径的判断做出相应的响应</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在Node中，有许多的模块,但是Node.js path 模块提供了一些用于处理文件路径的小工具&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Nodejs" scheme="https://zhongyuehui.github.io/categories/Nodejs/"/>
    
    
      <category term="nodejs" scheme="https://zhongyuehui.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Vuex的使用</title>
    <link href="https://zhongyuehui.github.io/2019/07/05/Vuex%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://zhongyuehui.github.io/2019/07/05/Vuex的使用/</id>
    <published>2019-07-05T14:02:22.000Z</published>
    <updated>2019-07-07T05:39:48.355Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>vuex是什么？Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p></blockquote><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>我们在进行一些复杂的父子组件之间的传值的时候，尤其是组件嵌套传值时尤其麻烦，读取值不方便，如果有异步操作，还需要对值监听，这样获取一些值得时候对我们开发人员不友好，所以诞生了Vuex</p></blockquote><h1 id="Vuex的使用"><a href="#Vuex的使用" class="headerlink" title="Vuex的使用"></a>Vuex的使用</h1><h2 id="vuex的安装配置"><a href="#vuex的安装配置" class="headerlink" title="vuex的安装配置"></a>vuex的安装配置</h2><ul><li><p>安装:<code>npm install vuex -S</code></p></li><li><p>如果使用<code>&lt;script&gt;&lt;/script&gt;</code>标签引入的<code>vue</code>，那么自己会安装有<code>vuex</code></p></li><li><p>安装插件：</p>  <figure class="highlight clean hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span></span><br><span class="line"><span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure></li><li><p>配置:</p>  <figure class="highlight pf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  <span class="hljs-keyword">state</span>: &#123;  //这个就是相当于 vue中的 data，用来存放数据的</span><br><span class="line">    count: <span class="hljs-number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;  //这个相当于 vue 中的 methods ，存放了些方法</span><br><span class="line">    increment (<span class="hljs-keyword">state</span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">state</span>.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>使用:实现一个小案例，官方也是这个案例来说明的：</p></li><li><p><code>main.js</code></p>  <figure class="highlight pf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 入口文件</span><br><span class="line">import Vue <span class="hljs-keyword">from</span> 'vue'</span><br><span class="line">// 配置vuex的步骤</span><br><span class="line">// <span class="hljs-number">1</span>. 运行 cnpm i vuex -S </span><br><span class="line">// <span class="hljs-number">2</span>. 导入包</span><br><span class="line">import Vuex <span class="hljs-keyword">from</span> 'vuex'</span><br><span class="line">// <span class="hljs-number">3</span>. 注册vuex到vue中</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line">    // <span class="hljs-number">4</span>. new Vuex.Store() 实例，得到一个 数据仓储对象</span><br><span class="line">var store = new Vuex.Store(&#123;</span><br><span class="line">    <span class="hljs-keyword">state</span>: &#123;</span><br><span class="line">        // 大家可以把 <span class="hljs-keyword">state</span> 想象成 组件中的 data ,专门用来存储数据的</span><br><span class="line">        // 如果在 组件中，想要访问，store 中的数据，只能通过 this.<span class="hljs-variable">$store</span>.<span class="hljs-keyword">state</span>.*** 来访问</span><br><span class="line">        count: <span class="hljs-number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">mutations: &#123;</span><br><span class="line">    // 注意： 如果要操作 store 中的 <span class="hljs-keyword">state</span> 值，只能通过 调用 mutations 提供的方法，才能操作对应的数据，不推荐直接操作 <span class="hljs-keyword">state</span> 中的数据，因为 万一导致了数据的紊乱，不能快速定位到错误的原因，因为，每个组件都可能有操作数据的方法；</span><br><span class="line">    increment(<span class="hljs-keyword">state</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">state</span>.count++</span><br><span class="line">    &#125;,</span><br><span class="line">    // 注意： 如果组件想要调用 mutations 中的方法，只能使用 this.<span class="hljs-variable">$store</span>.commit('方法名')</span><br><span class="line">    // 这种 调用 mutations 方法的格式，和 this.<span class="hljs-variable">$emit</span>('父组件中方法名')</span><br><span class="line">    subtract(<span class="hljs-keyword">state</span>, obj) &#123;</span><br><span class="line">        // 注意： mutations 的 函数参数列表中，最多支持两个参数，其中，参数<span class="hljs-number">1</span>： 是 <span class="hljs-keyword">state</span> 状态； 参数<span class="hljs-number">2</span>： 通过 commit 提交过来的参数；</span><br><span class="line">        console.<span class="hljs-keyword">log</span>(obj)</span><br><span class="line">        <span class="hljs-keyword">state</span>.count -= (obj.c + obj.d)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">getters: &#123;</span><br><span class="line">    // 注意：这里的 getters， 只负责 对外提供数据，不负责 修改数据，如果想要修改 <span class="hljs-keyword">state</span> 中的数据，请 去找 mutations</span><br><span class="line">    optCount: function(<span class="hljs-keyword">state</span>) &#123;</span><br><span class="line">            return '当前最新的count值是：' + <span class="hljs-keyword">state</span>.count</span><br><span class="line">        &#125;</span><br><span class="line">        // 经过咱们回顾对比，发现 getters 中的方法， 和组件中的过滤器比较类似，因为 过滤器和 getters 都没有修改原数据， 都是把原数据做了一层包装，提供给了 调用者；</span><br><span class="line">        // 其次， getters 也和 computed 比较像， 只要 <span class="hljs-keyword">state</span> 中的数据发生变化了，那么，如果 getters 正好也引用了这个数据，那么 就会立即触发 getters 的重新求值；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">import App <span class="hljs-keyword">from</span> './App.vue'</span><br><span class="line"></span><br><span class="line">const vm = new Vue(&#123;</span><br><span class="line">    el: '<span class="hljs-comment">#app',</span></span><br><span class="line">    render: h =&gt; h(App),</span><br><span class="line">    store // <span class="hljs-number">5</span>. 将 vuex 创建的 store 挂载到 VM 实例上， 只要挂载到了 vm 上，任何组件都能使用 store 来存取数据</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>counter.vue</code>文件内容</p> <figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"减少"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"remove"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"增加"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"add"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"$store.state.count"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"><span class="hljs-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="hljs-actionscript">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-comment">// count: 0</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    add() &#123;</span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-comment">// 不要这样使用，不符合 vuex 的设计理念，因为这样直接操作了state</span></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-comment">// this.$store.state.count++;</span></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-keyword">this</span>.$store.commit(<span class="hljs-string">"increment"</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    remove() &#123;</span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-keyword">this</span>.$store.commit(<span class="hljs-string">"subtract"</span>, &#123; c: <span class="hljs-number">3</span>, d: <span class="hljs-number">1</span> &#125;);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed:&#123;</span><br><span class="line">    fullname: &#123;</span><br><span class="line"><span class="hljs-javascript">      <span class="hljs-keyword">get</span>()&#123;&#125;,</span></span><br><span class="line"><span class="hljs-javascript">      <span class="hljs-keyword">set</span>()&#123;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"scss"</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>amount.vue</code>文件内容：</p>  <figure class="highlight django hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml">    <span class="hljs-comment">&lt;!-- &lt;h3&gt;</span></span><span class="hljs-template-variable">&#123;&#123; $store.state.count &#125;&#125;</span><span class="hljs-xml"><span class="hljs-comment">&lt;/h3&gt; --&gt;</span></span></span><br><span class="line"><span class="hljs-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; $store.getters.optCount &#125;&#125;</span><span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml">    </span></span><br><span class="line"><span class="hljs-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml"></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml"></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"scss"</span> <span class="hljs-attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml"></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>这样，这两个兄弟节点，就可以通过<code>state</code>读写数据了，不需要进行组件之间的传值</p></li><li><p>总结：</p><ol><li><code>state</code>中的数据，不能直接修改，如果想要修改，必须通过 <code>mutations</code>,不然的话就违背了<code>vuex</code>的设计初衷</li><li>如果组件想要直接 从 state 上获取数据： 需要 <code>this.$store.state.***</code></li><li>如果 组件，想要修改数据，必须使用 mutations 提供的方法，需要通过 <code>this.$store.commit(&#39;方法的名称&#39;， 唯一的一个参数)</code></li><li>如果 <code>store</code> 中 <code>state</code> 上的数据， 在对外提供的时候，需要做一层包装，那么 ，推荐使用 <code>getters</code>, 如果需要使用 <code>getters</code> ,则用 <code>this.$store.getters.***</code></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;vuex是什么？Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://zhongyuehui.github.io/categories/Vue/"/>
    
    
      <category term="vuex" scheme="https://zhongyuehui.github.io/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vs code中Git工具的使用</title>
    <link href="https://zhongyuehui.github.io/2019/07/02/Vs%20code%E4%B8%ADGit%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://zhongyuehui.github.io/2019/07/02/Vs code中Git工具的使用/</id>
    <published>2019-07-02T02:25:57.000Z</published>
    <updated>2019-07-07T13:38:45.218Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在一些开发工具中，集成了许多的功能，在我喜欢的vscode中，就集成了git的一些功能，非常方便我们使用</p></blockquote><a id="more"></a><h2 id="vscode中的Git工具"><a href="#vscode中的Git工具" class="headerlink" title="vscode中的Git工具"></a>vscode中的Git工具</h2><ul><li>当我们在对一些推送到远程的项目进行修改时，我们在VS code中发现修改的内容在侧边会有标记<ul><li><font color="red">红色</font>的箭头标识表示这里删除了一些东西</li><li><font color="green">绿色</font>标识表示这里修改了一些东西</li><li><font color="blue">蓝色</font>标识标识增加了一些东西</li></ul></li><li>当然，我们要说的并不是只有这些，最主要的是我们修改的文件内容后需要推送到远程，再也不需要<code>git add &#39;&#39;、git commit -m &#39;&#39; ，git push</code>了，我们在侧边栏找到这个工具<br><img src="https://s2.ax1x.com/2019/07/02/ZGB7s1.png" alt="git工具"></li><li>在这里工具会显示你修改了几个文件，而在更多这里显示你修改了哪些文件，鼠标指针放在修改的文件可以对文件进行一些操作，比如撤回修改</li><li>我们继续往下看，在这里有一个 <code>message</code>这里需要添加的是你提交的描述，和<code>git commit -m &#39;&#39;</code> 这里的一致，添加消息后点击 <strong>√</strong>就可以保存到暂存区了</li><li>如果需要推送到远程，点击推送即可<br><img src="https://s2.ax1x.com/2019/07/02/ZGDuyn.png" alt="推送到远程">、</li><li><strong>注意：</strong>如果你关联了多个远程，那么直接点击推送可能会报错，因为它不知道你需要推送到哪一个，所以选择<code>推送到...</code>然后选择即可<br><img src="https://s2.ax1x.com/2019/07/02/ZGDwex.png" alt="选择仓库"></li><li>这样我们在以后的开发中可以减少一点工作量</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在一些开发工具中，集成了许多的功能，在我喜欢的vscode中，就集成了git的一些功能，非常方便我们使用&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="开发工具" scheme="https://zhongyuehui.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="vs code" scheme="https://zhongyuehui.github.io/tags/vs-code/"/>
    
  </entry>
  
  <entry>
    <title>关联多个远程仓库</title>
    <link href="https://zhongyuehui.github.io/2019/07/02/%E5%85%B3%E8%81%94%E5%A4%9A%E4%B8%AA%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <id>https://zhongyuehui.github.io/2019/07/02/关联多个远程仓库/</id>
    <published>2019-07-02T01:21:36.000Z</published>
    <updated>2019-07-02T01:24:05.885Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们在日常的开发中，由于GitHub是外国的服务器，所以上传速度较慢，但是我们国内也有托管的网站，比如码云</p></blockquote><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><ul><li>在实际的开发过程中，团队协作开发项目是必不可少的，我们将项目托管到远程仓库上，就是为了解决多人合作开发和代码托管备份的作用，而有时候我们需要将一个项目托管到多个仓库中，现在我们就一起来学习一下如何操作</li></ul><hr><h2 id="使用码云"><a href="#使用码云" class="headerlink" title="使用码云"></a>使用码云</h2><hr><ul><li>要想使用码云现需要注册</li><li>注册成功后在个人中心，配置ssh，因为我们在github中，已经生成了ssh，所以我们直接拿公钥即可<br><img src="https://s2.ax1x.com/2019/07/02/ZGtnfI.png" alt="ssh公钥"></li><li>然后在个人中心旁边有个 + 号 新建仓库即可<br><img src="https://s2.ax1x.com/2019/07/02/ZGtNhn.png" alt="仓库"><h2 id="关联github和码云"><a href="#关联github和码云" class="headerlink" title="关联github和码云"></a>关联github和码云</h2></li><li>在git的使用我们已经详细的简述了如何托管到GitHub中，现在我们讲述一下托管到GitHub和码云中</li><li><code>git remote rm origin</code>；先删除已经关联的<code>origin</code>远程仓库</li><li>git remote add github <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:ZhongYueHui/vue-001.git</li><li><strong>注意：</strong>，远程仓库名是<code>github</code>了不是<code>origin</code>了</li><li>接着关联码云的仓库</li><li>git remote add gitee <a href="mailto:git@gitee.com" target="_blank" rel="noopener">git@gitee.com</a>:zhongyuehui/vue-001.git</li><li><strong>注意：</strong>，远程仓库名是<code>gitee</code>了不是<code>origin</code>了</li><li>现在我们使用<code>git remote -v</code>就可以查看到远程库的信息了  <figure class="highlight stylus hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gitee   git@gitee<span class="hljs-selector-class">.com</span>:zhongyuehui/vue-<span class="hljs-number">001</span><span class="hljs-selector-class">.git</span> (fetch)</span><br><span class="line">gitee   git@gitee<span class="hljs-selector-class">.com</span>:zhongyuehui/vue-<span class="hljs-number">001</span><span class="hljs-selector-class">.git</span> (push)</span><br><span class="line">github  git@github<span class="hljs-selector-class">.com</span>:ZhongYueHui/vue-<span class="hljs-number">001</span><span class="hljs-selector-class">.git</span> (fetch)</span><br><span class="line">github  git@github<span class="hljs-selector-class">.com</span>:ZhongYueHui/vue-<span class="hljs-number">001</span><span class="hljs-selector-class">.git</span> (push)</span><br></pre></td></tr></table></figure></li></ul><h2 id="推送到GitHub和码云"><a href="#推送到GitHub和码云" class="headerlink" title="推送到GitHub和码云"></a>推送到GitHub和码云</h2><ul><li>推送到GitHub：<code>git push github master</code></li><li>推送到码云:<code>git push gitee master</code></li><li>这样，我们的项目将就分别在git和码云中了</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我们在日常的开发中，由于GitHub是外国的服务器，所以上传速度较慢，但是我们国内也有托管的网站，比如码云&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Git" scheme="https://zhongyuehui.github.io/categories/Git/"/>
    
    
      <category term="git" scheme="https://zhongyuehui.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git的使用</title>
    <link href="https://zhongyuehui.github.io/2019/07/01/git%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://zhongyuehui.github.io/2019/07/01/git的使用/</id>
    <published>2019-07-01T13:47:23.000Z</published>
    <updated>2019-07-06T01:30:29.200Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>git是什么？Git(读音为/gɪt/。)是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。</p></blockquote><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>我们在平时的项目开发中，难免会用到一些托管工具来托管自己的代码，这样可以更好的和别人和分享自己项目和合作开发项目，这里就简单介绍一下git的使用。</p></blockquote><hr><h1 id="git的使用"><a href="#git的使用" class="headerlink" title="git的使用"></a>git的使用</h1><h2 id="Git基本操作"><a href="#Git基本操作" class="headerlink" title="Git基本操作"></a>Git基本操作</h2><hr><h3 id="上传本地文件-工作区-到暂存区"><a href="#上传本地文件-工作区-到暂存区" class="headerlink" title="上传本地文件(工作区)到暂存区"></a>上传本地文件(工作区)到暂存区</h3><hr><ul><li><p><code>git status</code>先初始化项目(状态)，检查是否在工作区域还是暂存区</p></li><li><p><code>git add 文件名</code>将文件上传到暂存区</p></li></ul><hr><h3 id="将暂存区的文件上传到git仓库中"><a href="#将暂存区的文件上传到git仓库中" class="headerlink" title="将暂存区的文件上传到git仓库中"></a>将暂存区的文件上传到git仓库中</h3><hr><ul><li><p><code>git status</code>初始化暂存区的项目，查看是否含有相同的内容</p></li><li><p><code>git commit -m &quot;提交的描述&quot;</code>，项目的说明</p></li><li><p><code>git status</code> 查看文件状态</p></li><li><p><strong>注意：</strong>使用 <code>git commit -m &#39;&#39;</code> 是一次性将文件放到分支，使用<code>git add</code>是将文件添加到暂存区(Stage), git是版本控制工具，并不是文件控制工具，我们只有使用<code>git add</code>添加到暂存区的文件，再使用<code>git commit -m &#39;&#39;</code>才能将文件提交到分支，如果你修改了文件直接提交到分支，这个是不能修改的，不信你可以使用<code>git diff HEAD -- &#39;文件名&#39;</code>查看工作区和版面本库中最新版本的区别 ，没有使用<code>git add &#39;&#39;</code> 的文件内容没有并没有添加到版本库(commit)中</p></li></ul><hr><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ul><li>基本流程图<br><img src="https://s2.ax1x.com/2019/06/30/Z39gFP.png" alt="GitHub基本流程"></li></ul><hr><h2 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h2><hr><ul><li><strong>设置用户名</strong>:<code>git config --global user.name &#39;GitHub的用户名&#39;</code></li><li><strong>设置用户名的邮箱</strong>：<code>git config --global user.email &#39;设置用户名的邮箱&#39;</code></li></ul><hr><h2 id="初始化新的git仓库"><a href="#初始化新的git仓库" class="headerlink" title="初始化新的git仓库"></a>初始化新的git仓库</h2><hr><ul><li>创建新的文件夹 也可以在命令行 <code>mkdir 文件夹名字</code>进行创建</li><li>进入文件夹 ，命令行<code>cd 文件夹名</code></li><li>初始化仓库, 命令行 <code>git init</code> ，会生成一个<code>.git</code>的文件夹，若没有在文件夹下点击查看，打开显示隐藏的项目<br><img src="https://s2.ax1x.com/2019/06/30/Z3iPxO.png" alt="查看隐藏文件"></li></ul><hr><h2 id="项目的管理"><a href="#项目的管理" class="headerlink" title="项目的管理"></a>项目的管理</h2><hr><h3 id="上传文件项目-使用流程"><a href="#上传文件项目-使用流程" class="headerlink" title="上传文件项目(使用流程)"></a>上传文件项目(使用流程)</h3><hr><ul><li>在项目文件夹中，创建文件，也可以在命令行中使用<code>touch 文件名</code></li><li><strong>注意</strong>：需要带后缀名</li><li>然后使用 <code>git status</code>可以查看文件是否在暂存区域中(没有是红色)</li><li>如果没有，使用<code>git add &#39;文件名&#39;</code>即可将文件名上传到暂存区中</li><li><code>git status</code>查看文件是否已经存在于暂存区(存在是绿色)</li></ul><hr><h3 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h3><hr><ul><li>命令行直接 <code>vi/vim 文件名</code>即可输入内容，也可以鼠标右键编辑</li><li>修改后 <code>git status</code>，发现文件更改后，又变成红色，需要重新提交</li><li><code>git diff</code>可以查看修改了什么内容</li><li><code>git add 文件名</code>提交即可</li><li><code>git status</code>发现没有文件可以提交，则提交成功</li></ul><hr><h4 id="撤销修改-例如撤回reademe-txt文件的修改"><a href="#撤销修改-例如撤回reademe-txt文件的修改" class="headerlink" title="撤销修改(例如撤回reademe.txt文件的修改)"></a>撤销修改(例如撤回reademe.txt文件的修改)</h4><hr><ul><li>我们再修改文件时可能由于出错误修改，我们可以及时的将文件返回到上一个未修改的版本，修改文件后 <code>git status</code>也可以发现git会提示你使用<code>git checkout -- &lt;file&gt;</code>可以丢弃工作区的修改</li><li>当然，命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：<ul><li>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li><li>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li></ul></li><li>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</li></ul><hr><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><hr><ul><li>在命令行<code>rm -rf 文件名</code>(强制删除，不建议使用)或者<code>rm 文件名</code>(普通删除),<code>rm -l 文件名</code>(删除三个以上提示),<code>rm -i 文件名</code>(删除前提示，可以确认删除文件是否选择正确)，或者在鼠标右键删除</li><li><strong>注意</strong>：上面的步骤是在工作区删除</li><li><code>git rm 文件名</code>:是在git中删除文件</li><li><code>git commit -m &#39;提交描述&#39;</code>，如果需要删除某个文件，则需要<code>rm 文件</code> 再 <code>git rm 文件</code> 再 <code>git commit -m &#39;提交描述&#39;</code>,这样就可以完整的删除这个文件了</li><li><strong>注意</strong>：使用<code>git log</code> 可以查看每次版本的修改历史，如果你嫌弃信息过多眼花缭乱，也可以使用<code>git log --pretty=oneline</code>查看，其中一大串的只是commit id(版本号)而已</li></ul><hr><h3 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h3><hr><ul><li>在git中，使用HEAD表示当前的版本，上个版本使用 <strong>(HEAD^)</strong>表示，上上版本使用 <strong>(HEAD^^)</strong>表示，如果是多个可以使用 <strong>(HEAD~N)</strong>表示</li><li>使用 <code>git reset --hard HEAD^</code>表示回退上一个版本，但是我们使用<code>git log</code>已经查看不到之前我们跳转过来的历史了，但是如果我们想还原，也还是有办法的，只要我们不关闭命令行窗口，找到之前的<strong>commit id</strong>,就可以回到未来的指定版本</li><li>使用<code>git reset --hard commit id</code> 后，可以查看是否回到上个版本了</li></ul><p><strong>注意：</strong> 使用commit id 时不需要全部填写 但是要精确到git能找到该文件</p><blockquote><p>如果我们回退到上一个版本后已经关闭了命令行又想回到最新版本怎么办？</p></blockquote><ul><li>在git中，提供了一个命令<code>git reflog</code>可以记录你的每一条命令</li></ul><hr><h2 id="git远程仓库"><a href="#git远程仓库" class="headerlink" title="git远程仓库"></a>git远程仓库</h2><hr><h3 id="添加远程仓库-如：test"><a href="#添加远程仓库-如：test" class="headerlink" title="添加远程仓库(如：test)"></a>添加远程仓库(如：test)</h3><hr><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><hr><h5 id="创建ssh（如果已经创建关联请忽略）"><a href="#创建ssh（如果已经创建关联请忽略）" class="headerlink" title="创建ssh（如果已经创建关联请忽略）"></a>创建ssh（如果已经创建关联请忽略）</h5><ul><li>在命令行下<code>ssh-keygen -t rsa -C &quot;898542119@qq.com&quot;</code>,然后一路回车即可</li><li>在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人</li><li>登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容即可，这样我们的关联就已经做好了</li></ul><hr><h4 id="远程添加文件到仓库中"><a href="#远程添加文件到仓库中" class="headerlink" title="远程添加文件到仓库中"></a>远程添加文件到仓库中</h4><ul><li>登陆GitHub，点击 <strong>“Create a new repo”</strong>，在<strong>Repository name</strong> 填入仓库名称，其他的默认即可</li><li>在你本地的仓库中运行如下：<code>git remote add origin git@github.com:ZhongYueHui/test.git</code>其中ZhongYueHui是GitHub的名字,test仓库的名字</li><li>然后使用 <code>git push -u origin master</code>就可以将文件提交到GitHub上了，其实就是将本地分支 master 推送到远程，这样远程的仓库和本地就一样了</li><li>从现在开始，只要你对文件做了修改，就可以使用<code>git push origin master</code>将最新的修改提交到版本库了</li><li><strong>注意：</strong>如果第一次clone或者push会弹出如下警告,输入yes即可 <figure class="highlight vbnet hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity <span class="hljs-keyword">of</span> host <span class="hljs-comment">'github.com (xx.xx.xx.xx)' can't be established.</span></span><br><span class="line">RSA <span class="hljs-keyword">key</span> fingerprint <span class="hljs-keyword">is</span> xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want <span class="hljs-keyword">to</span> <span class="hljs-keyword">continue</span> connecting (yes/no)?</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="从远程克隆仓库"><a href="#从远程克隆仓库" class="headerlink" title="从远程克隆仓库"></a>从远程克隆仓库</h3><hr><ul><li>在命令行输入<code>git clone git@github.com:ZhongYueHui/gitskills.git</code>即可克隆<code>gitskills</code>仓库</li><li><strong>注意：</strong>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆,<br>Git支持多种协议，包括<code>https</code>，但通过<code>ssh</code>支持的原生<code>git协议</code>速度最快</li></ul><hr><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><hr><h3 id="创建和合并分支"><a href="#创建和合并分支" class="headerlink" title="创建和合并分支"></a>创建和合并分支</h3><ul><li><p>创建分支:<code>git checkout -b 分支名称</code>，<code>git checkout -b dev</code>相当于创建新分支并切换，相当于如下两条命令</p>  <figure class="highlight q hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch <span class="hljs-built_in">dev</span> <span class="hljs-comment">//创建分支</span></span><br><span class="line">git checkout <span class="hljs-built_in">dev</span> <span class="hljs-comment">//切换分支</span></span><br></pre></td></tr></table></figure></li><li><p>查看分支:<code>git branch</code>,会列出所有的分支，当前的分支会使用<code>*</code>标记</p></li><li><p>我们在<code>dev</code>分支下修改的文件在切换到<code>master</code>分支查看，发现并未修改，但是我们可以使用<code>git merge dev</code>将dev分支合并到当前的分支上(<code>master</code>)</p></li><li><p>合并完之后，我们就可以将<code>dev</code>分支删除了:<code>git branch -d dev</code>，使用<code>git branch</code>查看分支就只有<code>master</code> 了</p></li><li><p><strong>小结</strong>：</p>  <figure class="highlight fortran hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">查看分支：git branch</span><br><span class="line"></span><br><span class="line">创建分支：git branch &lt;<span class="hljs-keyword">name</span>&gt;</span><br><span class="line"></span><br><span class="line">切换分支：git checkout &lt;<span class="hljs-keyword">name</span>&gt;</span><br><span class="line"></span><br><span class="line">创建+切换分支：git checkout -b &lt;<span class="hljs-keyword">name</span>&gt;</span><br><span class="line"></span><br><span class="line">合并某分支到当前分支：git <span class="hljs-built_in">merge</span> &lt;<span class="hljs-keyword">name</span>&gt;</span><br><span class="line"></span><br><span class="line">删除分支：git branch -d &lt;<span class="hljs-keyword">name</span>&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="分支之间的冲突"><a href="#分支之间的冲突" class="headerlink" title="分支之间的冲突"></a>分支之间的冲突</h3><ul><li>假设我们在创建了一个分支<strong>feature1</strong>，我们在feature1上修改reademe.txt文件，然后<code>git add  reademe.txt</code>和<code>git commit -m &#39;&#39;</code>，然后切换到<code>master</code>中同样对reademe.txt做出修改，然后<code>git add  reademe.txt</code>和`git commit -m</li><li>这样，我们想合并<strong>feature1</strong>分支就会出异常，Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改自己想要的内容和删除标记后保存：这个时候我们需要将内容统一到和<strong>feature1</strong>，然后<code>git add  reademe.txt</code>和<code>git commit -m</code>即可</li><li>我们还可以使用<code>git log --graph --pretty=oneline --abbrev-commit</code>查看分支合并情况<h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900005860592480" target="_blank" rel="noopener">分支管理策略</a></h3></li><li>合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用<code>Fastforward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息</li><li>假设我们在创建了一个分支<strong>feature1</strong>，我们在feature1上修改reademe.txt文件，然后<code>git add  reademe.txt</code>和<code>git commit -m &#39;&#39;</code>，然后切换到<code>master</code>中,准备合并<strong>feature1</strong>，使用=&gt;<code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>进行合并，注意 <code>--no-ff</code>表示的是<strong>禁用</strong><code>Fast forward</code></li><li><code>git log --graph --pretty=oneline --abbrev-commit</code>查看分支历史<figure class="highlight coq hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> *   e1e9c68 (HEAD -&gt; master) merge <span class="hljs-built_in">with</span> no-ff</span><br><span class="line">|<span class="hljs-type">\  </span></span><br><span class="line"><span class="hljs-type">| * f52c633</span> (dev) add merge</span><br><span class="line">|<span class="hljs-type">/  </span></span><br><span class="line"><span class="hljs-type">*   cf810e4</span> conflict fixed</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure></li></ul><h3 id="BUG分支"><a href="#BUG分支" class="headerlink" title="BUG分支"></a>BUG分支</h3><ul><li><p>我们可能在开发中出现一些紧急的BUG需要及时修复，你可能马上想创建一个BUG修复的文件，但是你突然发现自己手中的 工作还没做完，无法提交，这时候就需要用到Git提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作</p></li><li><p>我们使用<code>git stash</code>来暂停自己的工作现场，然后创建自己的<code>bug修复分区</code>，然后<code>git add &#39;&#39;</code>,<code>git commit -m &#39;&#39;</code>后合并到master分区中，这样BUG修复完毕了，删除bug修复分区即可（<code>git merge --no-ff -m &quot;删除描述&quot; 分区名</code>）</p></li><li><p>修复完后就可以切换到自己原来的分区继续工作了，但是我们需要使用<code>git stash list</code>查看，使用<code>git status</code>查看是干净的，然后我们可以使用<code>git stash apply</code>恢复，但是恢复后，<code>stash</code>内容并不删除，你需要用<code>git stash drop</code>来删除；<br>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容(就是暂停的记录)也删了,再使用<code>git stash list</code>就是干净的了                                                                    </p>  <figure class="highlight applescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stash@&#123;<span class="hljs-number">0</span>&#125;: WIP <span class="hljs-keyword">on</span> master: <span class="hljs-number">54</span>a255b git tracks changes</span><br></pre></td></tr></table></figure></li><li><p>你可以多次使用<code>git stash list</code>，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的<code>stash</code>，用命令：<code>git stash apply stash@{0}</code></p><h3 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h3></li><li><p>用于实验的项目功能，不能直接用于主分支，容易乱掉，所以最好新建一个分支进行实验性测试</p></li><li><p>新建一个分区后，新建一个增加功能的文件，<code>git add &#39;&#39;</code>,<code>git commit -m &#39;&#39;</code>后<code>git checkout dev</code>合并到dev中，如果此时想删除这个功能文件，我们此时就应该删除该文件<code>git branch -d feature-vulcan</code>，如果提示还没有合并，那么直接将<code>-d</code>换成<code>-D</code>即可强制删除该分区</p>  <figure class="highlight subunit hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">error: </span>The branch 'feature-vulcan' is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run 'git branch -D feature-vulcan'.</span><br></pre></td></tr></table></figure></li></ul><h3 id="远程同步分支"><a href="#远程同步分支" class="headerlink" title="远程同步分支"></a>远程同步分支</h3><ul><li>当我们需要多个人同时开发项目时，我们应该将本地的分支推送到远程分支上</li><li>当我们从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。要查看远程库的信息，用<code>git remote</code>或者<code>git remote -v</code>   <figure class="highlight stylus hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin  git@github<span class="hljs-selector-class">.com</span>:ZhongYueHui/learngit<span class="hljs-selector-class">.git</span> (fetch)</span><br><span class="line">origin  git@github<span class="hljs-selector-class">.com</span>:ZhongYueHui/learngit<span class="hljs-selector-class">.git</span> (push)</span><br></pre></td></tr></table></figure></li></ul><h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h4><ul><li><code>git push origin master</code>将本地分支推送到远程分支上</li><li>如果推送<code>dev</code>这个分区，<code>git push origin dev</code>即可</li><li><strong>说明：</strong> 并不是每个分支都需要被推送，<ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步</li><li><code>bug</code>分支只用于在本地修复bug，就没必要推到远程了，除非上级要求</li><li><code>feature</code>分支是否推到远程，取决于你是否和你的项目伙伴<h4 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h4></li></ul></li><li>如果你和你的团队再开发一个项目时，你的一个伙伴推送文件到<code>dev</code>分支上，并且推送到远程上，这个时候如果你也推送(push)<code>dev</code>到远程，这个是时候就会出错，解决办法也是和分支之间的冲突一样处理</li><li><strong>小结：</strong><ul><li>首先，可以试图用git push origin <branch-name>推送自己的修改；</branch-name></li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！</branch-name></li><li>如果git pull提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code><h4 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h4></li></ul></li><li>我们在多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后<code>push</code>的伙伴不得不先<code>pull</code>，在本地合并，然后才能<code>push</code>成功。每次合并再<code>push</code>后，分支变成的很乱</li><li>使用<code>git rebase</code>可以解决这个问题，帮我们把分支整理成一条直线<h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3></li><li>方便我们查找，虽然git有 <code>commit</code>，但是这个东西是一堆进制数，不方便我们查找，所以我们设置标签的形式，方便查找</li><li>在你想要创建标签的分支上,输入<code>git tag &lt;name&gt;</code>添加标签，使用<code>git tag</code>可以查看所有标签给git</li><li>如果之前忘记了添加标签，找到历史的<code>commit id</code>打上就可以，<code>git log --pretty=oneline --abbrev-commit</code></li><li>比方说要对<code>add merge</code>这次提交打标签，它对应的<code>commit id</code>是<code>f52c633</code>，敲入命令：<code>git tag v0.9 f52c633</code></li><li>查看所有的书签：<code>git show &lt;tagname&gt;</code><ul><li>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</li><li>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</li><li>命令<code>git tag</code>可以查看所有标签<h4 id="操作书签"><a href="#操作书签" class="headerlink" title="操作书签"></a>操作书签</h4></li></ul></li><li>修改书签：<code>git tag -d v0.1</code></li><li>将标签推送到远程：<code>git push origin &lt;tagname&gt;</code>或者<code>git push origin --tags</code>一次性将推送未推送的书签</li><li>删除远程的书签：<ul><li>先删除本地的书签：<code>git tag -d v0.9</code></li><li>再从远程删除：<code>git push origin :refs/tags/v0.9</code></li></ul></li><li><strong>总结：</strong><ul><li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li><li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li><li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li><li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签</li><li></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;git是什么？Git(读音为/gɪt/。)是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Git" scheme="https://zhongyuehui.github.io/categories/Git/"/>
    
    
      <category term="git" scheme="https://zhongyuehui.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>express中的中间件</title>
    <link href="https://zhongyuehui.github.io/2019/06/24/express%E4%B8%AD%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://zhongyuehui.github.io/2019/06/24/express中的中间件/</id>
    <published>2019-06-24T03:26:57.000Z</published>
    <updated>2019-06-25T07:34:44.497Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在Nodejs中的Express框架来说，中间件是一个比较抽象的概念，但是对于理解Nodejs的请求原理是非常重要的，这里简单的介绍了Nodejs中Express框架的中间件原理</p></blockquote><a id="more"></a><!-- toc --><hr><h3 id="中间件的原理"><a href="#中间件的原理" class="headerlink" title="中间件的原理"></a>中间件的原理</h3><hr><p><img src="https://i.loli.net/2019/06/24/5d1044327363a92295.png" alt></p><ul><li><p>就是相当于水经过一系列处理到用户的过程，中间不能跳过某些步骤或者调换某些步骤</p></li><li><p>下面使用一个代码来帮助我们更好的理解中间件的概念</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)</span><br><span class="line"><span class="hljs-keyword">const</span> app = express()</span><br><span class="line"><span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//这个就是中间件，中间件就是一个函数，函数有三个参数</span></span><br><span class="line"><span class="hljs-comment">//request 请求数据</span></span><br><span class="line"><span class="hljs-comment">//respone  响应数据</span></span><br><span class="line"><span class="hljs-comment">// next  表示继续执行下一个中间件，如果没有使用这个方法，那么下面就算有符合匹配项，都不会被执行</span></span><br><span class="line"><span class="hljs-comment">//这个表示所有请求都会经过这里,但是请求到这里时会停留，如果想要继续执行需要调用next方法</span></span><br><span class="line">app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">request, respone, next</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a'</span>)</span><br><span class="line">    next() <span class="hljs-comment">//需要继续执行</span></span><br><span class="line">&#125;)</span><br><span class="line">app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">request, respone, next</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b'</span>)</span><br><span class="line">        next()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="hljs-comment">//这个表示所有的get请求并且路径为 / 的请求会经过这个中间件</span></span><br><span class="line">app.get(<span class="hljs-string">'/'</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello World!'</span>)</span><br><span class="line">        <span class="hljs-comment">//如果此时不使用next方法，那么下面的get函数不会 被执行</span></span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="hljs-string">'/'</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="hljs-string">'Hello World!'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(port, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Example app listening on port port!`</span>))</span><br></pre></td></tr></table></figure></li><li><p>所以，我们在使用中间件时，都应该遵循这些规则，这样可以帮助我们更好的编写程序</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在Nodejs中的Express框架来说，中间件是一个比较抽象的概念，但是对于理解Nodejs的请求原理是非常重要的，这里简单的介绍了Nodejs中Express框架的中间件原理&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Nodejs" scheme="https://zhongyuehui.github.io/categories/Nodejs/"/>
    
    
      <category term="Express" scheme="https://zhongyuehui.github.io/tags/Express/"/>
    
  </entry>
  
  <entry>
    <title>webpack中引入vue</title>
    <link href="https://zhongyuehui.github.io/2019/06/23/webpack%E4%B8%AD%E5%BC%95%E5%85%A5vue/"/>
    <id>https://zhongyuehui.github.io/2019/06/23/webpack中引入vue/</id>
    <published>2019-06-23T15:04:31.000Z</published>
    <updated>2019-06-25T07:34:24.851Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在webpack使用vue，我们会遇到一些打包的问题，这个使用我们要使用打包工具来解决这个问题，以下是具体的一些说明和使用。</p></blockquote><a id="more"></a><!--toc--><hr><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><hr><ol><li><p>在webpack中，我们需要将所有的包在<code>main.js</code>这个入口文件中导入，在在我们安装<code>vue(npm i vue -D)</code>到本地时，我们在<code>main.js</code>导入这个包</p><figure class="highlight capnproto hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span></span><br></pre></td></tr></table></figure></li><li><p>会爆出以下异常： <code>You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.</code></p></li><li><p>以下的问题解释是：在webpack中使用 import Vue from “vue” 引入的 vue构造函数 功能是不完整的，它只提供了runtime-only 的方式，并没有提供 像网页中使用 script引入的那些功能</p></li></ol><ul><li><p>解决方式一：</p><ul><li>使用：<code>import Vue from &quot;../node_modules/vue/dist/vue&quot;</code>这种引入方式</li></ul></li><li><p>解决方式二：</p><ul><li><p>配置<code>webpack.config.js</code>文件，新增一个属性:<code>resolve</code>，在里面中还有一个属性:<code>alias</code>，配置如下</p><figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">resolve</span>: &#123;</span><br><span class="line">    <span class="hljs-attribute">alias</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-string">'vue$'</span>: <span class="hljs-string">'vue/dist/vue.esm.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这样使用<code>import Vue from &quot;vue&quot;</code>引入也不会报错了</p></li></ul></li></ul><hr><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><hr><ul><li>由于<code>webpack</code>是使用Node架构的，所以合法的Node语法都支持，当然，引入包的规则也是一致的</li><li>如下：</li><li>Nodejs中包的查找规则:<ol><li>找项目根目录中是否有安装 node_modules 的文件夹</li><li>在node_modules 中根据包名，找对应的 vue 文件夹</li><li>在 vue中，找到一个叫packahe.json的配置文件</li><li>在package.json 文件夹中，查找一个 main 属性，这个属性指定了这个包被加载时的入口文件</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在webpack使用vue，我们会遇到一些打包的问题，这个使用我们要使用打包工具来解决这个问题，以下是具体的一些说明和使用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://zhongyuehui.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://zhongyuehui.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>webpack打包图片</title>
    <link href="https://zhongyuehui.github.io/2019/06/22/webpack%E6%89%93%E5%8C%85%E5%9B%BE%E7%89%87/"/>
    <id>https://zhongyuehui.github.io/2019/06/22/webpack打包图片/</id>
    <published>2019-06-22T12:15:21.000Z</published>
    <updated>2019-06-25T06:05:09.448Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在webpack中，我们使用其打包一些项目的时候，经常会遇到图片，但是如果直接打包图片则会抛出异常，以下是打包图片的一些详细配置文件和步骤</p></blockquote><a id="more"></a> <hr><h3 id="使用webpack打包图片"><a href="#使用webpack打包图片" class="headerlink" title="使用webpack打包图片"></a>使用webpack打包图片</h3><hr><ul><li><p>在平常中，我们在设置style中使用<code>background:url</code> 可以引入背景图片，在前面我们已经学会如何打包<code>css、less、scss</code>文件</p></li><li><p>安装<code>url-loader</code>和其依赖<code>file-loader</code></p></li><li><p><code>cnpm install url-loader file-loader -D</code></p></li><li><p>使用<code>file-loader</code>进行图片的打包</p></li><li><p>在webpack.config.js中配置，在与其他配置下添加如下即可</p></li><li><figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            <span class="hljs-attribute">test</span>: /\.jpg|png|gif|bmp|jpeg/, //配置图片</span><br><span class="line">            use: [<span class="hljs-string">'file-loader'</span>]</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>可以简写成如下：</p><figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            <span class="hljs-attribute">test</span>: /\.(jpg|png|gif|bmp|jpeg)/, //配置图片打包的格式</span><br><span class="line">            loader: <span class="hljs-string">'file-loader'</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>如果想要打包出来的图片不改变名字和格式，只需添加<code>options</code>即可</p><pre><code><figure class="highlight less hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            <span class="hljs-attribute">test</span>: /\.(jpg|png|gif|bmp|jpeg)/, <span class="hljs-comment">//配置图片打包的格式</span></span><br><span class="line">            <span class="hljs-attribute">loader</span>: <span class="hljs-string">'file-loader'</span></span><br><span class="line">            <span class="hljs-attribute">options</span>: &#123; <span class="hljs-comment">//[name]表示名字,[ext]表示格式，而name属性其实就是图片打包后的路径</span></span><br><span class="line">                <span class="hljs-attribute">name</span>: <span class="hljs-string">'images/[name].[ext]'</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>除了使用file-loader对图片进行打包处理外，我们同样也可以使用url-loader代替，另外我们还可以对小于某个大小的图片进行base64格式的转化处理。</p></li><li><p>使用<code>url-loader</code>打包</p><figure class="highlight clojure hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.(<span class="hljs-name">png</span>|jpg|gif|svg)$/,</span><br><span class="line">    loader: 'url-loader',</span><br><span class="line">    options: &#123;</span><br><span class="line">        name: './images/[name].[ext]',</span><br><span class="line">        limit: <span class="hljs-number">8192</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这里limit属性的作用就是将小于8192B（8.192K）大小的图片转成base64格式，而大于这个大小的图片将会以file-loader的方式进行打包处理</p></li><li><p><strong>注意</strong>：如果不写limit属性，那么url-loader就会默认将所有图片转成base64</p></li><li><p>这样打包出来的图片会自动转换成<code>base64</code>,但是我们多数是将小图片转成base64，而大图片不进行转换</p></li><li><p>而对于有些图片在不同路径下，但是文件名字一样时，我们需要在<code>name:</code>属性中增加<code>hash</code>值：定义[hash:8]定义 8位hash值最多32位，这样图片就不会存在不同</p>  <figure class="highlight less hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            <span class="hljs-attribute">test</span>: /\.(jpg|png|gif|bmp|jpeg)/, <span class="hljs-comment">//配置图片</span></span><br><span class="line">            <span class="hljs-attribute">loader</span>: <span class="hljs-string">'url-loader'</span>, <span class="hljs-comment">//在这里时，只有一个我们可以简化 loader，使用use则会报错</span></span><br><span class="line">            <span class="hljs-attribute">options</span>: &#123;</span><br><span class="line">                <span class="hljs-attribute">limit</span>: <span class="hljs-number">2000</span>, <span class="hljs-comment">//limit 的值单位是 Byte ，如果图片小于limit的值，则转成base64格式的字符串，如果大于，则不转</span></span><br><span class="line">                <span class="hljs-attribute">name</span>: <span class="hljs-string">'[hash:8]-[name].[ext]'</span> <span class="hljs-comment">//这是将文件名原样输出[name]指的是图片名，[ext]是图片格式，</span></span><br><span class="line">                    <span class="hljs-comment">//[hash:8]表示生成8位hash值，否则在不同文件夹下同名图片会失效，用来区分</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在webpack中，我们使用其打包一些项目的时候，经常会遇到图片，但是如果直接打包图片则会抛出异常，以下是打包图片的一些详细配置文件和步骤&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://zhongyuehui.github.io/categories/Vue/"/>
    
    
      <category term="webpack" scheme="https://zhongyuehui.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack配置的一些总结</title>
    <link href="https://zhongyuehui.github.io/2019/06/22/webpack%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <id>https://zhongyuehui.github.io/2019/06/22/webpack配置的一些总结/</id>
    <published>2019-06-22T09:07:14.000Z</published>
    <updated>2019-07-01T14:20:26.435Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在配置webpack打包项目时，有些必要的插件安装与配置，才能保证项目完整的被打包，这里总结了一些基础的webpack配置，可以满足基础的打包运行要求。</p></blockquote><a id="more"></a><hr><h2 id="全局安装webpack"><a href="#全局安装webpack" class="headerlink" title="全局安装webpack"></a>全局安装webpack</h2><hr><ul><li><p><code>npm  install webpack -g</code></p><h2 id="生成package-json"><a href="#生成package-json" class="headerlink" title="生成package.json"></a>生成package.json</h2></li><li><p><code>npm init -y</code></p><h2 id="安装webpack-dev-server到本地"><a href="#安装webpack-dev-server到本地" class="headerlink" title="安装webpack-dev-server到本地"></a>安装webpack-dev-server到本地</h2></li><li><p><code>npm install webpack-dev-server -D</code></p></li><li><p>仍然需要在本地安装webpack作为webpack-dev-server的依赖</p></li><li><p><code>npm install  webpack -D</code></p><h3 id="配置webpack-config-js文件"><a href="#配置webpack-config-js文件" class="headerlink" title="配置webpack.config.js文件"></a>配置webpack.config.js文件</h3></li><li><p>创建webpack.config.js文件</p></li><li><p>配置文件出入口</p><figure class="highlight lasso hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//由于webpack是由Nodejs构建的，所以任何的Nodejs语法都支持</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//引入路径模块</span></span><br><span class="line"><span class="hljs-built_in">var</span> path = <span class="hljs-keyword">require</span>(<span class="hljs-string">'path'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//当以命令形式运行webpack或者webpack-dev-server的时候，工具会发现，我们没用提供要打包的文件入口和出口命令</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//此时，就会检查项目根目录中的配置文件 webpack.config.js 并读取这个文件，就拿到了导出的这个配置对象，然后根据对象进行打包</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//向外暴露出这个对象</span></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: path.<span class="hljs-keyword">join</span>(__dirname, <span class="hljs-string">'./src/main.js'</span>) <span class="hljs-comment">//入口文件，需要打包的文件</span></span><br><span class="line">        ,</span><br><span class="line">    output: &#123; <span class="hljs-comment">//出口文件，需要打包到哪里去</span></span><br><span class="line">        path: path.<span class="hljs-keyword">join</span>(__dirname, <span class="hljs-string">'./dist/bundle.js'</span>) <span class="hljs-comment">//输出路径</span></span><br><span class="line">            ,</span><br><span class="line">        filename: <span class="hljs-string">'bundle.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="hljs-string">'development'</span>, <span class="hljs-comment">//设置mode，在4.0新增</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>配置一些功能：在webpack.config.js中配置</p><figure class="highlight less hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="hljs-attribute">devServer</span>: &#123; <span class="hljs-comment">//配置webpack-dev-server</span></span><br><span class="line">    <span class="hljs-attribute">open</span>: true, <span class="hljs-comment">//是否打开浏览器</span></span><br><span class="line">    <span class="hljs-attribute">contentBase</span>: <span class="hljs-string">'src'</span>, <span class="hljs-comment">//指定托管的目录</span></span><br><span class="line">    <span class="hljs-attribute">hot</span>: true, <span class="hljs-comment">//是否启用热更新</span></span><br><span class="line">    <span class="hljs-attribute">port</span>: <span class="hljs-number">6000</span> <span class="hljs-comment">//代理的端口</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>在<code>package.json</code>中配置</p>  <figure class="highlight brainfuck hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">"script":&#123;</span></span><br><span class="line"><span class="hljs-comment">"start:dev":</span> <span class="hljs-comment">"webpack</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">open</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">port</span> <span class="hljs-comment">3000</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">contentBase</span> <span class="hljs-comment">src</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">hot"</span></span><br><span class="line"><span class="hljs-comment">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>需要将打包好的文件从虚拟内存中传入过来</p></li></ul><hr><h3 id="安装html-webpack-plugin"><a href="#安装html-webpack-plugin" class="headerlink" title="安装html-webpack-plugin"></a>安装html-webpack-plugin</h3><hr><ul><li><code>npm install html-webpack-plugin -D</code></li><li>在<code>webpack.config.js</code>中配置这个插件</li><li>作用：<ul><li>在内存中，根据只当的模板页面，生成一份内存中的首页，同时把打包好的bundle.js注入到页面底部</li><li>如果需要配置插件，需要在导出的对象中挂载一个 plugins:[]</li><li>注意：所有的第三方插件都在 <code>plugins:[]</code>中配置</li><li>与entry、output同级<figure class="highlight less hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attribute">plugins</span>: [</span><br><span class="line">       new htmlWebpackPlugin(&#123;</span><br><span class="line">           <span class="hljs-attribute">template</span>: path.join(__dirname, <span class="hljs-string">'./src/index.html'</span>), <span class="hljs-comment">//指定模板文件的目录</span></span><br><span class="line">           <span class="hljs-attribute">filename</span>: <span class="hljs-string">'index.html'</span> <span class="hljs-comment">//设置生成的页面名称</span></span><br><span class="line"></span><br><span class="line">       &#125;)</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="配置css-loader、less-loader、sass-loader"><a href="#配置css-loader、less-loader、sass-loader" class="headerlink" title="配置css-loader、less-loader、sass-loader"></a>配置css-loader、less-loader、sass-loader</h3><hr><ul><li>在main.js中引入css文件</li><li>import ‘./css/style.css’ <ul><li>安装css-loader插件：<code>npm install  css-loader style-loader --save-dev</code></li></ul></li><li>import ‘./css/style.less’ <ul><li>安装css-loader插件：<code>npm install less-loader less --save-dev</code></li></ul></li><li>import ‘./css/style.sass’ <ul><li>安装css-loader插件：<code>npm install sass-loader node-sass --save-dev</code></li></ul></li></ul><hr><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><hr><ul><li><p>在webpack.config.js配置sass</p></li><li><p><strong>注意</strong>：使用<code>npm</code>命令时安装<code>node-sass</code>可能会报错，无法打包，此时建议切换成<code>cnpm</code></p></li><li><p>切换方法 cmd运行<code>nrm ls</code>查看,然后切换<code>nrm use cnpm</code>即可，但是前提应该先在全局中安装<code>nrm</code></p>  <figure class="highlight openscad hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">module</span>.<span class="hljs-title">exports</span> =</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">module</span>: &#123;</span></span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: /\.scss$/,</span><br><span class="line">            <span class="hljs-keyword">use</span>: [</span><br><span class="line">                <span class="hljs-string">"style-loader"</span>, <span class="hljs-comment">// creates style nodes from JS strings</span></span><br><span class="line">                <span class="hljs-string">"css-loader"</span>, <span class="hljs-comment">// translates CSS into CommonJS</span></span><br><span class="line">                <span class="hljs-string">"sass-loader"</span> <span class="hljs-comment">// compiles Sass to CSS, using Node Sass by default</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在webpack.config.js配置css</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="hljs-keyword">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="hljs-regexp">/\.css$/i</span>,</span><br><span class="line">        use: [<span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在webpack.config.js配置less</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="hljs-keyword">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="hljs-regexp">/\.less$/</span>,</span><br><span class="line">        loader: <span class="hljs-string">'less-loader'</span>, <span class="hljs-comment">// compiles Less to CSS</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="配置好基本的webpack-config-js文件"><a href="#配置好基本的webpack-config-js文件" class="headerlink" title="配置好基本的webpack.config.js文件"></a>配置好基本的webpack.config.js文件</h3><hr><pre><code><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//由于webpack是由Nodejs构建的，所以任何的Nodejs语法都支持</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//引入路径模块</span></span><br><span class="line"><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//在内存中，根据只当的模板页面，生成一份内存中的首页，同时把打包好的bundle.js注入到页面底部</span></span><br><span class="line"><span class="hljs-comment">//如果需要配置插件，需要在导出的对象中挂载一个 plugins:[]</span></span><br><span class="line"><span class="hljs-keyword">const</span> htmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//当以命令形式运行webpack或者webpack-dev-server的时候，工具会发现，我们没用提供要打包的文件入口和出口命令</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//此时，就会检查项目根目录中的配置文件 webpack.config.js 并读取这个文件，就拿到了导出的这个配置对象，然后根据对象进行打包</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//向外暴露出这个对象</span></span><br><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: path.join(__dirname, <span class="hljs-string">'./src/main.js'</span>) <span class="hljs-comment">//入口文件，需要打包的文件</span></span><br><span class="line">        ,</span><br><span class="line">    output: &#123; <span class="hljs-comment">//出口文件，需要打包到哪里去</span></span><br><span class="line">        path: path.join(__dirname, <span class="hljs-string">'./dist'</span>) <span class="hljs-comment">//输出路径</span></span><br><span class="line">            ,</span><br><span class="line">        filename: <span class="hljs-string">'bundle.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="hljs-keyword">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="hljs-regexp">/\.css$/i</span>, <span class="hljs-comment">//配置css</span></span><br><span class="line">            use: [<span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span>],</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            test: <span class="hljs-regexp">/\.less$/i</span>, <span class="hljs-comment">//配置less</span></span><br><span class="line">            use: [<span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span>, <span class="hljs-string">'less-loader'</span>]</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            test: <span class="hljs-regexp">/\.scss$/i</span>, <span class="hljs-comment">//配置sass</span></span><br><span class="line">            use: [<span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span>, <span class="hljs-string">'sass-loader'</span>]</span><br><span class="line">        &#125;],</span><br><span class="line">    &#125;,</span><br><span class="line">    devServer: &#123; <span class="hljs-comment">//配置webpack-dev-server</span></span><br><span class="line">        open: <span class="hljs-literal">true</span>, <span class="hljs-comment">//是否打开浏览器</span></span><br><span class="line">        contentBase: <span class="hljs-string">'src'</span>, <span class="hljs-comment">//指定托管的目录</span></span><br><span class="line">        hot: <span class="hljs-literal">true</span>, <span class="hljs-comment">//是否启用热更新</span></span><br><span class="line">        port: <span class="hljs-number">2000</span> <span class="hljs-comment">//代理的端口</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="hljs-string">'development'</span>,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="hljs-keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">            template: path.join(__dirname, <span class="hljs-string">'./src/index.html'</span>), <span class="hljs-comment">//指定模板文件的目录</span></span><br><span class="line">            filename: <span class="hljs-string">'index.html'</span> <span class="hljs-comment">//设置生成的页面名称</span></span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><hr><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><hr><ul><li><p>在<code>webpack4.0</code>以后，webpack新增了<code>mode</code>属性 打包命令有所变化 <code>webpack 要打包的文件 -o 打包生成存放文件的路径</code></p></li><li><p>而且在<code>package.json</code>文件中，需要配置如下代码：</p><figure class="highlight 1c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">"scripts"</span>: &#123;</span><br><span class="line">   <span class="hljs-string">"dev"</span>: <span class="hljs-string">"webpack --mode development"</span>,  <span class="hljs-comment">// 开发环境</span></span><br><span class="line">    <span class="hljs-string">"build"</span>: <span class="hljs-string">"webpack --mode production"</span>,  <span class="hljs-comment">// 生产环境</span></span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><ul><li>在<code>webpack.config.js</code>中，同样需要配置如下代码：<figure class="highlight groovy hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">mode:</span> <span class="hljs-string">'development'</span> <span class="hljs-comment">// 设置mode</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果需要下载指定版本，输入以下命令：</p></li><li><p><code>npm i -D webpack@3</code> // 3： webpack版本3最新</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在配置webpack打包项目时，有些必要的插件安装与配置，才能保证项目完整的被打包，这里总结了一些基础的webpack配置，可以满足基础的打包运行要求。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://zhongyuehui.github.io/categories/Vue/"/>
    
    
      <category term="webpack" scheme="https://zhongyuehui.github.io/tags/webpack/"/>
    
  </entry>
  
</feed>
