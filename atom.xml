<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Just for fun</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhongyuehui.github.io/"/>
  <updated>2019-07-01T14:13:23.665Z</updated>
  <id>https://zhongyuehui.github.io/</id>
  
  <author>
    <name>zhong yuehui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git的使用</title>
    <link href="https://zhongyuehui.github.io/2019/07/01/git%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://zhongyuehui.github.io/2019/07/01/git的使用/</id>
    <published>2019-07-01T13:47:23.000Z</published>
    <updated>2019-07-01T14:13:23.665Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>我们在平时的项目开发中，难免会用到一些托管工具来托管自己的代码，这样可以更好的和别人和分享自己项目和合作开发项目，这里就简单介绍一下git的使用。</p></blockquote><hr><a id="more"></a><h2 id="Git基本操作"><a href="#Git基本操作" class="headerlink" title="Git基本操作"></a>Git基本操作</h2><hr><h3 id="上传本地文件-工作区-到暂存区"><a href="#上传本地文件-工作区-到暂存区" class="headerlink" title="上传本地文件(工作区)到暂存区"></a>上传本地文件(工作区)到暂存区</h3><hr><ul><li><p><code>git status</code>先初始化项目(状态)，检查是否在工作区域还是暂存区</p></li><li><p><code>git add 文件名</code>将文件上传到暂存区</p></li></ul><hr><h3 id="将暂存区的文件上传到git仓库中"><a href="#将暂存区的文件上传到git仓库中" class="headerlink" title="将暂存区的文件上传到git仓库中"></a>将暂存区的文件上传到git仓库中</h3><hr><ul><li><p><code>git status</code>初始化暂存区的项目，查看是否含有相同的内容</p></li><li><p><code>git commit -m &quot;提交的描述&quot;</code>，项目的说明</p></li><li><p><code>git status</code> 查看文件状态</p></li><li><p><strong>注意：</strong>使用 <code>git commit -m &#39;&#39;</code> 是一次性将文件放到分支，使用<code>git add</code>是将文件添加到暂存区(Stage), git是版本控制工具，并不是文件控制工具，我们只有使用<code>git add</code>添加到暂存区的文件，再使用<code>git commit -m &#39;&#39;</code>才能将文件提交到分支，如果你修改了文件直接提交到分支，这个是不能修改的，不信你可以使用<code>git diff HEAD -- &#39;文件名&#39;</code>查看工作区和版面本库中最新版本的区别 ，没有使用<code>git add &#39;&#39;</code> 的文件内容没有并没有添加到版本库(commit)中</p></li></ul><hr><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ul><li>基本流程图<br><img src="https://s2.ax1x.com/2019/06/30/Z39gFP.png" alt="GitHub基本流程"></li></ul><hr><h2 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h2><hr><p><strong>设置用户名</strong>:<code>git config --global user.name &#39;GitHub的用户名&#39;</code></p><h2 id="设置用户名的邮箱：git-config-global-user-email-39-设置用户名的邮箱-39"><a href="#设置用户名的邮箱：git-config-global-user-email-39-设置用户名的邮箱-39" class="headerlink" title="设置用户名的邮箱：git config --global user.email &#39;设置用户名的邮箱&#39;"></a><strong>设置用户名的邮箱</strong>：<code>git config --global user.email &#39;设置用户名的邮箱&#39;</code></h2><h2 id="初始化新的git仓库"><a href="#初始化新的git仓库" class="headerlink" title="初始化新的git仓库"></a>初始化新的git仓库</h2><hr><ul><li>创建新的文件夹 也可以在命令行 <code>mkdir 文件夹名字</code>进行创建</li><li>进入文件夹 ，命令行<code>cd 文件夹名</code></li><li>初始化仓库, 命令行 <code>git init</code> ，会生成一个<code>.git</code>的文件夹，若没有在文件夹下点击查看，打开显示隐藏的项目<br><img src="https://s2.ax1x.com/2019/06/30/Z3iPxO.png" alt="查看隐藏文件"></li></ul><hr><h2 id="项目的管理"><a href="#项目的管理" class="headerlink" title="项目的管理"></a>项目的管理</h2><hr><h3 id="上传文件项目-使用流程"><a href="#上传文件项目-使用流程" class="headerlink" title="上传文件项目(使用流程)"></a>上传文件项目(使用流程)</h3><hr><ul><li>在项目文件夹中，创建文件，也可以在命令行中使用<code>touch 文件名</code></li><li><strong>注意</strong>：需要带后缀名</li><li>然后使用 <code>git status</code>可以查看文件是否在暂存区域中(没有是红色)</li><li>如果没有，使用<code>git add &#39;文件名&#39;</code>即可将文件名上传到暂存区中</li><li><code>git status</code>查看文件是否已经存在于暂存区(存在是绿色)</li></ul><hr><h3 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h3><hr><ul><li>命令行直接 <code>vi/vim 文件名</code>即可输入内容，也可以鼠标右键编辑</li><li>修改后 <code>git status</code>，发现文件更改后，又变成红色，需要重新提交</li><li><code>git diff</code>可以查看修改了什么内容</li><li><code>git add 文件名</code>提交即可</li><li><code>git status</code>发现没有文件可以提交，则提交成功</li></ul><hr><h4 id="撤销修改-例如撤回reademe-txt文件的修改"><a href="#撤销修改-例如撤回reademe-txt文件的修改" class="headerlink" title="撤销修改(例如撤回reademe.txt文件的修改)"></a>撤销修改(例如撤回reademe.txt文件的修改)</h4><hr><ul><li>我们再修改文件时可能由于出错误修改，我们可以及时的将文件返回到上一个未修改的版本，修改文件后 <code>git status</code>也可以发现git会提示你使用<code>git checkout -- &lt;file&gt;</code>可以丢弃工作区的修改</li><li>当然，命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：<ul><li>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li><li>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li></ul></li><li>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</li></ul><hr><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><hr><ul><li>在命令行<code>rm -rf 文件名</code>(强制删除，不建议使用)或者<code>rm 文件名</code>(普通删除),<code>rm -l 文件名</code>(删除三个以上提示),<code>rm -i 文件名</code>(删除前提示，可以确认删除文件是否选择正确)，或者在鼠标右键删除</li><li><strong>注意</strong>：上面的步骤是在工作区删除</li><li><code>git rm 文件名</code>:是在git中删除文件</li><li><code>git commit -m &#39;提交描述&#39;</code>，如果需要删除某个文件，则需要<code>rm 文件</code> 再 <code>git rm 文件</code> 再 <code>git commit -m &#39;提交描述&#39;</code>,这样就可以完整的删除这个文件了</li><li><strong>注意</strong>：使用<code>git log</code> 可以查看每次版本的修改历史，如果你嫌弃信息过多眼花缭乱，也可以使用<code>git log --pretty=oneline</code>查看，其中一大串的只是commit id(版本号)而已</li></ul><hr><h3 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h3><hr><ul><li>在git中，使用HEAD表示当前的版本，上个版本使用 <strong>(HEAD^)</strong>表示，上上版本使用 <strong>(HEAD^^)</strong>表示，如果是多个可以使用 <strong>(HEAD~N)</strong>表示</li><li>使用 <code>git reset --hard HEAD^</code>表示回退上一个版本，但是我们使用<code>git log</code>已经查看不到之前我们跳转过来的历史了，但是如果我们想还原，也还是有办法的，只要我们不关闭命令行窗口，找到之前的<strong>commit id</strong>,就可以回到未来的指定版本</li><li>使用<code>git reset --hard commit id</code> 后，可以查看是否回到上个版本了</li></ul><p><strong>注意：</strong> 使用commit id 时不需要全部填写 但是要精确到git能找到该文件</p><blockquote><p>如果我们回退到上一个版本后已经关闭了命令行又想回到最新版本怎么办？</p></blockquote><ul><li>在git中，提供了一个命令<code>git reflog</code>可以记录你的每一条命令</li></ul><hr><h2 id="git远程仓库"><a href="#git远程仓库" class="headerlink" title="git远程仓库"></a>git远程仓库</h2><hr><h3 id="添加远程仓库-如：test"><a href="#添加远程仓库-如：test" class="headerlink" title="添加远程仓库(如：test)"></a>添加远程仓库(如：test)</h3><hr><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><hr><h5 id="创建ssh（如果已经创建关联请忽略）"><a href="#创建ssh（如果已经创建关联请忽略）" class="headerlink" title="创建ssh（如果已经创建关联请忽略）"></a>创建ssh（如果已经创建关联请忽略）</h5><ul><li>在命令行下<code>ssh-keygen -t rsa -C &quot;898542119@qq.com&quot;</code>,然后一路回车即可</li><li>在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人</li><li>登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容即可，这样我们的关联就已经做好了</li></ul><hr><h4 id="远程添加文件到仓库中"><a href="#远程添加文件到仓库中" class="headerlink" title="远程添加文件到仓库中"></a>远程添加文件到仓库中</h4><ul><li>登陆GitHub，点击 <strong>“Create a new repo”</strong>，在<strong>Repository name</strong> 填入仓库名称，其他的默认即可</li><li>在你本地的仓库中运行如下：<code>git remote add origin git@github.com:ZhongYueHui/test.git</code>其中ZhongYueHui是GitHub的名字,test仓库的名字</li><li>然后使用 <code>git push -u origin master</code>就可以将文件提交到GitHub上了，其实就是将本地分支 master 推送到远程，这样远程的仓库和本地就一样了</li><li>从现在开始，只要你对文件做了修改，就可以使用<code>git push origin master</code>将最新的修改提交到版本库了</li><li><strong>注意：</strong>如果第一次clone或者push会弹出如下警告,输入yes即可 <figure class="highlight vbnet hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity <span class="hljs-keyword">of</span> host <span class="hljs-comment">'github.com (xx.xx.xx.xx)' can't be established.</span></span><br><span class="line">RSA <span class="hljs-keyword">key</span> fingerprint <span class="hljs-keyword">is</span> xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want <span class="hljs-keyword">to</span> <span class="hljs-keyword">continue</span> connecting (yes/no)?</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="从远程克隆仓库"><a href="#从远程克隆仓库" class="headerlink" title="从远程克隆仓库"></a>从远程克隆仓库</h3><hr><ul><li>在命令行输入<code>git clone git@github.com:ZhongYueHui/gitskills.git</code>即可克隆<code>gitskills</code>仓库</li><li><strong>注意：</strong>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆,<br>Git支持多种协议，包括<code>https</code>，但通过<code>ssh</code>支持的原生<code>git协议</code>速度最快</li></ul><hr><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><hr><h3 id="创建和合并分支"><a href="#创建和合并分支" class="headerlink" title="创建和合并分支"></a>创建和合并分支</h3><ul><li><p>创建分支:<code>git checkout -b 分支名称</code>，<code>git checkout -b dev</code>相当于创建新分支并切换，相当于如下两条命令</p>  <figure class="highlight q hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch <span class="hljs-built_in">dev</span> <span class="hljs-comment">//创建分支</span></span><br><span class="line">git checkout <span class="hljs-built_in">dev</span> <span class="hljs-comment">//切换分支</span></span><br></pre></td></tr></table></figure></li><li><p>查看分支:<code>git branch</code>,会列出所有的分支，当前的分支会使用<code>*</code>标记</p></li><li><p>我们在<code>dev</code>分支下修改的文件在切换到<code>master</code>分支查看，发现并未修改，但是我们可以使用<code>git merge dev</code>将dev分支合并到当前的分支上(<code>master</code>)</p></li><li><p>合并完之后，我们就可以将<code>dev</code>分支删除了:<code>git branch -d dev</code>，使用<code>git branch</code>查看分支就只有<code>master</code> 了</p></li><li><p><strong>小结</strong>：</p>  <figure class="highlight fortran hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">查看分支：git branch</span><br><span class="line"></span><br><span class="line">创建分支：git branch &lt;<span class="hljs-keyword">name</span>&gt;</span><br><span class="line"></span><br><span class="line">切换分支：git checkout &lt;<span class="hljs-keyword">name</span>&gt;</span><br><span class="line"></span><br><span class="line">创建+切换分支：git checkout -b &lt;<span class="hljs-keyword">name</span>&gt;</span><br><span class="line"></span><br><span class="line">合并某分支到当前分支：git <span class="hljs-built_in">merge</span> &lt;<span class="hljs-keyword">name</span>&gt;</span><br><span class="line"></span><br><span class="line">删除分支：git branch -d &lt;<span class="hljs-keyword">name</span>&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="分支之间的冲突"><a href="#分支之间的冲突" class="headerlink" title="分支之间的冲突"></a>分支之间的冲突</h3><ul><li>假设我们在创建了一个分支<strong>feature1</strong>，我们在feature1上修改reademe.txt文件，然后<code>git add  reademe.txt</code>和<code>git commit -m &#39;&#39;</code>，然后切换到<code>master</code>中同样对reademe.txt做出修改，然后<code>git add  reademe.txt</code>和`git commit -m</li><li>这样，我们想合并<strong>feature1</strong>分支就会出异常，Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改自己想要的内容和删除标记后保存：这个时候我们需要将内容统一到和<strong>feature1</strong>，然后<code>git add  reademe.txt</code>和<code>git commit -m</code>即可</li><li>我们还可以使用<code>git log --graph --pretty=oneline --abbrev-commit</code>查看分支合并情况<h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900005860592480" target="_blank" rel="noopener">分支管理策略</a></h3></li><li>合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用<code>Fastforward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息</li><li>假设我们在创建了一个分支<strong>feature1</strong>，我们在feature1上修改reademe.txt文件，然后<code>git add  reademe.txt</code>和<code>git commit -m &#39;&#39;</code>，然后切换到<code>master</code>中,准备合并<strong>feature1</strong>，使用=&gt;<code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>进行合并，注意 <code>--no-ff</code>表示的是<strong>禁用</strong><code>Fast forward</code></li><li><code>git log --graph --pretty=oneline --abbrev-commit</code>查看分支历史<figure class="highlight coq hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> *   e1e9c68 (HEAD -&gt; master) merge <span class="hljs-built_in">with</span> no-ff</span><br><span class="line">|<span class="hljs-type">\  </span></span><br><span class="line"><span class="hljs-type">| * f52c633</span> (dev) add merge</span><br><span class="line">|<span class="hljs-type">/  </span></span><br><span class="line"><span class="hljs-type">*   cf810e4</span> conflict fixed</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure></li></ul><h3 id="BUG分支"><a href="#BUG分支" class="headerlink" title="BUG分支"></a>BUG分支</h3><ul><li><p>我们可能在开发中出现一些紧急的BUG需要及时修复，你可能马上想创建一个BUG修复的文件，但是你突然发现自己手中的 工作还没做完，无法提交，这时候就需要用到Git提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作</p></li><li><p>我们使用<code>git stash</code>来暂停自己的工作现场，然后创建自己的<code>bug修复分区</code>，然后<code>git add &#39;&#39;</code>,<code>git commit -m &#39;&#39;</code>后合并到master分区中，这样BUG修复完毕了，删除bug修复分区即可（<code>git merge --no-ff -m &quot;删除描述&quot; 分区名</code>）</p></li><li><p>修复完后就可以切换到自己原来的分区继续工作了，但是我们需要使用<code>git stash list</code>查看，使用<code>git status</code>查看是干净的，然后我们可以使用<code>git stash apply</code>恢复，但是恢复后，<code>stash</code>内容并不删除，你需要用<code>git stash drop</code>来删除；<br>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容(就是暂停的记录)也删了,再使用<code>git stash list</code>就是干净的了                                                                    </p>  <figure class="highlight applescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stash@&#123;<span class="hljs-number">0</span>&#125;: WIP <span class="hljs-keyword">on</span> master: <span class="hljs-number">54</span>a255b git tracks changes</span><br></pre></td></tr></table></figure></li><li><p>你可以多次使用<code>git stash list</code>，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的<code>stash</code>，用命令：<code>git stash apply stash@{0}</code></p><h3 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h3></li><li><p>用于实验的项目功能，不能直接用于主分支，容易乱掉，所以最好新建一个分支进行实验性测试</p></li><li><p>新建一个分区后，新建一个增加功能的文件，<code>git add &#39;&#39;</code>,<code>git commit -m &#39;&#39;</code>后<code>git checkout dev</code>合并到dev中，如果此时想删除这个功能文件，我们此时就应该删除该文件<code>git branch -d feature-vulcan</code>，如果提示还没有合并，那么直接将<code>-d</code>换成<code>-D</code>即可强制删除该分区</p>  <figure class="highlight subunit hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">error: </span>The branch 'feature-vulcan' is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run 'git branch -D feature-vulcan'.</span><br></pre></td></tr></table></figure></li></ul><h3 id="远程同步分支"><a href="#远程同步分支" class="headerlink" title="远程同步分支"></a>远程同步分支</h3><ul><li>当我们需要多个人同时开发项目时，我们应该将本地的分支推送到远程分支上</li><li>当我们从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。要查看远程库的信息，用<code>git remote</code>或者<code>git remote -v</code>   <figure class="highlight stylus hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin  git@github<span class="hljs-selector-class">.com</span>:ZhongYueHui/learngit<span class="hljs-selector-class">.git</span> (fetch)</span><br><span class="line">origin  git@github<span class="hljs-selector-class">.com</span>:ZhongYueHui/learngit<span class="hljs-selector-class">.git</span> (push)</span><br></pre></td></tr></table></figure></li></ul><h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h4><ul><li><code>git push origin master</code>将本地分支推送到远程分支上</li><li>如果推送<code>dev</code>这个分区，<code>git push origin dev</code>即可</li><li><strong>说明：</strong> 并不是每个分支都需要被推送，<ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步</li><li><code>bug</code>分支只用于在本地修复bug，就没必要推到远程了，除非上级要求</li><li><code>feature</code>分支是否推到远程，取决于你是否和你的项目伙伴<h4 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h4></li></ul></li><li>如果你和你的团队再开发一个项目时，你的一个伙伴推送文件到<code>dev</code>分支上，并且推送到远程上，这个时候如果你也推送(push)<code>dev</code>到远程，这个是时候就会出错，解决办法也是和分支之间的冲突一样处理</li><li><strong>小结：</strong><ul><li>首先，可以试图用git push origin <branch-name>推送自己的修改；</branch-name></li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！</branch-name></li><li>如果git pull提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code><h4 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h4></li></ul></li><li>我们在多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后<code>push</code>的伙伴不得不先<code>pull</code>，在本地合并，然后才能<code>push</code>成功。每次合并再<code>push</code>后，分支变成的很乱</li><li>使用<code>git rebase</code>可以解决这个问题，帮我们把分支整理成一条直线<h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3></li><li>方便我们查找，虽然git有 <code>commit</code>，但是这个东西是一堆进制数，不方便我们查找，所以我们设置标签的形式，方便查找</li><li>在你想要创建标签的分支上,输入<code>git tag &lt;name&gt;</code>添加标签，使用<code>git tag</code>可以查看所有标签给git</li><li>如果之前忘记了添加标签，找到历史的<code>commit id</code>打上就可以，<code>git log --pretty=oneline --abbrev-commit</code></li><li>比方说要对<code>add merge</code>这次提交打标签，它对应的<code>commit id</code>是<code>f52c633</code>，敲入命令：<code>git tag v0.9 f52c633</code></li><li>查看所有的书签：<code>git show &lt;tagname&gt;</code><ul><li>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</li><li>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</li><li>命令<code>git tag</code>可以查看所有标签<h4 id="操作书签"><a href="#操作书签" class="headerlink" title="操作书签"></a>操作书签</h4></li></ul></li><li>修改书签：<code>git tag -d v0.1</code></li><li>将标签推送到远程：<code>git push origin &lt;tagname&gt;</code>或者<code>git push origin --tags</code>一次性将推送未推送的书签</li><li>删除远程的书签：<ul><li>先删除本地的书签：<code>git tag -d v0.9</code></li><li>再从远程删除：<code>git push origin :refs/tags/v0.9</code></li></ul></li><li><strong>总结：</strong><ul><li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li><li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li><li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li><li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签</li><li></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;我们在平时的项目开发中，难免会用到一些托管工具来托管自己的代码，这样可以更好的和别人和分享自己项目和合作开发项目，这里就简单介绍一下git的使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Git" scheme="https://zhongyuehui.github.io/categories/Git/"/>
    
    
      <category term="git" scheme="https://zhongyuehui.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>express中的中间件</title>
    <link href="https://zhongyuehui.github.io/2019/06/24/express%E4%B8%AD%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://zhongyuehui.github.io/2019/06/24/express中的中间件/</id>
    <published>2019-06-24T03:26:57.000Z</published>
    <updated>2019-06-25T07:34:44.497Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在Nodejs中的Express框架来说，中间件是一个比较抽象的概念，但是对于理解Nodejs的请求原理是非常重要的，这里简单的介绍了Nodejs中Express框架的中间件原理</p></blockquote><a id="more"></a><!-- toc --><hr><h3 id="中间件的原理"><a href="#中间件的原理" class="headerlink" title="中间件的原理"></a>中间件的原理</h3><hr><p><img src="https://i.loli.net/2019/06/24/5d1044327363a92295.png" alt></p><ul><li><p>就是相当于水经过一系列处理到用户的过程，中间不能跳过某些步骤或者调换某些步骤</p></li><li><p>下面使用一个代码来帮助我们更好的理解中间件的概念</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)</span><br><span class="line"><span class="hljs-keyword">const</span> app = express()</span><br><span class="line"><span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//这个就是中间件，中间件就是一个函数，函数有三个参数</span></span><br><span class="line"><span class="hljs-comment">//request 请求数据</span></span><br><span class="line"><span class="hljs-comment">//respone  响应数据</span></span><br><span class="line"><span class="hljs-comment">// next  表示继续执行下一个中间件，如果没有使用这个方法，那么下面就算有符合匹配项，都不会被执行</span></span><br><span class="line"><span class="hljs-comment">//这个表示所有请求都会经过这里,但是请求到这里时会停留，如果想要继续执行需要调用next方法</span></span><br><span class="line">app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">request, respone, next</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a'</span>)</span><br><span class="line">    next() <span class="hljs-comment">//需要继续执行</span></span><br><span class="line">&#125;)</span><br><span class="line">app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">request, respone, next</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b'</span>)</span><br><span class="line">        next()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="hljs-comment">//这个表示所有的get请求并且路径为 / 的请求会经过这个中间件</span></span><br><span class="line">app.get(<span class="hljs-string">'/'</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello World!'</span>)</span><br><span class="line">        <span class="hljs-comment">//如果此时不使用next方法，那么下面的get函数不会 被执行</span></span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="hljs-string">'/'</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="hljs-string">'Hello World!'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(port, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Example app listening on port port!`</span>))</span><br></pre></td></tr></table></figure></li><li><p>所以，我们在使用中间件时，都应该遵循这些规则，这样可以帮助我们更好的编写程序</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在Nodejs中的Express框架来说，中间件是一个比较抽象的概念，但是对于理解Nodejs的请求原理是非常重要的，这里简单的介绍了Nodejs中Express框架的中间件原理&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Nodejs" scheme="https://zhongyuehui.github.io/categories/Nodejs/"/>
    
    
      <category term="Express" scheme="https://zhongyuehui.github.io/tags/Express/"/>
    
  </entry>
  
  <entry>
    <title>webpack中引入vue</title>
    <link href="https://zhongyuehui.github.io/2019/06/23/webpack%E4%B8%AD%E5%BC%95%E5%85%A5vue/"/>
    <id>https://zhongyuehui.github.io/2019/06/23/webpack中引入vue/</id>
    <published>2019-06-23T15:04:31.000Z</published>
    <updated>2019-06-25T07:34:24.851Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在webpack使用vue，我们会遇到一些打包的问题，这个使用我们要使用打包工具来解决这个问题，以下是具体的一些说明和使用。</p></blockquote><a id="more"></a><!--toc--><hr><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><hr><ol><li><p>在webpack中，我们需要将所有的包在<code>main.js</code>这个入口文件中导入，在在我们安装<code>vue(npm i vue -D)</code>到本地时，我们在<code>main.js</code>导入这个包</p><figure class="highlight capnproto hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span></span><br></pre></td></tr></table></figure></li><li><p>会爆出以下异常： <code>You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.</code></p></li><li><p>以下的问题解释是：在webpack中使用 import Vue from “vue” 引入的 vue构造函数 功能是不完整的，它只提供了runtime-only 的方式，并没有提供 像网页中使用 script引入的那些功能</p></li></ol><ul><li><p>解决方式一：</p><ul><li>使用：<code>import Vue from &quot;../node_modules/vue/dist/vue&quot;</code>这种引入方式</li></ul></li><li><p>解决方式二：</p><ul><li><p>配置<code>webpack.config.js</code>文件，新增一个属性:<code>resolve</code>，在里面中还有一个属性:<code>alias</code>，配置如下</p><figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">resolve</span>: &#123;</span><br><span class="line">    <span class="hljs-attribute">alias</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-string">'vue$'</span>: <span class="hljs-string">'vue/dist/vue.esm.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这样使用<code>import Vue from &quot;vue&quot;</code>引入也不会报错了</p></li></ul></li></ul><hr><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><hr><ul><li>由于<code>webpack</code>是使用Node架构的，所以合法的Node语法都支持，当然，引入包的规则也是一致的</li><li>如下：</li><li>Nodejs中包的查找规则:<ol><li>找项目根目录中是否有安装 node_modules 的文件夹</li><li>在node_modules 中根据包名，找对应的 vue 文件夹</li><li>在 vue中，找到一个叫packahe.json的配置文件</li><li>在package.json 文件夹中，查找一个 main 属性，这个属性指定了这个包被加载时的入口文件</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在webpack使用vue，我们会遇到一些打包的问题，这个使用我们要使用打包工具来解决这个问题，以下是具体的一些说明和使用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://zhongyuehui.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://zhongyuehui.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>webpack打包图片</title>
    <link href="https://zhongyuehui.github.io/2019/06/22/webpack%E6%89%93%E5%8C%85%E5%9B%BE%E7%89%87/"/>
    <id>https://zhongyuehui.github.io/2019/06/22/webpack打包图片/</id>
    <published>2019-06-22T12:15:21.000Z</published>
    <updated>2019-06-25T06:05:09.448Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在webpack中，我们使用其打包一些项目的时候，经常会遇到图片，但是如果直接打包图片则会抛出异常，以下是打包图片的一些详细配置文件和步骤</p></blockquote><a id="more"></a> <hr><h3 id="使用webpack打包图片"><a href="#使用webpack打包图片" class="headerlink" title="使用webpack打包图片"></a>使用webpack打包图片</h3><hr><ul><li><p>在平常中，我们在设置style中使用<code>background:url</code> 可以引入背景图片，在前面我们已经学会如何打包<code>css、less、scss</code>文件</p></li><li><p>安装<code>url-loader</code>和其依赖<code>file-loader</code></p></li><li><p><code>cnpm install url-loader file-loader -D</code></p></li><li><p>使用<code>file-loader</code>进行图片的打包</p></li><li><p>在webpack.config.js中配置，在与其他配置下添加如下即可</p></li><li><figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            <span class="hljs-attribute">test</span>: /\.jpg|png|gif|bmp|jpeg/, //配置图片</span><br><span class="line">            use: [<span class="hljs-string">'file-loader'</span>]</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>可以简写成如下：</p><figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            <span class="hljs-attribute">test</span>: /\.(jpg|png|gif|bmp|jpeg)/, //配置图片打包的格式</span><br><span class="line">            loader: <span class="hljs-string">'file-loader'</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>如果想要打包出来的图片不改变名字和格式，只需添加<code>options</code>即可</p><pre><code><figure class="highlight less hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            <span class="hljs-attribute">test</span>: /\.(jpg|png|gif|bmp|jpeg)/, <span class="hljs-comment">//配置图片打包的格式</span></span><br><span class="line">            <span class="hljs-attribute">loader</span>: <span class="hljs-string">'file-loader'</span></span><br><span class="line">            <span class="hljs-attribute">options</span>: &#123; <span class="hljs-comment">//[name]表示名字,[ext]表示格式，而name属性其实就是图片打包后的路径</span></span><br><span class="line">                <span class="hljs-attribute">name</span>: <span class="hljs-string">'images/[name].[ext]'</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>除了使用file-loader对图片进行打包处理外，我们同样也可以使用url-loader代替，另外我们还可以对小于某个大小的图片进行base64格式的转化处理。</p></li><li><p>使用<code>url-loader</code>打包</p><figure class="highlight clojure hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.(<span class="hljs-name">png</span>|jpg|gif|svg)$/,</span><br><span class="line">    loader: 'url-loader',</span><br><span class="line">    options: &#123;</span><br><span class="line">        name: './images/[name].[ext]',</span><br><span class="line">        limit: <span class="hljs-number">8192</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这里limit属性的作用就是将小于8192B（8.192K）大小的图片转成base64格式，而大于这个大小的图片将会以file-loader的方式进行打包处理</p></li><li><p><strong>注意</strong>：如果不写limit属性，那么url-loader就会默认将所有图片转成base64</p></li><li><p>这样打包出来的图片会自动转换成<code>base64</code>,但是我们多数是将小图片转成base64，而大图片不进行转换</p></li><li><p>而对于有些图片在不同路径下，但是文件名字一样时，我们需要在<code>name:</code>属性中增加<code>hash</code>值：定义[hash:8]定义 8位hash值最多32位，这样图片就不会存在不同</p>  <figure class="highlight less hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            <span class="hljs-attribute">test</span>: /\.(jpg|png|gif|bmp|jpeg)/, <span class="hljs-comment">//配置图片</span></span><br><span class="line">            <span class="hljs-attribute">loader</span>: <span class="hljs-string">'url-loader'</span>, <span class="hljs-comment">//在这里时，只有一个我们可以简化 loader，使用use则会报错</span></span><br><span class="line">            <span class="hljs-attribute">options</span>: &#123;</span><br><span class="line">                <span class="hljs-attribute">limit</span>: <span class="hljs-number">2000</span>, <span class="hljs-comment">//limit 的值单位是 Byte ，如果图片小于limit的值，则转成base64格式的字符串，如果大于，则不转</span></span><br><span class="line">                <span class="hljs-attribute">name</span>: <span class="hljs-string">'[hash:8]-[name].[ext]'</span> <span class="hljs-comment">//这是将文件名原样输出[name]指的是图片名，[ext]是图片格式，</span></span><br><span class="line">                    <span class="hljs-comment">//[hash:8]表示生成8位hash值，否则在不同文件夹下同名图片会失效，用来区分</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在webpack中，我们使用其打包一些项目的时候，经常会遇到图片，但是如果直接打包图片则会抛出异常，以下是打包图片的一些详细配置文件和步骤&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://zhongyuehui.github.io/categories/Vue/"/>
    
    
      <category term="webpack" scheme="https://zhongyuehui.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack配置的一些总结</title>
    <link href="https://zhongyuehui.github.io/2019/06/22/webpack%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <id>https://zhongyuehui.github.io/2019/06/22/webpack配置的一些总结/</id>
    <published>2019-06-22T09:07:14.000Z</published>
    <updated>2019-06-25T07:33:31.648Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在配置webpack打包项目时，有些必要的插件安装与配置，才能保证项目完整的被打包，这里总结了一些基础的webpack配置，可以满足基础的打包运行要求。</p></blockquote><a id="more"></a><!-- toc --><hr><h2 id="全局安装webpack"><a href="#全局安装webpack" class="headerlink" title="全局安装webpack"></a>全局安装webpack</h2><hr><ul><li><p><code>npm  install webpack -g</code></p><h2 id="生成package-json"><a href="#生成package-json" class="headerlink" title="生成package.json"></a>生成package.json</h2></li><li><p><code>npm init -y</code></p><h2 id="安装webpack-dev-server到本地"><a href="#安装webpack-dev-server到本地" class="headerlink" title="安装webpack-dev-server到本地"></a>安装webpack-dev-server到本地</h2></li><li><p><code>npm install webpack-dev-server -D</code></p></li><li><p>仍然需要在本地安装webpack作为webpack-dev-server的依赖</p></li><li><p><code>npm install  webpack -D</code></p><h3 id="配置webpack-config-js文件"><a href="#配置webpack-config-js文件" class="headerlink" title="配置webpack.config.js文件"></a>配置webpack.config.js文件</h3></li><li><p>创建webpack.config.js文件</p></li><li><p>配置文件出入口</p><figure class="highlight lasso hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//由于webpack是由Nodejs构建的，所以任何的Nodejs语法都支持</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//引入路径模块</span></span><br><span class="line"><span class="hljs-built_in">var</span> path = <span class="hljs-keyword">require</span>(<span class="hljs-string">'path'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//当以命令形式运行webpack或者webpack-dev-server的时候，工具会发现，我们没用提供要打包的文件入口和出口命令</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//此时，就会检查项目根目录中的配置文件 webpack.config.js 并读取这个文件，就拿到了导出的这个配置对象，然后根据对象进行打包</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//向外暴露出这个对象</span></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: path.<span class="hljs-keyword">join</span>(__dirname, <span class="hljs-string">'./src/main.js'</span>) <span class="hljs-comment">//入口文件，需要打包的文件</span></span><br><span class="line">        ,</span><br><span class="line">    output: &#123; <span class="hljs-comment">//出口文件，需要打包到哪里去</span></span><br><span class="line">        path: path.<span class="hljs-keyword">join</span>(__dirname, <span class="hljs-string">'./dist/bundle.js'</span>) <span class="hljs-comment">//输出路径</span></span><br><span class="line">            ,</span><br><span class="line">        filename: <span class="hljs-string">'bundle.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="hljs-string">'development'</span>, <span class="hljs-comment">//设置mode，在4.0新增</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>配置一些功能：在webpack.config.js中配置</p><figure class="highlight less hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="hljs-attribute">devServer</span>: &#123; <span class="hljs-comment">//配置webpack-dev-server</span></span><br><span class="line">    <span class="hljs-attribute">open</span>: true, <span class="hljs-comment">//是否打开浏览器</span></span><br><span class="line">    <span class="hljs-attribute">contentBase</span>: <span class="hljs-string">'src'</span>, <span class="hljs-comment">//指定托管的目录</span></span><br><span class="line">    <span class="hljs-attribute">hot</span>: true, <span class="hljs-comment">//是否启用热更新</span></span><br><span class="line">    <span class="hljs-attribute">port</span>: <span class="hljs-number">6000</span> <span class="hljs-comment">//代理的端口</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>在<code>package.json</code>中配置</p>  <figure class="highlight brainfuck hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">"script":&#123;</span></span><br><span class="line"><span class="hljs-comment">"start:dev":</span> <span class="hljs-comment">"webpack</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">open</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">port</span> <span class="hljs-comment">3000</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">contentBase</span> <span class="hljs-comment">src</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">hot"</span></span><br><span class="line"><span class="hljs-comment">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>需要将打包好的文件从虚拟内存中传入过来</p></li></ul><hr><h3 id="安装html-webpack-plugin"><a href="#安装html-webpack-plugin" class="headerlink" title="安装html-webpack-plugin"></a>安装html-webpack-plugin</h3><hr><ul><li><code>npm install html-webpack-plugin -D</code></li><li>在<code>webpack.config.js</code>中配置这个插件</li><li>作用：<ul><li>在内存中，根据只当的模板页面，生成一份内存中的首页，同时把打包好的bundle.js注入到页面底部</li><li>如果需要配置插件，需要在导出的对象中挂载一个 plugins:[]</li><li>注意：所有的第三方插件都在 <code>plugins:[]</code>中配置</li><li>与entry、output同级<figure class="highlight less hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attribute">plugins</span>: [</span><br><span class="line">       new htmlWebpackPlugin(&#123;</span><br><span class="line">           <span class="hljs-attribute">template</span>: path.join(__dirname, <span class="hljs-string">'./src/index.html'</span>), <span class="hljs-comment">//指定模板文件的目录</span></span><br><span class="line">           <span class="hljs-attribute">filename</span>: <span class="hljs-string">'index.html'</span> <span class="hljs-comment">//设置生成的页面名称</span></span><br><span class="line"></span><br><span class="line">       &#125;)</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="配置css-loader、less-loader、sass-loader"><a href="#配置css-loader、less-loader、sass-loader" class="headerlink" title="配置css-loader、less-loader、sass-loader"></a>配置css-loader、less-loader、sass-loader</h3><hr><ul><li>在main.js中引入css文件</li><li>import ‘./css/style.css’ <ul><li>安装css-loader插件：<code>npm install  css-loader style-loader --save-dev</code></li></ul></li><li>import ‘./css/style.less’ <ul><li>安装css-loader插件：<code>npm install less-loader less --save-dev</code></li></ul></li><li>import ‘./css/style.sass’ <ul><li>安装css-loader插件：<code>npm install sass-loader node-sass --save-dev</code></li></ul></li></ul><hr><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><hr><ul><li><p>在webpack.config.js配置sass</p></li><li><p><strong>注意</strong>：使用<code>npm</code>命令时安装<code>node-sass</code>可能会报错，无法打包，此时建议切换成<code>cnpm</code></p></li><li><p>切换方法 cmd运行<code>nrm ls</code>查看,然后切换<code>nrm use cnpm</code>即可，但是前提应该先在全局中安装<code>nrm</code></p>  <figure class="highlight openscad hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">module</span>.<span class="hljs-title">exports</span> =</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">module</span>: &#123;</span></span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: /\.scss$/,</span><br><span class="line">            <span class="hljs-keyword">use</span>: [</span><br><span class="line">                <span class="hljs-string">"style-loader"</span>, <span class="hljs-comment">// creates style nodes from JS strings</span></span><br><span class="line">                <span class="hljs-string">"css-loader"</span>, <span class="hljs-comment">// translates CSS into CommonJS</span></span><br><span class="line">                <span class="hljs-string">"sass-loader"</span> <span class="hljs-comment">// compiles Sass to CSS, using Node Sass by default</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在webpack.config.js配置css</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="hljs-keyword">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="hljs-regexp">/\.css$/i</span>,</span><br><span class="line">        use: [<span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在webpack.config.js配置less</p>  <figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="hljs-keyword">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="hljs-regexp">/\.less$/</span>,</span><br><span class="line">        loader: <span class="hljs-string">'less-loader'</span>, <span class="hljs-comment">// compiles Less to CSS</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="配置好基本的webpack-config-js文件"><a href="#配置好基本的webpack-config-js文件" class="headerlink" title="配置好基本的webpack.config.js文件"></a>配置好基本的webpack.config.js文件</h3><hr><pre><code><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//由于webpack是由Nodejs构建的，所以任何的Nodejs语法都支持</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//引入路径模块</span></span><br><span class="line"><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//在内存中，根据只当的模板页面，生成一份内存中的首页，同时把打包好的bundle.js注入到页面底部</span></span><br><span class="line"><span class="hljs-comment">//如果需要配置插件，需要在导出的对象中挂载一个 plugins:[]</span></span><br><span class="line"><span class="hljs-keyword">const</span> htmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//当以命令形式运行webpack或者webpack-dev-server的时候，工具会发现，我们没用提供要打包的文件入口和出口命令</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//此时，就会检查项目根目录中的配置文件 webpack.config.js 并读取这个文件，就拿到了导出的这个配置对象，然后根据对象进行打包</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//向外暴露出这个对象</span></span><br><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: path.join(__dirname, <span class="hljs-string">'./src/main.js'</span>) <span class="hljs-comment">//入口文件，需要打包的文件</span></span><br><span class="line">        ,</span><br><span class="line">    output: &#123; <span class="hljs-comment">//出口文件，需要打包到哪里去</span></span><br><span class="line">        path: path.join(__dirname, <span class="hljs-string">'./dist'</span>) <span class="hljs-comment">//输出路径</span></span><br><span class="line">            ,</span><br><span class="line">        filename: <span class="hljs-string">'bundle.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="hljs-keyword">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="hljs-regexp">/\.css$/i</span>, <span class="hljs-comment">//配置css</span></span><br><span class="line">            use: [<span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span>],</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            test: <span class="hljs-regexp">/\.less$/i</span>, <span class="hljs-comment">//配置less</span></span><br><span class="line">            use: [<span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span>, <span class="hljs-string">'less-loader'</span>]</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            test: <span class="hljs-regexp">/\.scss$/i</span>, <span class="hljs-comment">//配置sass</span></span><br><span class="line">            use: [<span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span>, <span class="hljs-string">'sass-loader'</span>]</span><br><span class="line">        &#125;],</span><br><span class="line">    &#125;,</span><br><span class="line">    devServer: &#123; <span class="hljs-comment">//配置webpack-dev-server</span></span><br><span class="line">        open: <span class="hljs-literal">true</span>, <span class="hljs-comment">//是否打开浏览器</span></span><br><span class="line">        contentBase: <span class="hljs-string">'src'</span>, <span class="hljs-comment">//指定托管的目录</span></span><br><span class="line">        hot: <span class="hljs-literal">true</span>, <span class="hljs-comment">//是否启用热更新</span></span><br><span class="line">        port: <span class="hljs-number">2000</span> <span class="hljs-comment">//代理的端口</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="hljs-string">'development'</span>,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="hljs-keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">            template: path.join(__dirname, <span class="hljs-string">'./src/index.html'</span>), <span class="hljs-comment">//指定模板文件的目录</span></span><br><span class="line">            filename: <span class="hljs-string">'index.html'</span> <span class="hljs-comment">//设置生成的页面名称</span></span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><hr><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><hr><ul><li><p>在<code>webpack4.0</code>以后，webpack新增了<code>mode</code>属性 打包命令有所变化 <code>webpack 要打包的文件 -o 打包生成存放文件的路径</code></p></li><li><p>而且在<code>package.json</code>文件中，需要配置如下代码：</p><figure class="highlight 1c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">"scripts"</span>: &#123;</span><br><span class="line">   <span class="hljs-string">"dev"</span>: <span class="hljs-string">"webpack --mode development"</span>,  <span class="hljs-comment">// 开发环境</span></span><br><span class="line">    <span class="hljs-string">"build"</span>: <span class="hljs-string">"webpack --mode production"</span>,  <span class="hljs-comment">// 生产环境</span></span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><ul><li>在<code>webpack.config.js</code>中，同样需要配置如下代码：<figure class="highlight groovy hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">mode:</span> <span class="hljs-string">'development'</span> <span class="hljs-comment">// 设置mode</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果需要下载指定版本，输入以下命令：</p></li><li><p><code>npm i -D webpack@3</code> // 3： webpack版本3最新</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在配置webpack打包项目时，有些必要的插件安装与配置，才能保证项目完整的被打包，这里总结了一些基础的webpack配置，可以满足基础的打包运行要求。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://zhongyuehui.github.io/categories/Vue/"/>
    
    
      <category term="webpack" scheme="https://zhongyuehui.github.io/tags/webpack/"/>
    
  </entry>
  
</feed>
