{"pages":[{"title":"关于我","text":"一个专注技术的修行者.","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Node中的path路径模块","text":"在Node中，有许多的模块,但是Node.js path 模块提供了一些用于处理文件路径的小工具 Path模块 引入 const path = require('path') path的一些方法path.basename(): 只有一个参数时 有两个参数时，且参数的后缀名相同时 有两个参数时，且参数的后缀名不相同时 总结： 一个参数时直接输出带后缀名的文件名 两个参数时第二个参数为第一个参数的后缀名时输出为不带后缀名的文件名 两个参数时第二个参数不是第一个参数的后缀名时输出仍是带后缀名的文件名path.dirname() 只输出目录 path.extname() 只输出后缀名 path.isAbsolute() 判断是否为绝对路径，返回一个布尔值 注意：文件路径前不能有空格 否则直接返回flase 拓展：绝对路径的两种方式 如：c:/a/b/c/index.js ，有磁盘符，相对于磁盘符的绝对路径 如：/a/b/c/index.js ，没有磁盘符，相对于当前磁盘下的绝对路径path.parse() 查看文件的详细信息 path.join() 路径拼接 在Node中，许多时候我们都需要用到路径模块，对文件路径的判断做出相应的响应","link":"/2019/07/07/Node中的path路径模块/"},{"title":"ES6中的模块导入与导出","text":"在 ES6 前， 实现模块化使用的是 RequireJS 或者 seaJS（分别是基于 AMD 规范的模块化库， 和基于 CMD 规范的模块化库）。ES6 引入了模块化，其设计思想是在编译时就能确定模块的依赖关系，以及输入和输出的变量。ES6 的模块化分为导出（export） @与导入（import）两个模块 导入与导出模块 在Nodejs中，提供了module.exports和exports向暴露(导出)成员接口，使用require('')使用导入的对象 ES6中的导入 在ES6中，也规定了导入和导出模块 ES6中导入模块使用 import 模块名称 from '模块标识符'的方式导入 或 import '标识路径' ES6中的导出 在ES6中，使用export default 和 export来暴露成员 两者导出的区别 使用export default: 来暴露成员时，在全局中，只允许定义一个export default 使用export来暴露成员时，可以定义多个export 两者导入的区别 在import 模块名称 from '模块标识符' 导入模块时，我们需要注意以下模块中是否同时使用了使用export default 和 export来暴露成员，如果只使用了export default 那么我们只需要自定义一个模块名称来接收数据即可 1234 export default { //导出 name: '张三', age: 16} 1import test from 'test' //引入 如果使用了export来暴露成员时，不管有没有使用export default 暴露成员，我们导出模块定义的成员名字和导入模块引入的名字必须一致，否则会出错 如果仅使用export暴露，我们只需要将成员名使用 { } 包括起来即可，且不能省略{ } 1export const a = 'text中的export' //导出 1import { a } from './test' //引入 ，不能省略 { } 如果我们同时使用了两种暴露方式或使用export定义了多个成员，只要按需导出即可 123456export default {name: '张三',age: 16 }export const test = 'text中的export'export const test2 = 'text2中的export' 1import test,{ test} from './text' //虽然定义了test2，但是我们可以根据需要不导出，导出在{}中加入即可 export导出时修改名称 我们发现使用export default 暴露时没有导入名称的规定，但是使用export暴露必须使用定义时的名字，其实我们可以使用 as 进行修改 1import test,{ test as a,test2 as b} from './text' 注意: ES6 的模块自动开启严格模式，不管你有没有在模块头部加上 use strict。 模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等 每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域 每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取","link":"/2019/07/09/ES6中的模块导入与导出/"},{"title":"TypeScript中的接口","text":"接口的作用，在面向对象编程中接口是一种规范的定义，它定义了行为和动作规范，在程序设计里面，接口起到了一种限制和规范的作用。接口定义了某一批类所需要遵守的规则，接口不关心这些类的内部状态数据，也不关心这些类里的方法细节，它只规定这批类里必须提供某些方法，提供这些方法的的类就可以满足实际需要，typescript的接口类似于Java，同时还增加了许多更灵活的接口类型，它包括属性、函数，可索引和类定义标准 TypeScript中的接口 对传入的参数进行约束 1234function getinfo(label:string): void { console.log(\"getinfo\");}getinfo(); //报错，提示需要传递一个参数 其实这个就是约束，就是规则 自定义方法传入参数对json进行约束 1234function getinfo(label: { name: string }): void { console.log(\"getinfo\");}getinfo({ name: \"zs\" }); //传入一个对象，且对象中第一个参数是name，还要string类型的数据 接口 行为和动作的规范，对批量方法进行约束 属性接口： 1234567891011interface FullName { firstName: string; secondName: string;}function printName(name: FullName) { console.log(name.firstName + \"---\" + name.secondName);}printName({ //使用这种方式传递只能传递interface定义好的属性 firstName: \"Mr\", secondName: \"Zhong\"}); //输出Mr Zhong 12345678910111213interface FullName { firstName: string; secondName: string;}function printName(name: FullName) { console.log(name.firstName + \"---\" + name.secondName + \"--\" + name.age);}let obj = { age: \"12\", firstName: \"Mr\", secondName: \"Zhong\"}; //使用外界定义对象传入的方式可以定义不同的属性但是必须有interface定义的属性printName(obj); //输出Mr Zhong 接口的可选属性 可选属性： 1234567891011interface FullName { firstName: string; secondName?: string; //定义可选属性}function printName(name: FullName) { console.log(name.firstName + \"---\" + name.secondName);}printName({ //可选属性可写可不写 firstName: \"firstname\"}); //输出Mr--undefined 属性类型封装的ajax 封装的ajax 12345678910111213141516171819202122232425262728interface Config { url: string; dataType: string; data?: string; type: string;}function ajax(config: Config) { var xhr = new XMLHttpRequest(); xhr.open(config.type, config.url, true); xhr.send(config.data); xhr.onreadystatechange = function() { if (xhr.readyState === 4) { if (xhr.status === 200) { if (config.dataType == \"json\") { console.log(JSON.parse(xhr.responseText)); } else { console.log(xhr.responseXML); } } } };}ajax({ url: \"http://a.itying.com/api/productlist\", //这个是api接口 dataType: \"json\", type: \"get\", data: \"name=zhangsan\"}); 函数类型的接口 加密的函数类型接口 1234567891011121314interface encrypt { //加密的函数类型接口 (key: string, value: string): string;}var md5: encrypt = function(key: string, value: string): string { return key + value; //真实的加密这里是经过一系列的算法进行加密，这里是模拟操作};console.log(md5(\"zhangsan\", \"14\")); //zhangsan14var info: encrypt = function(key: string, value: string): string { //这里继续使用加密接口 return key + \"---\" + value;};console.log(info(\"hello\", \"world\")); //hello--world 可索引的接口 对数组、对象的约束(不常用) 对数组: 12345interface UserArr { [index: number]: string; //下标是number，值是string}var arr: UserArr = [\"aaa\", \"bbb\"];console.log(arr[0]); //aaa 对对象： 12345interface UserArr { [index: string]: string;}var arr: UserArr = { name: \"张三\" };//name属性双引号可写可不写console.log(arr[\"name\"]); //张三 类类型接口 类类型接口 12345678910111213141516interface Animal { name: string; eat(str: string): void;}class Dog implements Animal { name: string; //必须定义 constructor(name: string) { this.name = name; } eat() { //必须定义 return `${this.name}爱吃粮食`; }}var d = new Dog(\"小黑\");console.log(d.eat()); //小黑爱吃粮食 12345678910111213141516171819202122232425262728interface Animal { name: string; eat(str: string): void;}class Dog implements Animal { name: string; //必须定义 constructor(name: string) { this.name = name; } eat() { //必须定义 return `${this.name}爱吃粮食`; }}var d = new Dog(\"小黑\");console.log(d.eat()); //小黑爱吃粮食class Cat implements Animal { name: string; constructor(name: string) { this.name = name; } eat(food: string) { return `${this.name}爱吃${food}`; }}var c = new Cat(\"小花猫\");console.log(c.eat(\"小老鼠\")); //小花猫爱吃小老鼠 接口的扩展 继承接口： 123456789101112131415161718192021interface Animal { eat(): void;}interface Person extends Animal { work(): void;}class Web implements Person { name: string; constructor(name: string) { this.name = name; } eat() { console.log(`${this.name}喜欢吃馒头`); } work() { console.log(`${this.name}是程序员`); }}var m = new Web(\"张三\");m.eat(); //张三喜欢吃馒头m.work(); //张三是程序员 继承类和继承接口 1234567891011121314151617181920212223242526272829303132import { closeSync } from \"fs\";interface Animal { eat(): void;}interface Person extends Animal { work(): void;}class Programmer { public name: string; constructor(name: string) { this.name = name; } coding(code: string) { console.log(this.name + code); }}class Web extends Programmer implements Person { //即继承programmer类 又使用继承的Person接口 constructor(name: string) { super(name); } eat() { console.log(`${this.name}喜欢吃馒头`); } work() { console.log(`${this.name}是程序员`); }}var m = new Web(\"张三\");m.eat(); //张三喜欢吃馒头m.work(); //张三是程序员 这些就是在Typescript中的接口的一些使用和说明。","link":"/2019/07/08/TypeScript中的接口/"},{"title":"TypeScript中的函数","text":"函数在 Javascript 中是一等一的公民 Typescript 中的函数TypeScript 中定义函数ES5 中定义函数的方式 1234&lt;!--函数声明--&gt;function getinfo() {return 'hello-world'} 1234&lt;!--匿名函数--&gt;var getinfo = function () {return 'hello-world'} ts 中的定义函数的方式 使用函数声明的方式，只定义函数的返回值类型 1234function getinfo():string { return 'This is getinfo'}getinfo() 注意：这样定义函数时，返回值的数据类型必须是 string,否则会报错 函数表达式的方式定义函数(匿名函数) 1234var getinfo=function():string { return 'This is getinfo'}getinfo() ts 中传递参数 使用函数声明定义函数，需要定义参数的类型和函数的返回值类型，且形参和实参类型与数据一一对应 12345function getinfo(name:string,age:number):string {return `${name}----${age}`}let value = getinfo('张三',12)console.log(value); 使用函数表达式(匿名函数)定义函数，传递参数，规则与使用函声明定义函数一样 12345let getinfo= function (name:string,age:number):string {return `${name}----${age}`}let value = getinfo('张三',40)console.log(value); 定义没有返回值的方法 1234function getinfo(name:string,age:number):void { console.log(`${name}----${age}`);}getinfo('张三',30) 定义可选参数 在 ES5 中，我们如果定义普通的形参时，形参个数和实参个数可以不一致，但是在 ts 中，不允许这样做 1234function getinfo(name:string,age:number):void {console.log(`${name}----年龄保密);} //这里提示报错了，没有将模板字符串写完getinfo('张三') 所以我们可以看到，如果写了形参，没有传递实参，就会编译错误,但是有时候我们并不传递，但是可以先定义预留位置 1234function getinfo(name:string,age?:number):void { age? console.log(`${name}----${age}`): console.log(`${name}---年龄保密`)}getinfo('张三',12) 在形参名后面加上 ? 表示对实参进行判断，如果有就使用，没有就不使用 定义默认参数 定义默认参数我们也可以不传递定义了默认值的参数 1234function getinfo(name:string,age:number=12):void {age? console.log(`${name}----${age}`): console.log(`${name}---年龄保密`)}getinfo('张三') //输出 张三 12 1234function getinfo(name:string,age:number=12):void {age? console.log(`${name}----${age}`): console.log(`${name}---年龄保密`)}getinfo('张三',45) //输出 张三 45 总结： 如果我们在形参中定义了默认的值的时候，你调用函数时可以不传递这个设有默认值的参数，他会使用默认值输出 如果我们在形参中定义了默认的值的时候，你调用函数时传递这个设有默认值的参数，他会使用你传递的值作为输出 剩余参数 当我们想要计算多个参数的值时，如下定义每一个参数会显得非常麻烦，所以我们需要换一种方式来解决这个累赘的定义 12345function sum(a:number,b:number,c:number,d:number):number{return a+b+c+d}var sun = sum(6,10,12,14)console.log(sun); 使用 ES6 中的三点运算符 123456789function sum(a:number,b:number,...result:number[]):number{var sum =a+bfor (var i = 0; i &lt; result.length; i++) { sum+=result[i]}return sum}var add = sum(1,2,3,4)console.log(add); 这样就不会有太多的重复代码 ts 函数重载 拓展： java 中方法的重载：重载指的是两个或者两个以上同名函数，但是它们的参数不一样，这时候会出现重载的情况 typescript 中的重载：通过为同一个函数提供多个函数类型定义来实现多种功能的目的 ts 中为了兼容 ES5 以及 ES6，重载的写法与 Java 有所区别 123456789&lt;!--在ES5中，如果出现了同名的方法，下面的会替换掉上面的--&gt;function a() {console.log('a')}function a() { console.log('b')}a() //输出 b 示例 1： 123456789function getinfo(age:number):numberfunction getinfo(name:string):stringfunction getinfo(str:any):any{ if(typeof str ==='string'){ return `我是:${str}` } return `我今年 ${str}岁`}console.log(getinfo('张三')) //我是张三 123456789function getinfo(age:number):numberfunction getinfo(name:string):stringfunction getinfo(str:any):any{ if(typeof str ==='string'){ return `我是:${str}` } return `我今年 ${str}岁`}console.log(getinfo(18)) //我今年18岁 示例 1 中，前面两个函数才是作为运行的方法，最后这个函数是判断调用哪个函数，判断的依据就是你传入的参数的数据类型和哪个方法中的形参的数据类型一致，那么他就调用哪个，如果传入的实参数据类型没有定义则报错 示例 2: 123456789101112function getinfo(name: string): string;function getinfo(name: string, age: number): string;function getinfo(name: string, age?: number): any { if (age) { return `我叫${name}，我今年：${age}岁`; } else { return `我叫:${name}`; }}console.log(getinfo(\"张三\")) //张三// getinfo(12) //报错，因为name是string ，只能在第二个参数传入number型数据console.log(getinfo(\"张三\", 12)); //我叫张三，我今年12岁 示例 2 中，我们定义了一个可选参数，当我们只有一个参数时他就调用第一个方法，如果有两个参数时，调用第二个方法 箭头函数 在 ES6 中，箭头函数的 this 指向的是上下文,但是在 ts 编译中采用的是严格模式，严格模式中禁止函数中的 this 指向 windowsetTimeout(() =&gt; { console.log(&quot;run&quot;); }, 3000) 以上就是我在学习中总结的一些关于函数的相关知识。","link":"/2019/07/08/TypeScript中的函数/"},{"title":"TypeScript中的类","text":"在 typescript 中，类的定义与 ES6的语法 稍有些差别，但是与 java,C++等更加相像了 Typescript 中的类 在 Typescript 中使用class关键字定义类 使用 class 定义类： 123456789101112131415class Person {name: string; //属性age: number;constructor(name: string, age: number) {//构造函数 实例化的时候触发的方法,相当于对实例化时传递的参数进行赋值this.name = name;this.age = age;}run() {console.log(this.name + \"---\" + this.age);}}var p = new Person(\"张三\", 12);p.run(); //张三 修改属性值 修改类中的属性值 1234567891011121314151617181920212223242526272829303132333435 class Person { name: string; //属性 constructor(name: string) { this.name = name; } getName(): void { console.log(this.name); } setName(name: string): void { this.name = name; } } var p = new Person(\"张三\"); p.getName(); //张三 p.setName(\"李四\"); //修改 name 的值 p.getName(); //李四 ```### 继承- 继承父类 ``` class Person { name: string; //属性 constructor(name: string) { this.name = name; } run() { console.log(this.name); } } var p = new Person(\"张三\"); class Web extends Person {} //如果直接继承，那么就是相当于复制了Person，继承了他的构造函数 var w = new Web(\"李四\"); w.run(); //李四 方法的继承 1234567891011121314151617181920class Person { name: string; //属性 constructor(name: string) { this.name = name; } run(): void { console.log(this.name); }}var p = new Person(\"张三\");class Web extends Person { constructor(name: string) { super(name); //这里表示继承父类的构造器，初始化自己的构造函数 } run(): void { console.log(`我是：${this.name}`); }}var w = new Web(\"李四\");w.run(); //我是李四，当子类和父类都有同一个方法时，子类会调用自己的 类的修饰符 typescript 中定义属性给我们提供了三种修饰符 public:表示公有 在类里面、子类、类外面都可以进行访问 protected：保护类型 在类里面、子类里面可以访问，在类外部没法访问 private：私有 在类里面可以进行访问，子类、类外部都不能进行访问 注意：属性如果不加修饰符，默认就是公有的(public) 公有属性(public) 在类外部访问 1234567891011class Person { public name: string; //公有属性 constructor(name: string) { this.name = name; } run() { console.log(this.name); }}var p = new Person(\"张三\");console.log(p.name); //张三 在类内部和子类内部访问 123456789101112131415161718192021class Person { public name: string; //公有属性 constructor(name: string) { this.name = name; } run(): string { return this.name; }}var p = new Person(\"张三\");console.log(p.run()); //张三class Web extends Person { constructor(name: string) { super(name); } work(): string { return `${this.name}在工作`; }}var w = new Web(\"李四\");console.log(w.work()); //李四在工作 保护属性(protected) 在类内部和子类内部访问 123456789101112131415161718192021class Person { protected name: string; //保护类型 constructor(name: string) { this.name = name; } run(): string { return `${this.name}在上班`; }}var p = new Person(\"张三\");console.log(p.run()); //张三在上班class Web extends Person { constructor(name: string) { super(name); } work() { return `${this.name}在工作`; }}var w = new Web(\"李四\");console.log(w.work()); //李四在工作 在类外部访问和子类外部访问 123456789101112131415161718192021class Person { protected name: string; //保护类型 constructor(name: string) { this.name = name; } run(): string { return `${this.name}在上班`; }}var p = new Person(\"张三\");console.log(p.name); //报错，name受保护class Web extends Person { constructor(name: string) { super(name); } work() { return `${this.name}在工作`; }}var w = new Web(\"李四\");console.log(w.name); //报错，name受保护 私有类型(private) 在类外部访问 1234567891011class Person { private name: string; //公有属性 constructor(name: string) { this.name = name; } run(): string { return this.name; }}var p = new Person(\"张三\");console.log(p.name); //报错，私有属性只能在内部中访问 在子类内部和外部访问 12345678910111213141516171819class Person { private name: string; //公有属性 constructor(name: string) { this.name = name; } run(): string { return this.name; }}var p = new Person(\"张三\");class Web extends Person { constructor(name: string) { super(name); } work(): string { return `${this.name}在工作`; //在这里就报错了，只能在Person内部中访问，所以外部没有试验的必要了 }}var w = new Web(\"李四\"); 在类内部访问 1234567891011class Person { private name: string; //公有属性 constructor(name: string) { this.name = name; } run(): string { return this.name; }}var p = new Person(\"张三\");console.log(p.run()); //张三 总结: 在类的定义中： + 公有的类里面，在当前类里面、子类、类外面都可以访问 + 在保护类里面，在当前类、子类里面都可以访问，在类外面不能访问 + 在私有类里面，在当前类里面可以访问，在子类，类外面都不能进行访问 一上就是在 TypeScript 中的类的相关知识。","link":"/2019/07/08/TypeScript中的类/"},{"title":"TypeScript中的数据类型","text":"JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。这里主要介绍前五种原始数据类型和一些其他的TypeScript的数据类型 Typescript中的数据类型布尔类型(boolean)1234&lt;!--在ES5中--&gt;var flag= true flag=123 console.log(flag) //123 12345678&lt;!--在Typescript中--&gt;var flag= true flag=123 //在这里时，编译器已经报错了&lt;!--正确的写法--&gt;var flag:boolean= true flag=false console.log(flag) //false 数字类型(number) 12345678910111213&lt;!--在ES5中--&gt;var num=123 num='aa' console.log(num) //aa&lt;!--在typesctipt--&gt;var num:number=123 num='str'// 编译器报错 &lt;!--正确的写法--&gt;var num:number = 123 num=456 console/log(num) //num 根据前两个我们已经可以看的出来.只要规定了该变量是什么类型或者是第一个赋值该变量的数据是什么类型的,这个变量就是什么类型的数据,并且赋值只能赋值相同的类型数据,否则直接报错 字符串类型(string) 1234&lt;!--在typescript中--&gt;let str:string = 'string' str = 'hello' console.log(str) //hello 数组类型(array)定义方式一: 在变量名后面跟上数组的类型 12345let arr:number[]= [12,11]arr=[\"123\",123] //这样就报错了arr=[123,456] //这样是正确的 定义方式二: 在变量名定义数组的时候在&lt;&gt;中定义数组的类型 12let arr:Array&lt;number&gt;=[12,123]console.log(arr) 定义方式三: 在下面有any类型的讲解 12let arr:any[]=['123',456,false]console.log(arr) //输出: [ '123', 456, false ] 元祖类型(tuple) 属于数组中的一种,可以定义多种数据类型,但是必须一一对应 12let arr:[number,string]=[123,\"123\"]arr=[\"123\",123] //这样是错误的,值必须与数据类型一一对应 枚举类型(enum) 123456enum Flag{ success=200, error=500}let s:Flag=Flag.successconsole.log(s) //输出:200 如果赋值了那么打印的就是你赋值的数字 123456enum Flag{ success=1, error=2}let s:Flag=Flag.successconsole.log(s) //输出:0 如果没有赋值那么输出的结果就是对应的下标,从 0 开始 1234567enum Flag{ success, 'error'=3, number}let s:Flag=Flag.numberconsole.log(s) //输出: 4,相当于前面的error=3赋值的是数组的下标,后面的值没有定义的话就是默认前面的下标+1 为了详细一点,我们在看一下这个代码就清楚了 12345678910111213141516enum Flag{ 'success'=-1, 'error'=999, number}let s:Flag=Flag.numberconsole.log(s) //输出 1000enum Flag{ 'success'=-10, 'error'=-15, number}let s:Flag=Flag.numberconsole.log(s) //输出 -14 注意: 在这个Flag中定义的名称可以加 ‘ ‘,也可以不加 ‘ ‘,但是值一定不能加‘ ‘,并且只能是数字,否则报错 任意类型(any)123let num:any[]=['123',123]num=['a',45]console.log(num); // 输出: ['a',45] any可以是任意的类型,但是我们在平时定义数据时不要随意使用any,不然其他的数据类型设计就没有意义了 any的正确用法: 12let app = document.getElementById('app')app.style.color= 'red' //报错了,对象可能为空 在Typescript中,并没有Object类型,所以无论定义什么具体类型,都会报错,这个时候我们就需要加入any 12let app:any = document.getElementById('app')app.style.color= 'red' 这样我们就完美的解决了这个错误 null和undefined 其他数据类型的子类型 示例: 12let num:numberconsole.log(num) //报错,在赋值前使用了num 这说明number类型的数据在赋值前都不能使用 12let num:undefinedconsole.log(num) //输出: undedined 有时候我们不管这个存不存在,存在的话就是number类型,不存在就是undefined类型 联合类型 123var num:undefined | number | nullnum=123console.log(num) //输出 123 并且不报错 12var num:undefined | number | nullconsole.log(num) //输出:undefined ,就算是没有赋值也不会报错 123var num:undefined | number | nullnum=nullconsole.log(num) //输出 null 这样就相当于有值就是number类型,没有值就是undefined,赋值为null就是null,因为undefined只能赋值为undefined,null只能赋值为null viod 类型 在typescript中,viod类型表示没有任何类型,一般定义没有返回值的方法 示例: 12345&lt;!--在ES5中--&gt;function run():void{ console.log('hello world')}run() //正常输出 1234function run():undefined{ console.log('aaa');}run() //报错,声明类型如果不是 viod 或者 any ,必须要有返回值 12345function run():undefined{ return null }run() //报错,不能返回数据类型不同的数据 never类型 never类型其他类型(包括了null,undefined)的子类型,代表从来不会出现的值,怎么理解呢? 12345let a:nevera=123 //报错let b:neverb=null //报错 这就说明了它不能是任意我们可以有的值,必须是没有的数据类型 1234let err:nevererr= (()=&gt;{ throw Error('error')})() 当我们使用never定义自执行函数抛出错误时,那么就可以使用never了,但是使用场景并不是很多,很多时候我们使用any来代替 总结的一些问题: 类型的推断 1234let num;num='45',num=123console.log(num) //123 我们可以推断,如果一开始没有给变量赋值,那么我们推断它默认就是 any 类型,可以赋任意值,和变量没有指定数据类型赋值一样,我们推断它是使用第一个赋值的数据类型作为该变量数据类型 在viod类型中,函数如果没有返回值那么使用 viod定义,如果有返回值,那么返回数据类型必须和定义函数的数据类型保持一致","link":"/2019/07/07/TypeScript中的数据类型/"},{"title":"TypeScript中的泛型","text":"泛型：软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性，组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能 前言 在像C#和java这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据，这样用户就可以以自己的数据类型来使用组件。 TypeScript中的泛型 通俗理解:泛型就是解决类接口方法的复用性、以及对不特定数据类型的支持 同时返回 string类型和number类型(但是代码冗余严重) 123456789101112131415function getData(value: string): string { return value;}function getData1(value: number): number { return value;}function getData3(value: any): any { if (typeof value === \"string\") { return `我是${value}`; } else { return `今年${value}`; }}console.log(getData3(\"张三\")); //我是张三console.log(getData3(12)); //我今年12 使用any也可以同时返回string和number类型，但是相当于放弃了类型检查 12345function getData(value:any):any{ return value}console.log(getData(12)); //12console.log(getData('张三'));//张三 泛型 一般我们定义泛型的时候，在函数名后面使用&lt;任意字母&gt;表示泛型，但是为了规范我们一般使用 T表示，函数定义了泛型后传入的参数也需要定义泛型，但是函数的返回值可以任意类型 12345function getData&lt;T&gt;(value: T): T { return value;}console.log(getData&lt;number&gt;(12)); //12console.log(getData&lt;string&gt;(\"张三\")); //张三 注意：在传入参数的时候定义的类型必须和参数类型一致 1234function getData&lt;T&gt;(value: T): any { //当函数的返回类型是any时，可以定义任意返回值 return \"hello\";}console.log(getData(\"zs\")); //hello 泛型类 普通取最小值 1234567891011121314151617181920class Sort { public list: number[] = []; add(num: number) { this.list.push(num); } min(): number { let min = this.list[0]; for (let i = 0; i &lt;= this.list.length; i++) { if (min &gt; this.list[i]) { min = this.list[i]; } } return min; }}let m = new Sort();m.add(10);m.add(1);m.add(20);console.log(m.min()); //1 这样定义的类我们不能往数组里面添加字母，不能实现字母的排序，所以需要使用泛型 123456789101112131415161718192021222324class Sort&lt;T&gt; { public list: T[] = []; add(value: T): void { this.list.push(value); } min(): T { let min = this.list[0]; for (let i = 0; i &lt;= this.list.length; i++) { if (min &gt; this.list[i]) { min = this.list[i]; } } return min; } } let m = new Sort&lt;number&gt;(); //实例化 并且指定了T代表number m.add(20); m.add(1); m.add(10); console.log(m.min()); // 1 let m2 = new Sort&lt;string&gt;(); // 实例化 并且指定了T代表string m2.add(\"a\"); m2.add(\"v\"); console.log(m2.min()); 泛型函数 如果我们在定义一个函数接口时，无法根据传入的参数类型作为返回数据类型，不够灵活 1234567interface Config { (name: string, age: number): string;}let getData: Config = function(name: string, age: number): string { return name + age;};console.log(getData(\"张三\", 12)); //张三 12 定义泛型函数接口的时候，并不是我们在函数中规定了数据的类型，而是在调用的时候传入类型，那么这个泛型就是传入的数据类型 第一种定义方法： 1234567interface Config { &lt;T&gt;(value: T): T;}let getinfo: Config = function&lt;T&gt;(value: T): T { return value;};console.log(getinfo&lt;number&gt;(12)); //12 此时，在这里我们传入了number，那么T就是指的number 定义方式二： 123456789interface Config&lt;T&gt; { //定义泛型接口 (value: T): T;}function getinfo&lt;T&gt;(value: T): T { return value;}let getData: Config&lt;number&gt; = getinfo; //给接口定义类型且getData使用这个接口console.log(getData(12)); //12 把类作为参数类型的泛型类 把类作为参数来约束数据传入的类型 示例1：定义User类，对数据库进行映射 1234567891011121314151617class User { username: string | undefined; password: string | undefined;}class Mydb { add(user: User): boolean { console.log(user); return true; }}let u = new User();u.username = \"张三\";u.password = \"123aaa\";let db = new Mydb();db.add(u); User{username:'张三',password:'123aaa'} 示例2： 123456789101112131415161718class ArticleCate { title: string | undefined; desc: string | undefined; status?: number | undefined;}class Mydb { add(info: ArticleCate): boolean { console.log(info); return true; }}let a = new ArticleCate();a.title = \"美味中国\";a.desc = \"江西美食\";let db = new Mydb();db.add(a); //ArticleCate { title: '美味中国', desc: '江西美食' } 我们可以使用不同的类作为参数进行数据的约束 示例3：泛型类 12345678910111213141516171819202122232425262728293031323334353637class Mydb&lt;T&gt; { add(info: T): boolean { //经过数据的校验，就可以将info传入数据库了 console.log(info); return true; } updata(info: T, id: number): boolean { //更新数据，info表示更新数据的内容，id表示更新数据的id console.log(info); console.log(id); return true; }}class ArticleCate { title: string | undefined; desc: string | undefined; status?: number | undefined; constructor(params: { //可以使用构造函数进行传参 title: string | undefined; desc: string | undefined; status?: number | undefined; }) { this.title = params.title; this.desc = params.desc; this.status = params.status; }}var a = new ArticleCate({ //直接传入参数 title: \"分类\", desc: \"000\", status: 200});var db = new Mydb&lt;ArticleCate&gt;();db.add(a); //ArticleCate { title: '分类', desc: '000', status: 200 }db.updata(a, 12); //ArticleCate { title: '分类', desc: '000', status: 200 } 12 以上就是Typescript中的泛型的一些使用方法。","link":"/2019/07/09/TypeScript中的泛型/"},{"title":"TypeScript对类型、接口、类、泛型的综合运用","text":"定义一个操作数据库的类 Typescript对类型、接口、类、泛型的综合使用 综合使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687interface DBI&lt;T&gt; { add(info: T): boolean; updata(info: T, id: number): boolean; dalete(id: number): boolean; get(id: number): any[];}//定义一个操作mysql数据库的类//注意：如果需要实现泛型接口时，那么这个实现泛型接口的类也需要是一个泛型类class Mysqldb&lt;T&gt; implements DBI&lt;T&gt; { constructor() {// console.log(\"这里可以建立和数据库的连接\"); } add(info: T): boolean { //添加数据，这里可以进行对数据库的增加操作 console.log(info); return true; } updata(info: T, id: number): boolean { //根据id更新数据，对数据库进行更新操作 console.log(info); console.log(id); return true } dalete(id: number): boolean { //根据id删除数据，对数据库进行删除操作 console.log(id); return true } get(id: number): any[] { //根据id 得到数据，对数据库进行查找操作 console.log(id); let lits:any[]=[] return lits }}//定义操作mssql数据库的类class MssqlDB&lt;T&gt; implements DBI&lt;T&gt; { constructor() {// console.log(\"这里可以建立和数据库的连接\"); } add(info: T): boolean { console.log(info); return true; } updata(info: T, id: number): boolean { console.log(info, id); return true; } dalete(id: number): boolean { console.log(id) } get(id: number): any[] { console.log(id); let lits:any[]=[] return lits }}//定义一个User数据表做数据库的映射class User { username: string | undefined; password: string | undefined; constructor(params: { //使用构造函数传值 username: string | undefined; password: string | undefined; }) { this.password = params.password; this.username = params.username; }}//往数据表添加数据let u = new User({ username: \"张三\", password: \"123aaa\"});//操作mysql// let mysql = new Mysqldb(); //如果此时没有使用定义的user作为限制，add()中参数可以是任意值，没有做类型的校验// mysql.add('aaa');let mysql = new Mysqldb&lt;User&gt;(); //此时使用User类作为限制类型，那么在实例化后的add中我们只能传入User类mysql.add(u); //User { password: '123aaa', username: '张三' }let m = new User({ username: \"李四\", password: \"lisi\"});// 操作mssqllet mssql = new MssqlDB&lt;User&gt;();mssql.add(m); // User { password: 'lisi', username: '李四' }mssql.updata(m, 12); //User { password: 'lisi', username: '李四' } 12 这样我们定义一个数据库的，只需要调用对应的数据库进行数据操作，而且对不同的数据库都是兼容的。","link":"/2019/07/09/TypeScript对类型、接口、类、泛型的综合运用/"},{"title":"Vs code中Git工具的使用","text":"在一些开发工具中，集成了许多的功能，在我喜欢的vscode中，就集成了git的一些功能，非常方便我们使用 vscode中的Git工具 当我们在对一些推送到远程的项目进行修改时，我们在VS code中发现修改的内容在侧边会有标记 红色的箭头标识表示这里删除了一些东西 绿色标识表示这里修改了一些东西 蓝色标识标识增加了一些东西 当然，我们要说的并不是只有这些，最主要的是我们修改的文件内容后需要推送到远程，再也不需要git add ''、git commit -m '' ，git push了，我们在侧边栏找到这个工具 在这里工具会显示你修改了几个文件，而在更多这里显示你修改了哪些文件，鼠标指针放在修改的文件可以对文件进行一些操作，比如撤回修改 我们继续往下看，在这里有一个 message这里需要添加的是你提交的描述，和git commit -m '' 这里的一致，添加消息后点击 √就可以保存到暂存区了 如果需要推送到远程，点击推送即可、 注意：如果你关联了多个远程，那么直接点击推送可能会报错，因为它不知道你需要推送到哪一个，所以选择推送到...然后选择即可 这样我们在以后的开发中可以减少一点工作量","link":"/2019/07/02/Vs code中Git工具的使用/"},{"title":"Vuex的使用","text":"vuex是什么？Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 前言 我们在进行一些复杂的父子组件之间的传值的时候，尤其是组件嵌套传值时尤其麻烦，读取值不方便，如果有异步操作，还需要对值监听，这样获取一些值得时候对我们开发人员不友好，所以诞生了Vuex Vuex的使用vuex的安装配置 安装:npm install vuex -S 如果使用&lt;script&gt;&lt;/script&gt;标签引入的vue，那么自己会安装有vuex 安装插件： 1234import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex) 配置: 123456789101112// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)const store = new Vuex.Store({ state: { //这个就是相当于 vue中的 data，用来存放数据的 count: 0 }, mutations: { //这个相当于 vue 中的 methods ，存放了些方法 increment (state) { state.count++ } }}) 使用:实现一个小案例，官方也是这个案例来说明的： main.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 入口文件import Vue from 'vue'// 配置vuex的步骤// 1. 运行 cnpm i vuex -S // 2. 导入包import Vuex from 'vuex'// 3. 注册vuex到vue中Vue.use(Vuex) // 4. new Vuex.Store() 实例，得到一个 数据仓储对象var store = new Vuex.Store({ state: { // 大家可以把 state 想象成 组件中的 data ,专门用来存储数据的 // 如果在 组件中，想要访问，store 中的数据，只能通过 this.$store.state.*** 来访问 count: 0 },mutations: { // 注意： 如果要操作 store 中的 state 值，只能通过 调用 mutations 提供的方法，才能操作对应的数据，不推荐直接操作 state 中的数据，因为 万一导致了数据的紊乱，不能快速定位到错误的原因，因为，每个组件都可能有操作数据的方法； increment(state) { state.count++ }, // 注意： 如果组件想要调用 mutations 中的方法，只能使用 this.$store.commit('方法名') // 这种 调用 mutations 方法的格式，和 this.$emit('父组件中方法名') subtract(state, obj) { // 注意： mutations 的 函数参数列表中，最多支持两个参数，其中，参数1： 是 state 状态； 参数2： 通过 commit 提交过来的参数； console.log(obj) state.count -= (obj.c + obj.d) }},getters: { // 注意：这里的 getters， 只负责 对外提供数据，不负责 修改数据，如果想要修改 state 中的数据，请 去找 mutations optCount: function(state) { return '当前最新的count值是：' + state.count } // 经过咱们回顾对比，发现 getters 中的方法， 和组件中的过滤器比较类似，因为 过滤器和 getters 都没有修改原数据， 都是把原数据做了一层包装，提供给了 调用者； // 其次， getters 也和 computed 比较像， 只要 state 中的数据发生变化了，那么，如果 getters 正好也引用了这个数据，那么 就会立即触发 getters 的重新求值； }})import App from './App.vue'const vm = new Vue({ el: '#app', render: h =&gt; h(App), store // 5. 将 vuex 创建的 store 挂载到 VM 实例上， 只要挂载到了 vm 上，任何组件都能使用 store 来存取数据}) counter.vue文件内容 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div&gt; &lt;input type=\"button\" value=\"减少\" @click=\"remove\"&gt; &lt;input type=\"button\" value=\"增加\" @click=\"add\"&gt; &lt;br&gt; &lt;input type=\"text\" v-model=\"$store.state.count\"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { // count: 0 }; }, methods: { add() { // 不要这样使用，不符合 vuex 的设计理念，因为这样直接操作了state // this.$store.state.count++; this.$store.commit(\"increment\"); }, remove() { this.$store.commit(\"subtract\", { c: 3, d: 1 }); } }, computed:{ fullname: { get(){}, set(){} } }};&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt;&lt;/style&gt; amount.vue文件内容： 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;!-- &lt;h3&gt;{{ $store.state.count }}&lt;/h3&gt; --&gt; &lt;h3&gt;{{ $store.getters.optCount }}&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt;&lt;/style&gt; 这样，这两个兄弟节点，就可以通过state读写数据了，不需要进行组件之间的传值 总结： state中的数据，不能直接修改，如果想要修改，必须通过 mutations,不然的话就违背了vuex的设计初衷 如果组件想要直接 从 state 上获取数据： 需要 this.$store.state.*** 如果 组件，想要修改数据，必须使用 mutations 提供的方法，需要通过 this.$store.commit('方法的名称'， 唯一的一个参数) 如果 store 中 state 上的数据， 在对外提供的时候，需要做一层包装，那么 ，推荐使用 getters, 如果需要使用 getters ,则用 this.$store.getters.***","link":"/2019/07/05/Vuex的使用/"},{"title":"express中的中间件","text":"在Nodejs中的Express框架来说，中间件是一个比较抽象的概念，但是对于理解Nodejs的请求原理是非常重要的，这里简单的介绍了Nodejs中Express框架的中间件原理 中间件的原理 就是相当于水经过一系列处理到用户的过程，中间不能跳过某些步骤或者调换某些步骤 下面使用一个代码来帮助我们更好的理解中间件的概念 1234567891011121314151617181920212223242526272829const express = require('express')const app = express()const port = 3000//这个就是中间件，中间件就是一个函数，函数有三个参数//request 请求数据//respone 响应数据// next 表示继续执行下一个中间件，如果没有使用这个方法，那么下面就算有符合匹配项，都不会被执行//这个表示所有请求都会经过这里,但是请求到这里时会停留，如果想要继续执行需要调用next方法app.use(function(request, respone, next) { console.log('a') next() //需要继续执行})app.use(function(request, respone, next) { console.log('b') next() }) //这个表示所有的get请求并且路径为 / 的请求会经过这个中间件app.get('/', (req, res, next) =&gt; { console.log('Hello World!') //如果此时不使用next方法，那么下面的get函数不会 被执行 next()})app.get('/', (req, res, next) =&gt; { res.send('Hello World!')})app.listen(port, () =&gt; console.log(`Example app listening on port port!`)) 所以，我们在使用中间件时，都应该遵循这些规则，这样可以帮助我们更好的编写程序","link":"/2019/06/24/express中的中间件/"},{"title":"webpack中引入vue","text":"在webpack使用vue，我们会遇到一些打包的问题，这个使用我们要使用打包工具来解决这个问题，以下是具体的一些说明和使用 两者区别 在webpack中，我们需要将所有的包在main.js这个入口文件中导入，在在我们安装vue(npm i vue -D)到本地时，我们在main.js导入这个包 1import Vue from \"vue\" 会爆出以下异常： You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build. 以下的问题解释是：在webpack中使用 import Vue from “vue” 引入的 vue构造函数 功能是不完整的，它只提供了runtime-only 的方式，并没有提供 像网页中使用 script引入的那些功能 解决方式一： 使用：import Vue from &quot;../node_modules/vue/dist/vue&quot;这种引入方式 解决方式二： 配置webpack.config.js文件，新增一个属性:resolve，在里面中还有一个属性:alias，配置如下 123456resolve: { alias: { 'vue$': 'vue/dist/vue.esm.js' }} 这样使用import Vue from &quot;vue&quot;引入也不会报错了 说明 由于webpack是使用Node架构的，所以合法的Node语法都支持，当然，引入包的规则也是一致的 如下： Nodejs中包的查找规则: 找项目根目录中是否有安装 node_modules 的文件夹 在node_modules 中根据包名，找对应的 vue 文件夹 在 vue中，找到一个叫packahe.json的配置文件 在package.json 文件夹中，查找一个 main 属性，这个属性指定了这个包被加载时的入口文件","link":"/2019/06/23/webpack中引入vue/"},{"title":"webpack打包图片","text":"在webpack中，我们使用其打包一些项目的时候，经常会遇到图片，但是如果直接打包图片则会抛出异常，以下是打包图片的一些详细配置文件和步骤 使用webpack打包图片 在平常中，我们在设置style中使用background:url 可以引入背景图片，在前面我们已经学会如何打包css、less、scss文件 安装url-loader和其依赖file-loader cnpm install url-loader file-loader -D 使用file-loader进行图片的打包 在webpack.config.js中配置，在与其他配置下添加如下即可 1234{ test: /\\.jpg|png|gif|bmp|jpeg/, //配置图片 use: ['file-loader'] } 可以简写成如下： 1234{ test: /\\.(jpg|png|gif|bmp|jpeg)/, //配置图片打包的格式 loader: 'file-loader' } 如果想要打包出来的图片不改变名字和格式，只需添加options即可 123456{ test: /\\.(jpg|png|gif|bmp|jpeg)/, //配置图片打包的格式 loader: 'file-loader' options: { //[name]表示名字,[ext]表示格式，而name属性其实就是图片打包后的路径 name: 'images/[name].[ext]' } 除了使用file-loader对图片进行打包处理外，我们同样也可以使用url-loader代替，另外我们还可以对小于某个大小的图片进行base64格式的转化处理。 使用url-loader打包 12345678{ test: /\\.(png|jpg|gif|svg)$/, loader: 'url-loader', options: { name: './images/[name].[ext]', limit: 8192 }} 这里limit属性的作用就是将小于8192B（8.192K）大小的图片转成base64格式，而大于这个大小的图片将会以file-loader的方式进行打包处理 注意：如果不写limit属性，那么url-loader就会默认将所有图片转成base64 这样打包出来的图片会自动转换成base64,但是我们多数是将小图片转成base64，而大图片不进行转换 而对于有些图片在不同路径下，但是文件名字一样时，我们需要在name:属性中增加hash值：定义[hash:8]定义 8位hash值最多32位，这样图片就不会存在不同 123456789{ test: /\\.(jpg|png|gif|bmp|jpeg)/, //配置图片 loader: 'url-loader', //在这里时，只有一个我们可以简化 loader，使用use则会报错 options: { limit: 2000, //limit 的值单位是 Byte ，如果图片小于limit的值，则转成base64格式的字符串，如果大于，则不转 name: '[hash:8]-[name].[ext]' //这是将文件名原样输出[name]指的是图片名，[ext]是图片格式， //[hash:8]表示生成8位hash值，否则在不同文件夹下同名图片会失效，用来区分 } }","link":"/2019/06/22/webpack打包图片/"},{"title":"关联多个远程仓库","text":"我们在日常的开发中，由于GitHub是外国的服务器，所以上传速度较慢，但是我们国内也有托管的网站，比如码云 前言 在实际的开发过程中，团队协作开发项目是必不可少的，我们将项目托管到远程仓库上，就是为了解决多人合作开发和代码托管备份的作用，而有时候我们需要将一个项目托管到多个仓库中，现在我们就一起来学习一下如何操作 使用码云 要想使用码云现需要注册 注册成功后在个人中心，配置ssh，因为我们在github中，已经生成了ssh，所以我们直接拿公钥即可 然后在个人中心旁边有个 + 号 新建仓库即可关联github和码云 在git的使用我们已经详细的简述了如何托管到GitHub中，现在我们讲述一下托管到GitHub和码云中 git remote rm origin；先删除已经关联的origin远程仓库 git remote add github git@github.com:ZhongYueHui/vue-001.git 注意：，远程仓库名是github了不是origin了 接着关联码云的仓库 git remote add gitee git@gitee.com:zhongyuehui/vue-001.git 注意：，远程仓库名是gitee了不是origin了 现在我们使用git remote -v就可以查看到远程库的信息了 1234gitee git@gitee.com:zhongyuehui/vue-001.git (fetch)gitee git@gitee.com:zhongyuehui/vue-001.git (push)github git@github.com:ZhongYueHui/vue-001.git (fetch)github git@github.com:ZhongYueHui/vue-001.git (push) 推送到GitHub和码云 推送到GitHub：git push github master 推送到码云:git push gitee master 这样，我们的项目将就分别在git和码云中了","link":"/2019/07/02/关联多个远程仓库/"},{"title":"webpack配置的一些总结","text":"在配置webpack打包项目时，有些必要的插件安装与配置，才能保证项目完整的被打包，这里总结了一些基础的webpack配置，可以满足基础的打包运行要求 全局安装webpack npm install webpack -g 生成package.json npm init -y 安装webpack-dev-server到本地 npm install webpack-dev-server -D 仍然需要在本地安装webpack作为webpack-dev-server的依赖 npm install webpack -D 配置webpack.config.js文件 创建webpack.config.js文件 配置文件出入口 1234567891011121314151617181920212223//由于webpack是由Nodejs构建的，所以任何的Nodejs语法都支持//引入路径模块var path = require('path')//当以命令形式运行webpack或者webpack-dev-server的时候，工具会发现，我们没用提供要打包的文件入口和出口命令//此时，就会检查项目根目录中的配置文件 webpack.config.js 并读取这个文件，就拿到了导出的这个配置对象，然后根据对象进行打包//向外暴露出这个对象module.exports = { entry: path.join(__dirname, './src/main.js') //入口文件，需要打包的文件 , output: { //出口文件，需要打包到哪里去 path: path.join(__dirname, './dist/bundle.js') //输出路径 , filename: 'bundle.js' }, mode: 'development', //设置mode，在4.0新增 } 配置一些功能：在webpack.config.js中配置 123456 devServer: { //配置webpack-dev-server open: true, //是否打开浏览器 contentBase: 'src', //指定托管的目录 hot: true, //是否启用热更新 port: 6000 //代理的端口}, 在package.json中配置 123\"script\":{\"start:dev\": \"webpack --open --port 3000 --contentBase src --hot\"} 需要将打包好的文件从虚拟内存中传入过来 安装html-webpack-plugin npm install html-webpack-plugin -D 在webpack.config.js中配置这个插件 作用： 在内存中，根据只当的模板页面，生成一份内存中的首页，同时把打包好的bundle.js注入到页面底部 如果需要配置插件，需要在导出的对象中挂载一个 plugins:[] 注意：所有的第三方插件都在 plugins:[]中配置 与entry、output同级1234567plugins: [ new htmlWebpackPlugin({ template: path.join(__dirname, './src/index.html'), //指定模板文件的目录 filename: 'index.html' //设置生成的页面名称 }) ] 配置css-loader、less-loader、sass-loader 在main.js中引入css文件 import ‘./css/style.css’ 安装css-loader插件：npm install css-loader style-loader --save-dev import ‘./css/style.less’ 安装css-loader插件：npm install less-loader less --save-dev import ‘./css/style.sass’ 安装css-loader插件：npm install sass-loader node-sass --save-dev 配置文件 在webpack.config.js配置sass 注意：使用npm命令时安装node-sass可能会报错，无法打包，此时建议切换成cnpm 切换方法 cmd运行nrm ls查看,然后切换nrm use cnpm即可，但是前提应该先在全局中安装nrm 12345678910111213module.exports = { ... module: { rules: [{ test: /\\.scss$/, use: [ \"style-loader\", // creates style nodes from JS strings \"css-loader\", // translates CSS into CommonJS \"sass-loader\" // compiles Sass to CSS, using Node Sass by default ] }] }}; 在webpack.config.js配置css 12345678910module.exports = {module: { rules: [ { test: /\\.css$/i, use: ['style-loader', 'css-loader'], }, ],},}; 在webpack.config.js配置less 12345678910module.exports = {module: { rules: [ { test: /\\.less$/, loader: 'less-loader', // compiles Less to CSS }, ],},}; 配置好基本的webpack.config.js文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//由于webpack是由Nodejs构建的，所以任何的Nodejs语法都支持//引入路径模块var path = require('path')//在内存中，根据只当的模板页面，生成一份内存中的首页，同时把打包好的bundle.js注入到页面底部//如果需要配置插件，需要在导出的对象中挂载一个 plugins:[]const htmlWebpackPlugin = require('html-webpack-plugin')//当以命令形式运行webpack或者webpack-dev-server的时候，工具会发现，我们没用提供要打包的文件入口和出口命令//此时，就会检查项目根目录中的配置文件 webpack.config.js 并读取这个文件，就拿到了导出的这个配置对象，然后根据对象进行打包//向外暴露出这个对象module.exports = { entry: path.join(__dirname, './src/main.js') //入口文件，需要打包的文件 , output: { //出口文件，需要打包到哪里去 path: path.join(__dirname, './dist') //输出路径 , filename: 'bundle.js' }, module: { rules: [{ test: /\\.css$/i, //配置css use: ['style-loader', 'css-loader'], }, { test: /\\.less$/i, //配置less use: ['style-loader', 'css-loader', 'less-loader'] }, { test: /\\.scss$/i, //配置sass use: ['style-loader', 'css-loader', 'sass-loader'] }], }, devServer: { //配置webpack-dev-server open: true, //是否打开浏览器 contentBase: 'src', //指定托管的目录 hot: true, //是否启用热更新 port: 2000 //代理的端口 }, mode: 'development', plugins: [ new htmlWebpackPlugin({ template: path.join(__dirname, './src/index.html'), //指定模板文件的目录 filename: 'index.html' //设置生成的页面名称 }) ]} 注意事项： 在webpack4.0以后，webpack新增了mode属性 打包命令有所变化 webpack 要打包的文件 -o 打包生成存放文件的路径 而且在package.json文件中，需要配置如下代码： 1234\"scripts\": { \"dev\": \"webpack --mode development\", // 开发环境 \"build\": \"webpack --mode production\", // 生产环境 }, 在webpack.config.js中，同样需要配置如下代码：1mode: 'development' // 设置mode 如果需要下载指定版本，输入以下命令： npm i -D webpack@3 // 3： webpack版本3最新","link":"/2019/06/22/webpack配置的一些总结/"},{"title":"git的使用","text":"git是什么？Git(读音为/gɪt/。)是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理 前言 我们在平时的项目开发中，难免会用到一些托管工具来托管自己的代码，这样可以更好的和别人和分享自己项目和合作开发项目，这里就简单介绍一下git的使用。 git的使用Git基本操作 上传本地文件(工作区)到暂存区 git status先初始化项目(状态)，检查是否在工作区域还是暂存区 git add 文件名将文件上传到暂存区 将暂存区的文件上传到git仓库中 git status初始化暂存区的项目，查看是否含有相同的内容 git commit -m &quot;提交的描述&quot;，项目的说明 git status 查看文件状态 注意：使用 git commit -m '' 是一次性将文件放到分支，使用git add是将文件添加到暂存区(Stage), git是版本控制工具，并不是文件控制工具，我们只有使用git add添加到暂存区的文件，再使用git commit -m ''才能将文件提交到分支，如果你修改了文件直接提交到分支，这个是不能修改的，不信你可以使用git diff HEAD -- '文件名'查看工作区和版面本库中最新版本的区别 ，没有使用git add '' 的文件内容没有并没有添加到版本库(commit)中 基本流程 基本流程图 基本设置 设置用户名:git config --global user.name 'GitHub的用户名' 设置用户名的邮箱：git config --global user.email '设置用户名的邮箱' 初始化新的git仓库 创建新的文件夹 也可以在命令行 mkdir 文件夹名字进行创建 进入文件夹 ，命令行cd 文件夹名 初始化仓库, 命令行 git init ，会生成一个.git的文件夹，若没有在文件夹下点击查看，打开显示隐藏的项目 项目的管理 上传文件项目(使用流程) 在项目文件夹中，创建文件，也可以在命令行中使用touch 文件名 注意：需要带后缀名 然后使用 git status可以查看文件是否在暂存区域中(没有是红色) 如果没有，使用git add '文件名'即可将文件名上传到暂存区中 git status查看文件是否已经存在于暂存区(存在是绿色) 修改文件 命令行直接 vi/vim 文件名即可输入内容，也可以鼠标右键编辑 修改后 git status，发现文件更改后，又变成红色，需要重新提交 git diff可以查看修改了什么内容 git add 文件名提交即可 git status发现没有文件可以提交，则提交成功 撤销修改(例如撤回reademe.txt文件的修改) 我们再修改文件时可能由于出错误修改，我们可以及时的将文件返回到上一个未修改的版本，修改文件后 git status也可以发现git会提示你使用git checkout -- &lt;file&gt;可以丢弃工作区的修改 当然，命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 删除文件 在命令行rm -rf 文件名(强制删除，不建议使用)或者rm 文件名(普通删除),rm -l 文件名(删除三个以上提示),rm -i 文件名(删除前提示，可以确认删除文件是否选择正确)，或者在鼠标右键删除 注意：上面的步骤是在工作区删除 git rm 文件名:是在git中删除文件 git commit -m '提交描述'，如果需要删除某个文件，则需要rm 文件 再 git rm 文件 再 git commit -m '提交描述',这样就可以完整的删除这个文件了 注意：使用git log 可以查看每次版本的修改历史，如果你嫌弃信息过多眼花缭乱，也可以使用git log --pretty=oneline查看，其中一大串的只是commit id(版本号)而已 回退版本 在git中，使用HEAD表示当前的版本，上个版本使用 (HEAD^)表示，上上版本使用 (HEAD^^)表示，如果是多个可以使用 (HEAD~N)表示 使用 git reset --hard HEAD^表示回退上一个版本，但是我们使用git log已经查看不到之前我们跳转过来的历史了，但是如果我们想还原，也还是有办法的，只要我们不关闭命令行窗口，找到之前的commit id,就可以回到未来的指定版本 使用git reset --hard commit id 后，可以查看是否回到上个版本了 注意： 使用commit id 时不需要全部填写 但是要精确到git能找到该文件 如果我们回退到上一个版本后已经关闭了命令行又想回到最新版本怎么办？ 在git中，提供了一个命令git reflog可以记录你的每一条命令 git远程仓库 添加远程仓库(如：test) 准备工作 创建ssh（如果已经创建关联请忽略） 在命令行下ssh-keygen -t rsa -C &quot;898542119@qq.com&quot;,然后一路回车即可 在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人 登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容即可，这样我们的关联就已经做好了 远程添加文件到仓库中 登陆GitHub，点击 “Create a new repo”，在Repository name 填入仓库名称，其他的默认即可 在你本地的仓库中运行如下：git remote add origin git@github.com:ZhongYueHui/test.git其中ZhongYueHui是GitHub的名字,test仓库的名字 然后使用 git push -u origin master就可以将文件提交到GitHub上了，其实就是将本地分支 master 推送到远程，这样远程的仓库和本地就一样了 从现在开始，只要你对文件做了修改，就可以使用git push origin master将最新的修改提交到版本库了 注意：如果第一次clone或者push会弹出如下警告,输入yes即可 123The authenticity of host 'github.com (xx.xx.xx.xx)' can't be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)? 从远程克隆仓库 在命令行输入git clone git@github.com:ZhongYueHui/gitskills.git即可克隆gitskills仓库 注意：要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆,Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快 分支管理 创建和合并分支 创建分支:git checkout -b 分支名称，git checkout -b dev相当于创建新分支并切换，相当于如下两条命令 12git branch dev //创建分支git checkout dev //切换分支 查看分支:git branch,会列出所有的分支，当前的分支会使用*标记 我们在dev分支下修改的文件在切换到master分支查看，发现并未修改，但是我们可以使用git merge dev将dev分支合并到当前的分支上(master) 合并完之后，我们就可以将dev分支删除了:git branch -d dev，使用git branch查看分支就只有master 了 小结： 1234567891011查看分支：git branch创建分支：git branch &lt;name&gt;切换分支：git checkout &lt;name&gt;创建+切换分支：git checkout -b &lt;name&gt;合并某分支到当前分支：git merge &lt;name&gt;删除分支：git branch -d &lt;name&gt; 分支之间的冲突 假设我们在创建了一个分支feature1，我们在feature1上修改reademe.txt文件，然后git add reademe.txt和git commit -m ''，然后切换到master中同样对reademe.txt做出修改，然后git add reademe.txt和`git commit -m 这样，我们想合并feature1分支就会出异常，Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改自己想要的内容和删除标记后保存：这个时候我们需要将内容统一到和feature1，然后git add reademe.txt和git commit -m即可 我们还可以使用git log --graph --pretty=oneline --abbrev-commit查看分支合并情况分支管理策略 合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fastforward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息 假设我们在创建了一个分支feature1，我们在feature1上修改reademe.txt文件，然后git add reademe.txt和git commit -m ''，然后切换到master中,准备合并feature1，使用=&gt;git merge --no-ff -m &quot;merge with no-ff&quot; dev进行合并，注意 --no-ff表示的是禁用Fast forward git log --graph --pretty=oneline --abbrev-commit查看分支历史123456 * e1e9c68 (HEAD -&gt; master) merge with no-ff|\\ | * f52c633 (dev) add merge|/ * cf810e4 conflict fixed ... BUG分支 我们可能在开发中出现一些紧急的BUG需要及时修复，你可能马上想创建一个BUG修复的文件，但是你突然发现自己手中的 工作还没做完，无法提交，这时候就需要用到Git提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作 我们使用git stash来暂停自己的工作现场，然后创建自己的bug修复分区，然后git add '',git commit -m ''后合并到master分区中，这样BUG修复完毕了，删除bug修复分区即可（git merge --no-ff -m &quot;删除描述&quot; 分区名） 修复完后就可以切换到自己原来的分区继续工作了，但是我们需要使用git stash list查看，使用git status查看是干净的，然后我们可以使用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；另一种方式是用git stash pop，恢复的同时把stash内容(就是暂停的记录)也删了,再使用git stash list就是干净的了 1stash@{0}: WIP on master: 54a255b git tracks changes 你可以多次使用git stash list，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：git stash apply stash@{0} Feature分支 用于实验的项目功能，不能直接用于主分支，容易乱掉，所以最好新建一个分支进行实验性测试 新建一个分区后，新建一个增加功能的文件，git add '',git commit -m ''后git checkout dev合并到dev中，如果此时想删除这个功能文件，我们此时就应该删除该文件git branch -d feature-vulcan，如果提示还没有合并，那么直接将-d换成-D即可强制删除该分区 12error: The branch 'feature-vulcan' is not fully merged.If you are sure you want to delete it, run 'git branch -D feature-vulcan'. 远程同步分支 当我们需要多个人同时开发项目时，我们应该将本地的分支推送到远程分支上 当我们从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。要查看远程库的信息，用git remote或者git remote -v 12origin git@github.com:ZhongYueHui/learngit.git (fetch)origin git@github.com:ZhongYueHui/learngit.git (push) 推送分支 git push origin master将本地分支推送到远程分支上 如果推送dev这个分区，git push origin dev即可 说明： 并不是每个分支都需要被推送， master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步 bug分支只用于在本地修复bug，就没必要推到远程了，除非上级要求 feature分支是否推到远程，取决于你是否和你的项目伙伴抓取分支 如果你和你的团队再开发一个项目时，你的一个伙伴推送文件到dev分支上，并且推送到远程上，这个时候如果你也推送(push)dev到远程，这个是时候就会出错，解决办法也是和分支之间的冲突一样处理 小结： 首先，可以试图用git push origin 推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;rebase 我们在多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的伙伴不得不先pull，在本地合并，然后才能push成功。每次合并再push后，分支变成的很乱 使用git rebase可以解决这个问题，帮我们把分支整理成一条直线标签管理 方便我们查找，虽然git有 commit，但是这个东西是一堆进制数，不方便我们查找，所以我们设置标签的形式，方便查找 在你想要创建标签的分支上,输入git tag &lt;name&gt;添加标签，使用git tag可以查看所有标签给git 如果之前忘记了添加标签，找到历史的commit id打上就可以，git log --pretty=oneline --abbrev-commit 比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令：git tag v0.9 f52c633 查看所有的书签：git show &lt;tagname&gt; 命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息； 命令git tag可以查看所有标签操作书签 修改书签：git tag -d v0.1 将标签推送到远程：git push origin &lt;tagname&gt;或者git push origin --tags一次性将推送未推送的书签 删除远程的书签： 先删除本地的书签：git tag -d v0.9 再从远程删除：git push origin :refs/tags/v0.9 总结： 命令git push origin &lt;tagname&gt;可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d &lt;tagname&gt;可以删除一个本地标签； 命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签","link":"/2019/07/01/git的使用/"}],"tags":[{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"vs code","slug":"vs-code","link":"/tags/vs-code/"},{"name":"vuex","slug":"vuex","link":"/tags/vuex/"},{"name":"Express","slug":"Express","link":"/tags/Express/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"git","slug":"git","link":"/tags/git/"}],"categories":[{"name":"Nodejs","slug":"Nodejs","link":"/categories/Nodejs/"},{"name":"ES6","slug":"ES6","link":"/categories/ES6/"},{"name":"TypeScript","slug":"TypeScript","link":"/categories/TypeScript/"},{"name":"开发工具","slug":"开发工具","link":"/categories/开发工具/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"Git","slug":"Git","link":"/categories/Git/"}]}