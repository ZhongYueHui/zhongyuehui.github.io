{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"关于我","text":"一个专注技术的修行者.","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Angular中父子路由嵌套","text":"Angular中的父子路由嵌套和Vue的相似，你如果学习了Vue的路由嵌套那么你也会Angular的路由嵌套 Angular中父子路由嵌套嵌套路由 配置子路由 123456789101112131415161718192021222324252627282930313233343536373839//app.routing.htmlimport { NgModule } from '@angular/core';import { Routes, RouterModule } from '@angular/router';import { HomeComponent } from './components/home/home.component';import { WelcomComponent } from './components/home/welcom/welcom.component';import { SettingComponent } from './components/home/setting/setting.component';import { ShoppingComponent } from './components/shopping/shopping.component';import { PcateComponent } from './components/shopping/pcate/pcate.component';import { ListsComponent } from './components/shopping/lists/lists.component';const routes: Routes = [{ path: 'home', component: HomeComponent, children: [ { path: 'setting', component: SettingComponent }, { path: 'welcome', component: WelcomComponent }, { path: '**', redirectTo: 'welcome' } ]}, { path: 'shopping', component: ShoppingComponent, children: [{ path: 'pcate', component: PcateComponent, }, { path: 'lists', component: ListsComponent }, { path: '**', redirectTo: 'pcate' }]}, { path: '**', redirectTo: 'home'}];@NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule]})export class AppRoutingModule { } 在父组件中显示子路由，先在根组件中，设置各个父组件的路由 1234567//app.html&lt;header class=\"header\"&gt; &lt;a [routerLink]=\"[ '/home' ]\" routerLinkActive=\"active\"&gt;首页&lt;/a&gt; &lt;a [routerLink]=\"[ '/shopping' ]\" routerLinkActive=\"active\"&gt;商城&lt;/a&gt;&lt;/header&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt; 1234567891011//shopping.html&lt;section class=\"container\"&gt;&lt;div class=\"left\"&gt; &lt;a [routerLink]=\"[ '/shopping/pcate' ]\" routerLinkActive=\"active\"&gt;商品分类&lt;/a&gt; &lt;a [routerLink]=\"[ '/shopping/lists' ]\" routerLinkActive=\"active\"&gt;商品列表&lt;/a&gt;&lt;/div&gt;&lt;div class=\"right\"&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; //选中路由展示区域&lt;/div&gt;&lt;/section&gt; 123456789101112//home.html&lt;section class=\"container\"&gt;&lt;div class=\"left\"&gt; &lt;a [routerLink]=\"[ '/home/welcome' ]\" routerLinkActive=\"active\"&gt;欢迎&lt;/a&gt; &lt;a [routerLink]=\"[ '/home/setting' ]\" routerLinkActive=\"active\"&gt;设置&lt;/a&gt;&lt;/div&gt;&lt;div class=\"right\"&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt;&lt;/div&gt;&lt;/section&gt; 在style.scss中设置全局样式 1234567891011121314151617181920212223242526/* You can add global styles to this file, and also import other style files */* { margin: 0; padding: 0; text-decoration: none;}.container { width: 100%; flex: 1; height: 500px; display: flex; .left { height: 500px; width: 200px; border-right: 1px solid; a { display: block; } } .right { flex: 1; }}.active { background-color: aqua;} 这样就是实现了简单路由的嵌套与跳转","link":"/2019/08/04/Angular中父子路由嵌套/"},{"title":"Angular中的内置模块以及自定义模块","text":"Angular集成了许多功能，封装在模块中，我们需要使用模块就需要调用和配置 Angular中的内置模块以及自定义模块内置模块 模块的使用，比如我们需要实现数据的双向绑定，那么就需要引入forms表单模块，需要发送数据请求就需要引入http模块 自定义模块 使用ng g module 模块名创建模块 创建模块后，在自定义的模块中创建组件的话，那么这个模块会自动引入这些创建的组件，如果你创建的组件名和路径与模块名一样，那么就会认为是创建这个模块的根组件 在app根组件中，是不能直接使用自定义模块中的组件的，如果需要使用，需要在自定义模块的module.ts文件中，使用exports暴露要被其他模块是使用的组件 1exports:[要暴露的组件名] 这样才能在其他模块中使用该组件，但是需要注意的是，使用之前先要在app.module.ts中引入自定义的模块，然后在imports中挂载这个模块，然后才能使用自定义的组件 自定义下的模块下的组件之间可以相互访问，但是不同模块之间需要使用别的模块的组件必须要暴露出去，不然使用不了 具体定义步骤 如果实际开发中建议将自定义的模块放在一个单独的modules文件夹中，但是这里我们就不做这个操作了 先创建模块 1ng g module use 创建模块根组件 1ng g component use 在模块下创建一个组件 1ng g component use/userinfo 在use.module.ts将userinfo组件暴露出去 1234567@NgModule({ declarations: [UseComponent, UserinfoComponent], imports: [ CommonModule ], exports: [UseComponent] //暴露组件}) 5.在根组件app.module.ts中引入use模块并注入 12345678910111213141516171819202122import { BrowserModule } from '@angular/platform-browser';import { NgModule } from '@angular/core';import { AppRoutingModule } from './app-routing.module';import { AppComponent } from './app.component';//引入自定义模块import { UseModule } from './use/use.module'@NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, AppRoutingModule, UseModule //注入模块 ], providers: [], bootstrap: [AppComponent]})export class AppModule { } 6.在根模块的根组件app.component.html中使用自定义模块的组件 12&lt;!--The content below is only a placeholder and can be replaced.--&gt;&lt;app-use&gt;&lt;/app-use&gt; 这样就完成了自定义的模块的组件在其他模块中使用","link":"/2019/08/04/Angular中的内置模块以及自定义模块/"},{"title":"Angular中的数据请求","text":"不论你使用什么技术，数据请求都是必不可少的，因为我们需要保持数据的同步和交互 Angular中的数据请求使用angular自带的HttpClient请求数据 要使用HttpClient，需要在app.module.ts中引入如下模块 12//引入HttpClientModuleimport { HttpClientModule } from '@angular/common/http' 注入模块: 1234 imports: [ BrowserModule, HttpClientModule //注入HttpClientModule], 在需要使用http请求的组件中引入HttpClient 12//引入HttpClient模块import { HttpClient } from '@angular/common/http' 在constructor初始化 1constructor(public http: HttpClient) { } 这样就可以同http.get()发送请求了 发送get请求 比如定义一个button按钮获取数据 123//news.html&lt;button (click)='getData()'&gt;发送请求&lt;/button&gt; 定义事件函数 1234567getData() {let api = \"http://a.itying.com/api/productlist\"this.http.get(api) .subscribe(response =&gt; { console.log(response); })} 这样就完成了get请求并成功拿到数据 发送post请求 发送post请求除了需要引入以上的模块之外，还需要引入请求头HttpHeaders模块 12//news.html&lt;button (click)=\"postData()\"&gt;发送post请求&lt;/button&gt; 1234567891011 import { HttpClient, HttpHeaders } from '@angular/common/http' postData() { const httpOptions = { headers: new HttpHeaders({ 'Content- Type': \" application /json\" }) } this.http.post('url', { username: 'kebo' }) //这样就可以发送post请求了 .subscribe(response =&gt; { console.log(response); })} 在这里如果没有接口的话我们可以使用nodejs自己制作一个简单的接口，当然使用PHP、java、python都可以 123456789101112131415161718192021222324252627var express = require('express');var app = express();var bodyParser = require('body-parser');app.use(bodyParser.json());app.use(bodyParser.urlencoded({ extended: false }));/*express允许跨域*/app.all('*', function (req, res, next) { res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Headers\", \"Content-Type,Content-Length, Authorization, Accept,X-Requested-With\"); res.header(\"Access-Control-Allow-Methods\", \"PUT,POST,GET,DELETE,OPTIONS\"); res.header(\"X-Powered-By\", ' 3.2.1') if (req.method == \"OPTIONS\") res.send(200); else next();});app.get('/', function (req, res) { res.send('首页');})app.post('/dologin', function (req, res) { console.log(req.body); res.json({ \"msg\": 'post成功' });})app.get('/news', function (req, res) { //console.log(req.body); res.jsonp({ \"msg\": '这是新闻数据' });})app.listen(3000, '127.0.0.1'); package.json依赖 12345678 { \"dependencies\": { \"ejs\": \"^2.5.6\", \"express\": \"^4.15.3\", \"socket.io\": \"^2.0.3\", \"body-parser\": \"~1.17.1\" }} 使用只需要创建一个app.js黏贴上面的代码，创建一个package.json复制以上依赖然后 cnpm i即可，运行时找到你这个文件的目录 node app.js即可运行 发送Jsonp请求 发送Jsonp请求需要在app.module.ts引入HttpClientJsonpModule 1import { HttpClientModule,HttpClientJsonpModule } from '@angular/common/http' 注入HttpClientJsonpModule 12345 imports: [ BrowserModule, HttpClientModule, //注入HttpClientModule HttpClientJsonpModule //注入HttpClientJsonpModule], 定义一个button发送jsonp请求 12345 jsonp() { let api = \"http://a.itying.com/api/productlist\" this.http.jsonp(api, 'callback') .subscribe(response =&gt; console.log(response))} 使用axios发送数据 在Vue、React中，我们经常使用axios来发送数据请求，在Angular中也可以使用 安装:cnpm i axios -S 引入： 1import axios from 'axios' 使用方式很简单，和以前的一样 1234axios.get('url').then(response=&gt;{ console.log(response)}) 以上就是一些Angular中的数据请求的一些相关知识了。","link":"/2019/08/04/Angular中的数据请求/"},{"title":"Angular中的路由","text":"在Angular中，angular的路由使用与Vue非常相似 Angular中的路由配置路由 在app-routing.module.ts中引入需要配置路由的组件和配置路由 1234567891011121314151617181920212223import { NgModule } from '@angular/core';import { Routes, RouterModule } from '@angular/router';//引入需要配置的组件import { NewsComponent } from './components/news/news.component';import { HomeComponent } from './components/home/home.component';import { FooterComponent } from './components/footer/footer.component';//配置路由const routes: Routes = [{ path: 'home', component: HomeComponent}, { path: 'news', component: NewsComponent}, { path: 'footer', component: FooterComponent}];@NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule]})export class AppRoutingModule { } 点击路由跳转到对应的组件 12345678910111213//app.html&lt;!--The content below is only a placeholder and can be replaced.--&gt;&lt;header class=\"header\"&gt; &lt;a [routerLink]=\"[ '/home' ]\"&gt;首页&lt;/a&gt; // &lt;a routerLink=\"/home\"&gt;首页&lt;/a&gt; //这样也是可以的 &lt;a [routerLink]=\"[ '/news' ]\"&gt;新闻资讯&lt;/a&gt; &lt;a [routerLink]=\"[ '/footer' ]\"&gt;尾部&lt;/a&gt;&lt;/header&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt; 这个时候已经实现了点击显示对应的组件了，但是我们会发现一进入页面默认是没有组件显示的，这样的话并不好，需要重定向路由 Angular中使用'**'来表示没有匹配到路由后，使用redirectTo重定向，比如我们一打开页面要进入首页 1234567891011//配置路由const routes: Routes = [{ path: 'home', component: HomeComponent}, { path: 'news', component: NewsComponent}, { path: 'footer', component: FooterComponent}, { path: '**', redirectTo: 'home'}]; 这样就实现了重定向的功能 选中路由高亮 我们希望路由选中时有高亮，在Angular中其实已经给我们提供了这个功能，和Vue非常相似，只需要在路由中加入routerLinkActive=&quot;active&quot;就可以了，我们可以自己设置active这个类的样式，达到自己想要的选中效果","link":"/2019/08/04/Angular中的路由/"},{"title":"Angular中的自定义模块以及路由模块的懒加载","text":"在很多公司中，模块的路由是经常使用的，因为可以提升性能，增加用户体验 Angular中的自定义模块以及路由模块的懒加载为什么使用懒加载 如果我们有上百个组件，在app把上百个组件都加载进来，那么响应速度会很慢，不利于用户的体验，但是在Angular中，为我们提供了解决办法，就是路由的懒加载 创建一个自定义根模块modules 1ng g module module 在根模块下创建子模块并创建组件 12ng g module module/user --routing //创建模块的路由ng g component module/user //创建模块的组件 再按照以上方式分别创建article、product模块的路由和组件 使用路由实现模块的懒加载 在刚才创建的三个模块中，分别在自己的模块下面的routing-module.ts中引入以下,path为空表示你加载user模块的时候显示这个组件，，当然你想在user或其他模块中引入其他组件，你只需要添加以下路由规则就可以了 123456//article模块//在自己模块的路由中将自己的根组件加载进来import { ArticleComponent } from './article.component'const routes: Routes = [{ path: '', component: ArticleComponent}]; 12345//product模块import { ProductComponent } from './product.component'const routes: Routes = [ { path: '', component: ProductComponent }]; 12345//user模块import { UserComponent } from './user.component'const routes: Routes = [ { path: '', component: UserComponent }]; 然后在app.routing.module.ts中配置懒加载路由,注意。此时并没有引入模块，而是直接加载，通过匹配到指定的路由，然后再加载该模块，实现懒加载 12345678910111213141516import { NgModule } from '@angular/core';import { Routes, RouterModule } from '@angular/router';const routes: Routes = [ { path: 'user', loadChildren: './modules/user/user.module#UserModule' }, { path: 'product', loadChildren: './modules/product/product.module#ProductModule' }, { path: 'article', loadChildren: './modules/article/article.module#ArticleModule' }, { path: '**', redirectTo: 'user' }];@NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule]})export class AppRoutingModule { } 配置好后在app.component.html中定义路由链接 1234567891011&lt;header&gt; &lt;a [routerLink]=\"[ '/user' ]\"&gt;用户模块&lt;/a&gt; &lt;a [routerLink]=\"[ '/article' ]\"&gt;文章模块&lt;/a&gt; &lt;a [routerLink]=\"[ '/product' ]\"&gt;商品模块&lt;/a&gt;&lt;/header&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt; 这样就实现了路由的懒加载了，原理就是当你点击路由的链接时，他会在路由规则中寻找匹配的路由，匹配成功后就会去加载对应的路由模块，提升性能和加载速度 组件嵌套 在一般情况下，我们把功能一样或者类别一样的组件放在一个自定义的模块中，那么一个模块就有许多的子组件，我们来看一下自定义模块怎么配置子组件 以product模块为例，我们创建一下cars、lists组件 ng g component modules/product/cars ng g component modules/product/lists 创建成功后在product.routing.module.ts引入并配置 12345678910111213141516171819202122import { NgModule } from '@angular/core';import { Routes, RouterModule } from '@angular/router';import { ProductComponent } from './product.component'//引入子组件import { CarsComponent } from './cars/cars.component';import { ListsComponent } from './lists/lists.component';const routes: Routes = [ { path: '', component: ProductComponent }, //配置子组件的路由 { path: 'cars', component: CarsComponent }, { path: 'lists', component: ListsComponent }];@NgModule({ imports: [RouterModule.forChild(routes)], exports: [RouterModule]})export class ProductRoutingModule { } 配置完成后，我们就可以通过/product/cars或者/product/lists来访问这些子组件了，但是这样相当于和一开始引入的ProductComponent根组件形成了兄弟关系，他们只能有一个被挂载到app根组件中，他们并不能共存，如果需要共存，那么我们需要这样配置它 12345678910111213141516171819202122232425import { NgModule } from '@angular/core';import { Routes, RouterModule } from '@angular/router';import { ProductComponent } from './product.component'//引入子组件import { CarsComponent } from './cars/cars.component';import { ListsComponent } from './lists/lists.component';const routes: Routes = [ { path: '', component: ProductComponent, children: [ //配置子组件的路由 { path: 'cars', component: CarsComponent }, { path: 'lists', component: ListsComponent }] },];@NgModule({ imports: [RouterModule.forChild(routes)], exports: [RouterModule]})export class ProductRoutingModule { } 这样配置还需要在根组件中的product.component.html引入路由容器来显示子组件 1&lt;router-outlet&gt;&lt;/router-outlet&gt; 这样就形成了父子组件的嵌套了","link":"/2019/08/04/Angular中的自定义模块以及路由模块的懒加载/"},{"title":"Angular的服务以及数据的持久化存储","text":"为什么使用服务?在很多服务中，比如 $location 服务，它可以使用 DOM 中存在的对象，类似 window.location 对象，但 window.location 对象在 AngularJS 应用中有一定的局限性 Angular 服务以及数据的持久化存储 使用 Angular 的服务可以在应用中使用。 创建服务 使用命令行创建服务:ng g service services/storag 这个命令表示创建一个 services 文件夹，里面创建 storag 服务 引入服务 在app.module.ts中引入创建的服务，并且声明12345//引入import {StorageService} from './services/storage.service'//声明 providers: [StoragService], 使用 引入服务 1import {StorageService} from '../../services/storage.service' 初始化服务: 123constructor(public storage: StoragService) {//初始化服务this.storage.getData() //使用服务} 注意：服务需要在 services 下的 storage.service.ts 中自己创建，由于我创建了如下方法，才能在使用的服务的时候调用该方法 123getData() {console.log('😄');} 我们一般使用 storage 做本地数据的持久化存储的功能可以封装一下几个方法 123456789set(key: string, value: any) { //定义存储的方法 localStorage.setItem(key, value) } get(key:string) { //定义获取数据的方法 return JSON.parse(localStorage.getItem(key)) } remove(key:string) { //定义删除数据的方法 localStorage.removeItem(key) } 调用的时候在任何组件中初始化完毕后直接可以使用this.storage.方法名来使用服务中的方法 注意：因为 Angular 使用的是 Typescript 语法，所以我们尽量定义数据类型，以免引起不必要的错误。 在 Angular 中，组件与组件之间可以相互传值，不能相互调用，组件可以调用服务，但是服务不能调用组件，但是服务与服务之间是可以相互调用的。 以上就是一些关于 Angular 数据持久化存储的一些相关使用。","link":"/2019/07/23/Angular的服务以及数据的持久化存储/"},{"title":"Angular中路由传值","text":"Angular中的路由传值稍微和React、Vue中有所区别，方式和功能相对丰富 Angular中路由传值get传值 Angular中get传值，只需要在路由加入一项参数即可 我们定义一个数组，里面放10条数据,然后循环这个数组 1234//news-info.html&lt;li *ngFor=\"let item of list;let i=index\"&gt;&lt;a routerLink=\"/newsinfo\" [queryParams]=\"{id:i}\"&gt;{{i}} ---{{ item}}&lt;/a&gt;&lt;/li&gt; 我们将下标作为id传入，然后在组件中获取到传入的id，当然也可以在对象中传递多个参数 1234567891011121314151617181920212223242526//news-info.tsimport { Component, OnInit } from '@angular/core';//1.引入 ActivatedRouteimport { ActivatedRoute } from '@angular/router'@Component({ selector: 'app-news-info', templateUrl: './news-info.component.html', styleUrls: ['./news-info.component.scss']})export class NewsInfoComponent implements OnInit { public list: any[] = [] //2.初始化ActivatedRoute constructor(public route: ActivatedRoute) { //3.获取数据 this.route.queryParams.subscribe(data =&gt; console.log(data)) } ngOnInit() { //添加10条数据 for (let i = 0; i &lt;= 10; i++) { this.list.push(`第${i}个数据`) } }} 这样就获取到了这个传递的参数 动态路由传值 配置动态路由 1234//app.routing.module.ts{ path: 'newsinfo/:id', component: NewsInfoComponent} 传值路由参数,两种方式，任选一种 12345//news-info.html&lt;li *ngFor=\"let item of list;let i=index\"&gt;// &lt;a routerLink=\"/newsinfo/{{i}}\"&gt;{{i}}--{{item}}&lt;/a&gt;&lt;a [routerLink]=\"[ '/newsinfo', i ]\"&gt;{{i}}--{{item}}&lt;/a&gt;&lt;/li&gt; 获取传递的值 12345678910111213141516171819202122232425262728//news-info.tsimport { Component, OnInit } from '@angular/core';//1.引入 ActivatedRouteimport { ActivatedRoute } from '@angular/router'@Component({ selector: 'app-news-info', templateUrl: './news-info.component.html', styleUrls: ['./news-info.component.scss']})export class NewsInfoComponent implements OnInit { public list: any[] = [] //2.初始化ActivatedRoute constructor(public route: ActivatedRoute) { //3.get传值获取数据 this.route.queryParams.subscribe(data =&gt; console.log(data)) //动态路由获取数据 this.route.params.subscribe(data =&gt; console.log()) } ngOnInit() { //添加10条 for (let i = 0; i &lt;= 10; i++) { this.list.push(`第${i}个数据`) } }} js跳转路由动态路由的js跳转 引入： 1import { Router } from '@angular/router'; 初始化 12345678constructor(private router: Router) {}ngOnInit() {}goNews(){// this.router.navigate(['/news', hero.id]);//如果是动态路由this.router.navigate(['/news']); //静态路由} get传值js跳转 引入 1import { Router ,NavigationExtras} from '@angular/router'; 定义一个goNewsInfo方法进行跳转并传参 1234567goNewsContent(){let navigationExtras: NavigationExtras = {queryParams: { 'session_id': '123' },fragment: 'anchor'};this.router.navigate(['/news'],navigationExtras);} 获取get传值 123 constructor(private route: ActivatedRoute) { console.log(this.route.queryParams);}","link":"/2019/08/04/Angular中路由传值/"},{"title":"ES6中的模块导入与导出","text":"在 ES6 前， 实现模块化使用的是 RequireJS 或者 seaJS（分别是基于 AMD 规范的模块化库， 和基于 CMD 规范的模块化库）。ES6 引入了模块化，其设计思想是在编译时就能确定模块的依赖关系，以及输入和输出的变量。ES6 的模块化分为导出（export） @与导入（import）两个模块 导入与导出模块 在 Nodejs 中，提供了module.exports和exports向暴露(导出)成员接口，使用require('')使用导入的对象 ES6 中的导入 在 ES6 中，也规定了导入和导出模块 ES6 中导入模块使用 import 模块名称 from '模块标识符'的方式导入 或 import '标识路径' ES6 中的导出 在 ES6 中，使用export default 和 export来暴露成员 两者导出的区别 使用export default: 来暴露成员时，在全局中，只允许定义一个export default 使用export来暴露成员时，可以定义多个export 两者导入的区别 在import 模块名称 from '模块标识符' 导入模块时，我们需要注意以下模块中是否同时使用了使用export default 和 export来暴露成员，如果只使用了export default 那么我们只需要自定义一个模块名称来接收数据即可 1234 export default { //导出 name: '张三', age: 16} 1import test from 'test' //引入 如果使用了export来暴露成员时，不管有没有使用export default 暴露成员，我们导出模块定义的成员名字和导入模块引入的名字必须一致，否则会出错 如果仅使用 export 暴露，我们只需要将成员名使用 { } 包括起来即可，且不能省略{ } 1export const a = 'text中的export' //导出 1import { a } from './test' //引入 ，不能省略 { } 如果我们同时使用了两种暴露方式或使用 export 定义了多个成员，只要按需导出即可 123456export default {name: '张三',age: 16 }export const test = 'text中的export'export const test2 = 'text2中的export' 1import test,{ test} from './text' //虽然定义了test2，但是我们可以根据需要不导出，导出在{}中加入即可 export 导出时修改名称 我们发现使用export default 暴露时没有导入名称的规定，但是使用export暴露必须使用定义时的名字，其实我们可以使用 as 进行修改 1import test,{ test as a,test2 as b} from './text' 注意: ES6 的模块自动开启严格模式，不管你有没有在模块头部加上 use strict。 模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等 每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域 每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取","link":"/2019/07/09/ES6中的模块导入与导出/"},{"title":"ES7-async的使用","text":"async是现在解决异步的最好方法，通过同步的流程表达和完成了异步的操作。 async(ES7) 概念：真正意义上去解决异步回调的问题，同步流程表达异步操作 语法： 1234async function foo(){ await 异步操作; await 异步操作;} 特点：不需要像Generator去调用next方法，遇到await等待，当前的异步操作完成就往下执行 返回的总是Promise对象，可以使用then方法进行下一步操作 async取代Generator函数的 * 号，await取代yield 1234567async function asyncprint(){ let result = await Promise.resovle('Promise') console.log(reslue) //Promise 说明成功了可以返回值 resulte = await Promise.reject(\"失败了\") console.log(resulut) // 抛出异常错误}asyncprint() 一个获取新闻的demo 12345678910111213141516async function getnews(url){return new Promise((resolve,reject)=&gt;{ $.ajax({ method:'GET', url, success:data=&gt;resolve(data) //将data返回出去，作为函数的返回值 error:err=&gt;reject() })})}async function sendXml(){ let result = await getnews('http://localhost:8080/news?id=5') console.log(result) //可以接收返回值 let comment = await getnews('http://localhost:8080/news'+comment.commentUrl) //这样我们从返回值中再拿到数据再去发请求拿到评论列表} 如果失败了我们可以使用这样的方法来传递错误信息 1234567891011121314151617async function getnews(url){return new Promise((resolve,reject)=&gt;{ $.ajax({ method:'GET', url, success:data=&gt;resolve(data) error:err=&gt;resolve(false) //我们这里也使用resolve,但是传一个值，因为用户是不会看控制台的 })})}async function sendXml(){ let result = await getnews('http://localhost:8080/news?id=5')//那么我们在这里接受到的就是false if(!result){window.alert('暂无新闻内容') return;}//这样就不会往下执行了 console.log(result) let comment = await getnews('http://localhost:8080/news'+comment.commentUrl) }","link":"/2019/08/09/ES7-async的使用/"},{"title":"Express框架的安装和基本使用","text":"Express框架是基于Nodejs的框架,非常简洁,但是功能非常强大. Express框架的安装和基本使用 安装：cnpm i express -save-dev 引入:const express= require(&quot;express&quot;) 实例化:const app =express(),也可以使用const app=new express() 使用 12345678const express = require('express')const app = express()const port = 3000//配置静态路由规则app.get('/', (req, res) =&gt; res.send('Hello World!')) //使用express的send方法app.get('/news', (req, res) =&gt; res.end('xixi'))//使用原生的end方法app.listen(port, () =&gt; console.log(`Example app listening on port port!`)) 配置动态路由 1234567891011const express = require('express')const app = express()const port = 3000//配置静态路由app.get('/', (req, res) =&gt; res.send('Hello World!')) //使用express的send方法//配置动态路由，传递idapp.get('/news/:id', (req, res) =&gt; res.send('新闻'))app.listen(port, () =&gt; console.log(`Example app listening on port port!`)) 获取动态路由的值,使用req.params可以获取传递的数据对象,req.params.属性名获取传递的值 1234567891011121314const express = require('express')const app = express()const port = 3000//配置静态路由app.get('/', (req, res) =&gt; res.send('Hello World!')) //使用express的send方法//配置动态路由，传递idapp.get('/news/:id', (req, res) =&gt; { console.log(req.params); //获取传递过来的数据{} res.send('新闻' + req.params.id)})app.listen(port, () =&gt; console.log(`Example app listening on port port!`)) get传值与获取，使用/news?id=5&amp;name=&quot;zs&quot;这种形式传值 1234567891011121314151617const express = require('express')const app = express()const port = 3000//配置静态路由app.get('/', (req, res) =&gt; res.send('Hello World!')) //使用express的send方法//get传值// http://localhost:3000/product?id=5&amp;name=\"zs\"app.get('/product', (req, res) =&gt; { console.log(req.query); res.send('product' + req.query.id + \"------\" + req.query.name)})app.listen(port, () =&gt; console.log(`Example app listening on port port!`))","link":"/2019/08/04/Express框架的安装和基本使用/"},{"title":"ES6遍历数组和对象的一些方法","text":"在很多时候，我感觉数组遍历和对象遍历总是必不可少的，所以我整理出来了遍历数组和对象的一些方法。 ES6遍历数组的一些方法 forEach() 1234let arr = [1,2,3,4,5]; arr.forEach(function(item,index){ console.log('forEach',item);}); map()可以遍历数组中的每项并且进行某一种运算，产生一个新数组 123456let arr = [1,2,3,4,5];let newArrmap = arr.map(function(item,index){ console.log('map', item); return item * 2; });console.log('map',newArrmap); filter()筛选出数组中符合条件的项，组成新数组 123456let arr = [1,2,3,4,5];let newArrfilter = arr.filter(function(item,index){ console.log('filter',item); return item&gt;3;});console.log('filter',newArrfilter); reduce()让数组中的前项和后项做某种计算，并累计最终值 123456let arr = [1,2,3,4,5];let result = arr.reduce(function(prev,next){ console.log('reduce',prev); return prev + next;});console.log('reduce',result); // result 15 every()检测数组中的每一项是否符合条件 123456let arr = [1,2,3,4,5];let res = arr.every(function(item,index){ console.log('every',item); return item &gt; 0;});console.log('every',res); // true 全部满足才为 true some()检测数组中是否有某些项符合条件 123456let arr = [1,2,3,4,5];let resu = arr.some(function(item, index){ console.log('some',item); return item &gt; 0;});console.log('some', resu); //一个true则为true 数组的排序 顺序排序 123var a = [3, 2, 5, 7];//顺序排序console.log(a.sort()) 逆序排序 123//逆序排序console.log(a.sort().reverse())console.log(a.sort(function (a, b) { return b - a })) 遍历对象的一些方法 使用Object.keys()遍历，返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性). 123456var obj = {'0':'a','1':'b','2':'c'}; Object.keys(obj).forEach(function(key){ console.log(key,obj[key]); 使用for..in..遍历,循环遍历对象自身的和继承的可枚举属性(不含Symbol属性). 123456var obj = {'0':'a','1':'b','2':'c'}; for(var i in obj) { console.log(i,\":\",obj[i]); 使用Object.getOwnPropertyNames(obj)遍历,返回一个数组,包含对象自身的所有属性(不含Symbol属性,但是包括不可枚举属性). 1234var obj = {'0':'a','1':'b','2':'c'};Object.getOwnPropertyNames(obj).forEach(function(key){console.log(key,obj[key]);}) 使用Reflect.ownKeys(obj)遍历,返回一个数组,包含对象自身的所有属性,不管属性名是Symbol或字符串,也不管是否可枚举. 1234var obj = {'0':'a','1':'b','2':'c'};Reflect.ownKeys(obj).forEach(function(key){console.log(key,obj[key]);})","link":"/2019/08/09/ES6遍历数组和对象的一些方法/"},{"title":"Express路由的模块化","text":"在每个项目中，路由的使用是必不可少的，尤其是大型项目中，规则的配置路由会在我们后期维护代码的时候显得非常方便，就相当于给每个页面或功能归类，修改找到类别就定位到了需要修改的地方。 Express的模块化路由什么是模块化路由？ 模块化路由就是将某些功能或类型相同的路由生成到一个模块中，比如：商品功能的服务，有上传修改删除等功能，我们需要单独的封装成一个路由模块 为什么要模块化路由 方便后期维护，减少代码冗余 Express模块化路由 Express中我们使用const router=express.Router()来进行路由的模块化 123456789101112/routers/admin.jsconst express = require('express')const router = express.Router()router.get('/', (req, res) =&gt; { res.send('admin')})//暴露这个模块module.exports = router 这样就暴露了管理模块的路由 123456789101112//app.jsconst express = require('express')const app = express()const port = 3000//引入路由模块const admin = require('./routers/admin')app.use('/admin', admin)app.listen(port, () =&gt; console.log(`http://localhost:` + port)) 然后，我们通过中间件的配置方式，配置路由模块，这样我们可以通过http://localhost:3000/admin访问到admin模块中的/路由；http://localhost:3000/admin中的admin就相当于路由模块 当然，我们可以在admin中引入login、resgin等模块，然后在login,resgin模块中来处理相关的模块，这样就形成了路由层层嵌套 路由嵌套 示例：我们在app中写入一些所有模块都需要的一些插件，还有配置主模块，因为在大型的项目中可能有许多的模块，如管理模块，用户模块等等,之后可以通过http://localhost:3000/admin访问管理模块,http://localhost:3000/user访问用户模块等等 在这里我们只以管理模块做示范，通过中间件的形式配置 123456789101112131415161718192021222324252627//app.jsconst express = require('express')const app = express()const session = require('express-session')const port = 3000const admin = require('./routers/admin')//表示使用ejs模板引擎，当然你也可以使用art-template模板引擎app.set('view engine', 'ejs')app.use(express.static('./public'))app.use('/uploadImages', express.static('./uploadImages'))//配置图片地址文件夹//配置sessionapp.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true, cookie: { maxAge: 1000 * 60 * 30, }, rolling: true}))app.use('/', index)app.use('/admin', admin)app.listen(port, () =&gt; console.log(`http://localhost:` + port)) 这里我们在admin中引入admin/的子路由模块，到时候可以通过http://localhost:3000/admin/xxx访问 12345678910111213141516171819202122232425262728//admin.js//引入模块const login = require('../routers/admin/login')const product = require('./admin/product.js')const user = require('../routers/admin/user')router.use((req, res, next) =&gt; { if (req.url == '/login' || req.url == '/login/dologin' || req.url == '/login/resgin' || req.url == '/logoin/doresgin') { //除去这两个 next() } else { if (req.session.userinfo &amp;&amp; req.session.userinfo.username != '') { //判断是否有用户信息 //使用ejs设置全局属性，可以在任意的ejs模板中获取 req.app.locals['userinfo'] = req.session.userinfo next() } else { res.redirect('/admin/login') } }})//配置路由中间件，到时候只需要http://localhost:3000/admim/login就可以访问login模块的路由router.use('/login', login)router.use('/product', product)router.use('/user', user)//暴露这个模块module.exports = router 在这里我们继续做路由的详细的处理，到时候可以通过http://localhost:3000/admin/xxx/xxx访问，示例,http://localhost:3000/admin/login/xxx 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//login.jsconst express = require('express')const router = express.Router()const bodyParser = require('body-parser')const DB = require('../../modules/db')const md5s = require('../../md5')// //引入并配置body-parser中间件,并按需引入const jsonParser = bodyParser.json()const urlencodedParser = bodyParser.urlencoded({ extended: false })//登陆页面router.get('/', (req, res) =&gt; { res.render('admin/login/login')})//验证登陆表单router.post('/dologin', urlencodedParser, (req, res) =&gt; { //将数据重新转换一下，因为req.body有一些没有作用的数据 let body = JSON.parse(JSON.stringify(req.body)) DB.find('user', { \"username\": body.username, \"password\": md5s.md5(body.password) }, (err, result) =&gt; { if (err) throw err if (result.length &gt; 0) {//如果大于0表示有数据 req.session.userinfo = result[0] //将用户数据保存到session中 res.status = 200 res.redirect('/admin/product') } else {//如果等于0表示没有数据 res.status = 300 res.send('&lt;script&gt;alert(\\'用户名或密码错误\\');location.href=\"/admin/login\"&lt;/script&gt;') } })})//注册页面router.get('/resgin', (req, res) =&gt; { res.render('admin/login/resgin')})//注册表单router.post('/resgin', urlencodedParser, (req, res) =&gt; { let body = JSON.parse(JSON.stringify(req.body)) body.password = md5s.md5(body.password) //将密码进行加密 DB.find('user', { \"username\": body.username }, (err, result) =&gt; { if (err) throw err if (result.length &gt; 0) {//如果大于0表示有数据,不能注册 res.send('&lt;script&gt;alert(\"此用户已被注册\");location.href=\"/admin/resgin\"&lt;/script&gt;') } else {//如果等于0表示没有数据 DB.insertOne('user', body, (err, result) =&gt; { if (err) throw err res.send('&lt;script&gt;alert(\"注册成功，即将前往登陆页面\");location.href=\"/admin/login\"&lt;/script&gt;') }) } })})//退出router.get('/loginout', (req, res) =&gt; { //销毁session req.session.destroy(err =&gt; { if (err) throw err res.redirect('admin/login') })})//暴露这个模块module.exports = router 以上我作出了模块化路由的嵌套，如果你想详细了解代码，可以在我的github中下载源码，进行查看。","link":"/2019/08/08/Express路由的模块化/"},{"title":"Koa中使用koa-static中间件配置静态文件","text":"由于koa中自身不绑定任何的中间件，所以我们需要手动的将配置静态文件的中间件引入 Koa中的koa-static中间件的使用 在express中我们如果需要配置静态文件，直接以app.use(express.static(''))就可以配置，但是因为在koa中没有绑定任何的中间件，所以我们如果需要使用中间件，那么我们就需要自己去手动去配置 koa-static中间件的使用 安装:cnpm i koa-static --save 配置：app.use(serve('/test/fixtures')) 使用： 12345//引入const static = require('koa-static')//配置,两种方式，一种带绝对路径的，是被推荐的// app.use(static('public'))app.use(static(__dirname + '/public')) 配置完成后我们使用就根目录中的public文件夹下的文件文件就可以直接使用了，如使用public/css/style.css，引用的 时候直接css/style.css即可","link":"/2019/08/12/Koa中使用koa-static中间件配置静态文件/"},{"title":"Koa中使用session","text":"在express中我们已经说到过了session及其原理，安全性比cookie高，在这里我们直接看在koa中如何使用session Koa中使用session 同样的，在express中我们已经说到过了session及其原理，安全性比cookie高，在这里我们直接看在koa中如何使用session 使用session 安装:cnpm i koa-session --save 引入：const session=require('koa-session') 配置session 1234567891011121314151617181920212223242526272829const session = require('koa-session');const Koa = require('koa');const app = new Koa(); app.keys = ['some secret hurr']; const CONFIG = { key: 'koa:sess', //cookie的签名 maxAge: 86400000,//过期时间，默认是一天 autoCommit: true, //自动添加请求头，默认是添加的 overwrite: true,//能否覆盖session，默认是可以 httpOnly: true, //是否在服务端才能访问，默认是true signed: true, //是否签名，默认是true rolling: false, //每次访问页面或对页面进行操作时重置session过期时间，默认是false renew: false, //当session快过期的时候如果还在操作是否重置seesion过期时间，默认是false}; app.use(session(CONFIG, app));//使用自定义的session配置，如果你想使用默认的配置可以这样使用app.use(session(app)); app.use(ctx =&gt; { // 忽略 favicon if (ctx.path === '/favicon.ico') return; let n = ctx.session.views || 0; ctx.session.views = ++n; ctx.body = n + ' views';}); app.listen(3000); 设置session 1ctx.session.username='zs' 获取session 1ctx.session.username","link":"/2019/08/12/Koa中使用session/"},{"title":"Koa中的路由与动态路由和get传值","text":"路由传值是在开发中的家常便饭了，不论是在Nodejs中，还是在PHP等语言上，都是非常常用的，我们来看一下在node中如何使用路由传值 Koa中的路由与动态路由和get传值什么是路由？ 路由是由一个URL(路径)和一个特定的HTTP方法(GET、POST等)组成，涉及应用如何响应客户端对某个网站节点的访问。 通俗的讲就是路由根据不同的URL地址，加载不同的页面响应不同的内容实现不同的功能。Koa中的路由 Koa的路由和Express有所不同，在Express中直接引入express就可以配置路由，但是koa需要安装路由模块 安装:cnpm i koa-router --save 基本的路由配置 1234567891011121314151617181920const koa = require('koa') const app = new koa() //引入路由 const Router = require('koa-router') //实例化路由 const router = new Router() //首页 router.get('/', async ctx =&gt; { cxt.body = \"Home\" }) .get('/admin',async ctx =&gt; { cxt.body = \"管理页面\" }) //启动路由并配置端口 app .use(router.routes()) .use(router.allowedMethods()) .listen(3000, console.log(\"http://localhost:3000\")) Koa路由获取GET传值的值 在koa中GET传值通过request接收，但是接收的方式有两种:(query,querystring) 使用query：返回的是格式化好的参数对象，如：{name:zs,age:12} 使用querystring：返回的是请求字符串 123456789101112131415161718192021222324252627const koa = require('koa')const app = new koa()//引入路由const Router = require('koa-router')//实例化路由const router = new Router()//首页router.get('/',async (ctx) =&gt; { ctx.body = \"Home\" //从ctx中读取GET传值 http://localhost:3000/?name=zs console.log(ctx.query);//输出 [Object: null prototype] { name: 'zs' } console.log(ctx.querystring); //输出 namne=zs 获取的是一个字符串 //从ctx的request中获取 console.log(ctx.request.query);//输出 [Object: null prototype] { name: 'zs' } console.log(ctx.request.querystring); //输出 namne=zs 获取的是一个字符串}) .get('/admin',async ctx =&gt; { ctx.body = \"管理页面\" })//启动路由并配置端口app .use(router.routes()) .use(router.allowedMethods()) .listen(3000, console.log(\"http://localhost:3000\")) koa中的动态路由以及获取动态路由的值 和express一样使用/:id的方式设置的动态路由，使用params获取传递的值 1234567891011121314151617181920212223242526const koa = require('koa')const app = new koa()//引入路由const Router = require('koa-router')//实例化路由const router = new Router()//首页router.get('/', async (ctx) =&gt; { ctx.body = \"Home\"}) .get('/admin/:id', ctx =&gt; { //动态路由 ctx.body = \"管理页面\" //http://localhost:3000/admin/123 console.log(ctx.params); //获取动态路由的传值 {id:'123} }) .get('/news/:id/:title', async ctx =&gt; { //动态路由传递多个值 ctx.body = \"新闻页面\" //http://localhost:3000/news/12/新闻 console.log(ctx.params);//{ id: '12', title: '新闻' } })//启动路由并配置端口app .use(router.routes()) .use(router.allowedMethods()) .listen(3000, console.log(\"http://localhost:3000\"))","link":"/2019/08/10/Koa中的路由与动态路由和get传值/"},{"title":"Ionic的安装运行","text":"ionic起初是为Angular打造的ui组件库，但是后面因为收到欢迎，就又支持了Vue和React，功能非常强大 Ionic的安装运行 目前Ionic已经支持了Vue、angular、react三大框架 只要有相关基础的就可以使用Ionic 安装 cnpm i -g cordova ionic 查看是否安装：ionic -v 创建项目 cd到你要创建项目的文件夹 创建的方式 ionic start my-app直接创建空项目 ionic start my-app tabs，创建有tabs的项目，当然你也可以在后面追加多个UI组件 运行项目 ionic serve 创建一个页面并实现跳转 ionic g page 页面名 如果你想要创建其他的组件或者服务，可以使用ng g --help来获取提示 比如我们创建一个button页面，那么我们在tab2中创建一个按钮，导航到这个button页面 123456789101112131415//tab2.html&lt;ion-header&gt; &lt;ion-toolbar&gt; &lt;ion-title&gt; Tab Two &lt;/ion-title&gt; &lt;/ion-toolbar&gt;&lt;/ion-header&gt;&lt;!-- 导航到Button页面 --&gt;&lt;ion-button [routerLink]=\"[ '/button' ]\"&gt; Click me&lt;/ion-button&gt;&lt;ion-content&gt;&lt;/ion-content&gt; 这样就完成了，感觉是真的非常方便，因为配置路由啥的在你生成这个页面的时候全部给你更新好了","link":"/2019/08/04/Ionic的安装运行/"},{"title":"ES6的fetch的使用","text":"在 React 中，我们经常使用这个方法进行数据的获取，它是基于 Promise 封装的一个 API fetch 的使用 在 Vue 中，我们使用 axios 来发起数据请求，但是在 React 中，我们可以使用 ES6 中的 fetch API 来获取数据 fetch API 是基于 promise 封装的 API 使用 fetch 的使用: 1234fetch(url).then(response=&gt;{ console.log(response)}) 这样获取到的 Response 对象只是一些状态，并没有实际想要的数据 但是我们可以调用 response.json()得到一个新的 promise 12345678 fetch(url).then(response=&gt;{ console.log(response) return response.json()}).then(data=&gt;{ console.log(data)}) 当使用 response.json()时，把他返回出去就得到一个新的 promise 对象，再.then 就可以获取到数据了","link":"/2019/07/23/ES6的fetch的使用/"},{"title":"Koa异步处理Async、Await和Promise","text":"koa采用ES6、ES7语法进行处理异步问题，增强了错误处理的能力。 Koa异步处理Async、Await和Promise 因为koa框架是基于ES6、ES7语法的，所以学习之前必须掌握ES6的基本语法，这里不再赘述，我们之前认识koa一些重要的ES6、ES7语法Async Async是异步的简写，await可以认为是async wait的简写，async用于申明一个function是异步的，而await用域等待一个异步方法执行完成 简单的理解 async：让方法变成异步 await：等待异步方法执行完成 普通方法与async方法的区别 1234567891011//普通函数function getData() { return 'Koa'}console.log(getData()); //Koa//async函数async function getData() { return 'Koa'}console.log(getData()); //Promise { 'Koa' } 因为async其实就是基于promise封装的，所以它返回的还是一个promise对象，只要是promise对象，我们就可以使用.then()的方式获数据 12345async function getData() {return 'Koa'}getData() .then(res =&gt; console.log(res)) //Koa 但是，以上这种方法如果获取下一个数据需要上一个数据的结果时，又会形成回调地狱的情况，所以说Promise并没有正真解决回调地狱的问题，所以ES7的async才又一次对回调地域现象做出了解决的方法，就是使用await，以同步的方式处理异步 123456789async function data() {return 'Koa'}async function getData() { let d = await data() //等待data函数执行完毕，将结果赋值给变量d console.log(d); //打印结果}getData() //调用函数进行取值 点击这里，详细了解async","link":"/2019/08/09/Koa异步处理Async、Await和Promise/"},{"title":"Nodejs中的post、get获取表单数据以及路由封装模块","text":"在原生Nodejs中如何获取get和post数据，相对于express框架来说，原生较为麻烦。 Nodejs中的post、get获取表单数据获取get数据 假设有一个登陆页面login.html 123456789101112131415 &lt;h2&gt;登陆&lt;/h2&gt;&lt;form action=\"/dologin\" method=\"get\"&gt; &lt;label id=\"username\"&gt; 用户名: &lt;input name=\"username\" type=\"text\" id=\"username\" /&gt; &lt;/label&gt; &lt;br&gt; &lt;label id=\"password\"&gt; 密码: &lt;input type=\"password\" name=\"password\" id=\"password\"&gt; &lt;/label&gt; &lt;br&gt; &lt;input type=\"submit\" value=\"登陆\"&gt;&lt;/form&gt; 我们在app.js中的路由模块中可以使用url.parse(request.url,true).query拿到传递过来的数据对象 12345678910111213141516171819const http = require('http');const url = require('url')const ejs = require('ejs')const port = 8081http.createServer(function (request, response) { //头文件 response.writeHead(200, { 'Content-Type': 'text/html' }); //过滤掉url中的参数 let pathname = url.parse(request.url).pathname if (pathname == '/dologin') { console.log(url.parse(request.url, true).query) response.end('dologin') }}).listen(port, () =&gt; { console.log('run' + port)}); 这样就成功的获取到了我们传递过来的数据 获取POST传递的数据 使用req.method可以获取请求的类型，判断类型后进行处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const http = require('http')const fs = require('fs')const url = require('url')const ejs = require('ejs')http.createServer(function (request, response) { response.writeHead(200, { 'Content-Type': 'text/html' }); const URL = url.parse(request.url) const pathname = URL.pathname if (pathname == '/') { ejs.renderFile('views/index.html', (error, data) =&gt; { response.end(data) }) } else if (pathname == '/login') { ejs.renderFile('views/login.html', (error, data) =&gt; { response.end(data) }) } else if (pathname == '/dologin') { const method = request.method if (method == 'GET') {//判断请求类型是不是GET console.log(URL.query);//获取get请求的数据，写入文件中 fs.appendFile('./files/user.txt', URL.query + '\\n', error =&gt; { if (error) { console.log(error); } else { response.end(\"&lt;script&gt;alert('登陆成功');history.back()&lt;/script&gt;\") } }) } else if (method == 'POST') { //判断请求类型是不是POST let postData = '' request.on('data', chunk =&gt; { //获取post请求的数据 postData += chunk }) request.on('end', (error, chunk) =&gt; { if (postData) { // 写入文件中 fs.appendFile('./files/user.txt', postData + '\\n', error =&gt; { if (error) { console.log(error); } else { response.end(\"&lt;script&gt;alert('登陆成功');history.back()&lt;/script&gt;\") } }) } }) } }}).listen(8081);console.log('Server running at http://127.0.0.1:8081/'); 封装模块 将路由模块封装单独封装出来,models/model.js 12345678910111213141516171819202122232425262728293031323334353637383940const ejs = require('ejs')const fs = require('fs')const app = { login: function (request, response) { console.log('login'); ejs.renderFile(('views/login.html'), (error, data) =&gt; { response.end(data) }) }, resgin: function (request, response) { console.log(\"resgin\"); ejs.renderFile('views/resgin.html', (error, data) =&gt; { response.end(data) }) }, home: function (request, response) { response.end('home') }, dologin: function (request, response) { let postData = '' request.on('data', chunk =&gt; { //获取post请求的数据 postData += chunk }) request.on('end', (error, chunk) =&gt; { if (postData) { // 写入文件中 fs.appendFile('./files/user2.txt', postData + '\\n', error =&gt; { if (error) { console.log(error); } else { response.end(\"&lt;script&gt;alert('登陆成功');history.back()&lt;/script&gt;\") } }) } }) }}module.exports = app 那么此时router模块就非常简洁了 router.js 12345678910111213141516171819202122const http = require('http');const url = require('url')const model = require('./models/model')http.createServer((request, response) =&gt; { response.writeHead(200, { 'Content-Type': 'text/html' }); //将路由从 /login 切割成 login const pathname = url.parse(request.url).pathname.replace('/', '') //调用model路由模块，使用[]的形式可以传递属性变量 if (pathname != 'favicon.ico') { try { //如果可以找到pathname对应的路由，就执行这个 model[pathname](request, response) } catch{//找不到就执行这个 model['home'](request, response) } }}).listen(8081);console.log('Server running at http://127.0.0.1:8081/');","link":"/2019/08/09/Nodejs中的post、get获取表单数据以及路由封装模块/"},{"title":"MongoDB数据库的备份与还原","text":"数据库的备份与还原也是在操作数据库中常用的操作,但是它们非常简单. MongoDB数据库的备份与还原备份 备份格式： 12345678mongodump--host 127.0.0.1 //主机名--port 27017 。。端口号--out D:/databack/backup //备份路径--collection myCollections //备份的数据表--db test //备份的数据库--username username //用户名--password password //密码 mongodump命令脚本语法如下 1&gt;mongodump -h dbhost -d dbname -o dbdirectory -h： MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017 -d：需要备份的数据库实例，例如：test -o：备份的数据存放位置，例如：c:\\data\\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。 注意： 备份格式中，后面那些参数都是可选的 如果我们不指定数据表和数据库，那么默认全部都会备份,但是备份时我们不用进入数据库，直接在命令行进行备份 1PS C:\\Program Files\\MongoDB\\Server\\4.0\\bin&gt; mongodump --host 127.0.0.1:27017 --out E:\\data\\data 也可以简写成这样 1PS C:\\Program Files\\MongoDB\\Server\\4.0\\bin&gt; mongodump -h 127.0.0.1:27017 -o E:\\data\\home 恢复还原 mongodb使用 mongorerstore 命令来恢复备份的数据。 语法 mongorestore命令脚本语法如下： 1&gt;mongorestore -h dbhost -d dbname --directoryperdb dbdirectory -h：MongoDB所在服务器地址 -d：需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2 –directoryperdb：备份数据所在位置，例如：c:\\data\\dump\\test，这里为什么要多加一个test，而不是备份时候的dump，读者自己查看提示吧！ –drop:恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！ 基本格式 123456mongorestore--host 127.0.0.1--port 27017--username username--password password&lt;path to the backup&gt; 比如我们现在不小心删除了一个collections的数据，要进行恢复。现在删除random集合 1db.random.drop() 使用命令进行恢复 1mongorestore --host 127.0.0.1 --port 27017 E:/data/data","link":"/2019/08/04/MongoDB数据库的备份与还原/"},{"title":"MongoDB用户的创建删除和管理","text":"一般的在一些项目上,我们都是通过用户来登陆数据库和访问数据库的,这样可以更好的管理用户的权限. 用户的创建删除和管理 创建用户,在admim数据库中创建user数据表，在该表中添加用户数据和权限 1234567891011121314151617use admin后db.createUser({// 创建user表user: \"zhong\", //用户名称pwd: \"123456\", //用户密码customData: { //数据 name: 'Mrzhong', //用户名 email: 'web0432@126.com', //邮箱 age: 18,},roles: [{ //权限模块 role: \"readWrite\", // 具体权限 db: \"User\" //赋予该权限的数据库}, 'read' //其他数据库]}) 用户权限的说明： 权限 说明 Read 允许用户读取指定数据库 readWrite 允许用户读写指定数据库 dbAdmin 允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile userAdmin 允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户 clusterAdmin 只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。 readAnyDatabase 只在admin数据库中可用，赋予用户所有数据库的读权限 readWriteAnyDatabase 只在admin数据库中可用，赋予用户所有数据库的读写权限 userAdminAnyDatabase 只在admin数据库中可用，赋予用户所有数据库的userAdmin权限 dbAdminAnyDatabase 只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。 root 只在admin数据库中可用。超级账号，超级权限 删除用户数据 使用db.system.users.remove({要删除的用户信息条件})一般是以用户名为条件 建权 有时候我们要验证用户的用户名密码是否正确，就需要用到MongoDB提供的健全操作。也算是一种登录操作，不过MongoDB把这叫做建权。 建权就是给之前的数据表注册给功能一样，登陆了建权的用户可以和创建用户时的权限做匹配，就是你创建用户的时候允许的权限，建权之后就可以获得权限 如何建权呢？ 1db.auth(\"zhong\",\"123456\") 使用用户名称和密码进行建权，建权成功后返回1 12&gt; db.auth(\"zhong\",\"123456\")1 错误返回 12Error: Authentication failed.0 启动建权 重启数据库服务器，设置必须使用建权登陆 1mongod --auth 启动后，用户登录只能用用户名和密码进行登录，原来的mongo形式链接已经不起作用了。相应的用户权限也对应妥当。实际项目中我们启动服务器必须使用建权形式 登录 如果在配置用户之后，用户想登录，可以使用mongo的形式，不过需要配置用户名密码： 1mongom -u zhong -p 123456 127.0.0.1:27017/admin 登陆成功后，我们可以对指定的User数据库进行读写操作，但是对其他数据库只读，这个时候我们修改其他数据库的数据就会报错 12&gt; db.info.insert({\"name\":\"zs\"}) //这个时test数据库的表WriteResult({ \"nInserted\" : 1 })","link":"/2019/08/04/MongoDB用户的创建删除和管理/"},{"title":"React-native的学习","text":"React-native是基于React框架的移动端技术，与接近原生的框架，性能高，只要你会React你就可以学习React-native。 React-native开发app 配置好Android环境之后，只需要使用react-native init 项目名称 cd 项目名称 react-native run-android即可运行 推荐使用模拟器开发，较为方便 react-native项目的一些说明 在项目的index.js中，从react-native导入的AppRegistery，它的作用就是注册首页的 使用AppRegistery注册项目时，第一个参数是你要做的项目app名称，第二个参数是表示把哪个页面注册为项目的首页 创建自己的首页 在react-native中， 不能使用.jsx文件，只能使用.js 在react-native中,组件的语法与react相似，在组件中也必须要有render函数，但是需要注意的是，RN中，不能使用网页的标签(div,p,img…)，取而代之的是RN的View组件来实现布局 布局的一些说明 使用组件时必须先引入，再使用 必须使用View作为布局容器 文本内容必须使用Text标签包裹 Platform:提供平台检测功能 StyleSheet：样式相关的组件，专门用来创建样式的 Text：文本节点，所有的文本必须放在里面 View：用来布局的，相当于div TextInput：文本框组件 Image:图片组件 Button：按钮组件 ActivityIndicator：加载中的loading图 ScrollView：超出内容后显示滚动条 View 必须将元素放在View中，才能显示 Text 存放文本内容的阿 Image 12使用Image引入图片，引入本地图片:`&lt;Image source={requrie('./1.jpg')} /&gt;`引入网络图片`&lt;Image source={{uri:'http://xxx.xxx.xxx'}} style={{width:200,height:150}} /&gt;`需要设置宽高，否则不显示 Button 使用BUtton必须要一个title属性，作为按钮显示的名字ActivityIndicator 属性：animating(是否要显示加载动画：true or false)、color(颜色)、size(‘large,small’):安卓可以使用数字、hidesWhenStopped(ios)ScrollView 在RN中，内容超出界面不会自动出现滚动条，需要使用ScrollView将元素包裹起来，才会出现滚动条.","link":"/2019/08/04/React-native的学习/"},{"title":"Node中的path路径模块","text":"在Node中，有许多的模块,但是Node.js path 模块提供了一些用于处理文件路径的小工具 Path模块 引入 const path = require('path') path的一些方法path.basename(): 只有一个参数时 有两个参数时，且参数的后缀名相同时 有两个参数时，且参数的后缀名不相同时 总结： 一个参数时直接输出带后缀名的文件名 两个参数时第二个参数为第一个参数的后缀名时输出为不带后缀名的文件名 两个参数时第二个参数不是第一个参数的后缀名时输出仍是带后缀名的文件名path.dirname() 只输出目录 path.extname() 只输出后缀名 path.isAbsolute() 判断是否为绝对路径，返回一个布尔值 注意：文件路径前不能有空格 否则直接返回flase 拓展：绝对路径的两种方式 如：c:/a/b/c/index.js ，有磁盘符，相对于磁盘符的绝对路径 如：/a/b/c/index.js ，没有磁盘符，相对于当前磁盘下的绝对路径path.parse() 查看文件的详细信息 path.join() 路径拼接 在Node中，许多时候我们都需要用到路径模块，对文件路径的判断做出相应的响应","link":"/2019/07/07/Node中的path路径模块/"},{"title":"Nodejs配置MD5加密","text":"在服务端语言中，加密数据是必不可少的，这关系到用户的数据的安全性，我们在一般的使用加密数据时，md5加密用户的密码等信息使用尤其广泛 Nodejs配置MD5加密MD5算法MD5是计算机领域使用最广泛的散列函数(可以叫哈希算法、摘要算法)，注意是用来确保消息的完整和一致性。下面我们最主要是以 md5 加密为例来了解下加密算法。MD5算法有以下特点： 压缩性： 任意长度的数据，算出的MD5值长度都是固定的。 容易计算：从原数据算出MD5值很容易。 抗修改性：对原数据进行任何改动，哪怕只修改一个字节，所得到的MD5值都有很大的区别。 强抗碰撞：已知原数据和其MD5值，想找到一个具有相同的MD5值的伪数据是非常困难的。在nodejs中使用md5加密 使用自带的加密模块crypto 引入模块:const crypto = require('crypto'); 创建一个hash对象const md5=crypto.createHash('md5'); 往hash对象中添加要摘要的内容md5.update(str); 使用digest方法输出内容，如果不适用编码格式的参数，输出的是一个Buffer对象 1console.log(md5.digest()); 使用编码格式的参数，输出的是一个字符串格式的摘要内容 1console.log(md5.digest('hex')); // 输出 900150983cd24fb0d6963f7d28e17f72 完整示例代码如下: 12345678910111213141516const crypto = require('crypto');const str = 'abc';// 创建一个hash对象const md5 = crypto.createHash('md5');// 往hash对象中添加摘要内容md5.update(str);// 使用 digest 方法输出摘要内容，不使用编码格式的参数 其输出的是一个Buffer对象// console.log(md5.digest()); // 输出 &lt;Buffer 90 01 50 98 3c d2 4f b0 d6 96 3f 7d 28 e1 7f 72&gt;// 使用编码格式的参数，输出的是一个字符串格式的摘要内容console.log(md5.digest('hex')); // 输出 900150983cd24fb0d6963f7d28e17f72 但是经过我的实践，发现这个md5如果直接在一个页面上添加摘要内容再输出，只能有一次，如果使用第二次就会报错，如果我们再处理用户的密码的时候往往需要使用加密，所以我们需要将这个md5单独的封装成一个模块，使用的时候调用这个模块即可 123456789//md5.jsexports.md5 = function (str) { //暴露出md5s方法var crypto = require('crypto') //加载加密文件var md5 = crypto.createHash('md5')md5.update(str)str = md5.digest('hex')return str} 这个时候我们使用只需要调用这个模块就行了 12var md5s=require('./md5') //调用模块md5s.md5(str) //使用模块中的方法并传入str 这样就不受限制了，可以一直使用。","link":"/2019/08/06/Nodejs配置MD5加密/"},{"title":"Koa的中间件","text":"Koa的中间件和Express的中间件很相似，但是也有不同的地方，我们来看一下它们的相同之处和不同之处 Koa的中间件 中间件就是匹配路由之前或者匹配路由完成做的一系列操作，我们可以把它叫做中间件。 koa的中间件和express的中间件相似，可以参考我之前的express中间件 这里我就不再赘述中间件的概念，我们直接使用一下你就明白了。应用级中间件 配置应用级中间件 1234567891011121314151617const koa = require('koa')const app = new koa()const Router = require('koa-router')const router = new Router()// 匹配路由前打印日期的中间件app.use( async (ctx, next) =&gt; { //所有的路由都会经过这个中间件，然后输出时间 console.log(new Date()); //输出时间 next() //继续匹配，如果没有继续匹配就只输出时间})router.get('/',async (ctx) =&gt; { ctx.body = \"Home\"})app .use(router.routes()) .use(router.allowedMethods()) .listen(3000, console.log(\"http://localhost:3000\")) 路由级中间件 配置路由级中间件 12345678910111213141516171819const koa = require('koa')const app = new koa()const Router = require('koa-router')const router = new Router()//我们想在这个路由输出1，下一个路由输出2，如果我们直接这样，路由是不会继续往下执行的//这个时候我们需要在参数中添加一个参数next并调用router.get('/', async (ctx, next) =&gt; { ctx.body = \"Home\" console.log(1); await next() //表示路由继续往下匹配}) .get('/', async ctx =&gt; { //只有上面的路由next执行后，这个路由才能匹配 console.log(2); })app .use(router.routes()) .use(router.allowedMethods()) .listen(3000, console.log(\"http://localhost:3000\")) 但是实际的开发中，我们不建议这么写，因为代码多余，但是可以这么写 配置错误处理中间件 在koa中，不像express中的中间件流程是自上而下的，在koa中，中间件会优先执行，尽管你放在最下面，还是会先执行 123456789101112131415161718const koa = require('koa')const app = new koa()const Router = require('koa-router')const router = new Router()router.get('/', async (ctx, next) =&gt; { ctx.body = \"Home\" console.log(2);//2.输出2})app.use(async (ctx, next) =&gt; { console.log(1); //1.输出1 next()})app .use(router.routes()) .use(router.allowedMethods()) .listen(3000, console.log(\"http://localhost:3000\")) 由此可见是先执行了中间件再匹配了路由，所以这个时候我们配置错误处理就需要换一种方式了 123456789101112131415161718192021222324252627const koa = require('koa')const app = new koa()const Router = require('koa-router')const router = new Router()router.get('/', async (ctx, next) =&gt; { //4.匹配到路由，如果没有匹配到状态码也为404 ctx.body = \"Home\" //5.有响应数据，则状态码为200，没有则404 console.log(2);//6.输出2})app.use(async (ctx, next) =&gt; { //1.匹配执行中间件 console.log(1); //2.输出 1 next() //3.去匹配路由 if (ctx.status == 404) {//7.判断状态码，有则输出else ctx.status = 404 ctx.body = '这是一个404页面' } else { console.log('匹配完成'); }})app .use(router.routes()) .use(router.allowedMethods()) .listen(3000, console.log(\"http://localhost:3000\")) 这里的状态码是以有无路由和响应数据来判断的如果没有就是404。因为页面上没有任何数据，如果有就是200，二者缺一不可 koa中间件执行流程 先从外到内 再从内到外 1234567891011121314151617181920212223242526272829const koa = require('koa')const app = new koa()const Router = require('koa-router')const router = new Router()app.use(async (ctx, next) =&gt; { //1.匹配执行中间件 console.log(1); //2.输出 1 await next() //3.去匹配路由 console.log(5); //11.输出5})app.use(async (ctx, next) =&gt; { //4.匹配执行中间件 console.log(2); //5.输出 2 await next() //6.去匹配路由 console.log(4); //10.输出4})router.get('/', async (ctx, next) =&gt; { //7.匹配到路由 ctx.body = \"Home\" //8.有响应数据，则状态码为200 console.log(3);//9.输出3})app .use(router.routes()) .use(router.allowedMethods()) .listen(3000, console.log(\"http://localhost:3000\")) 最终的输出就是1-5，以next为内外分界的话，就像是洋葱，先从外到里，然后从里到外","link":"/2019/08/10/Koa的中间件/"},{"title":"React-redux的Provider和connect","text":"Provider和connect可以帮助我们更方便的获取数据。 React-redux的Provider和connect提供器Provider的使用 使用Provider可以让在标签内的所有组件和元素都可以访问store 很简单，我们在项目的index.js中使用Provider 123456789101112import React from 'react';import ReactDOM from 'react-dom';import TodoList from './components/TodoList.jsx'import { Provider } from 'react-redux'import store from './store/index'const App = ( &lt;Provider store={store}&gt; // Provider包裹的元素都可以使用store &lt;TodoList&gt;&lt;/TodoList&gt; &lt;/Provider&gt;)ReactDOM.render(App, document.getElementById('root')); 连接器connect的使用 使用connect映射store中的对应数据,这时候不需要在使用state来获取store的数据，它会变成props属性，我们直接根据映射关系就可以拿到值 1234567891011121314151617181920212223242526272829//TodoList.jsximport React, { Component } from \"react\";import { Button, Input } from \"antd\";import { connect } from \"react-redux\";class TodoList extends Component { render() { return ( &lt;div&gt; &lt;Input style={{ width: 400 }} placeholder={this.props.inputValue} /&gt; &lt;Button type=\"primary\"&gt;按钮&lt;/Button&gt; &lt;ul&gt; &lt;li&gt;今天天气真不错！&lt;/li&gt; &lt;li&gt;万里无云&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ); }}const StateToProps = state =&gt; { return { inputValue: state.inputValue //这里其实就是一个映射关系 };};export default connect( StateToProps, null)(TodoList);","link":"/2019/08/04/React-redux的Provider和connect/"},{"title":"React中绑定this并传参的几种方式","text":"在React中，由于函数的this指向问题，我们需要绑定函数内部中的this指向，这样才能成功的调用并传递参数 React中绑定this并传参的几种方式 在React中的传参方式中，总结了一些解决函数内部的this指向问题和传参的问题。 第一种方式 在事件函数处理中，直接使用bind绑定this并传参 123456789101112131415161718192021222324252627// bindThis.jsximport React from \"react\";export default class BindThist extends React.Component { constructor(props) { super(props); this.state = { mes: \"绑定this并传参\" }; } render() { return ( &lt;div&gt; &lt;h1&gt;绑定This传参的方式&lt;/h1&gt; &lt;button onClick={this.changeMes.bind(this, \"🐖\", \"🐕\")}&gt; 绑定This传参 &lt;/button&gt; &lt;h4&gt;{this.state.mes}&lt;/h4&gt; &lt;/div&gt; ); } changeMes(pig, dog) { //这个时候因为this指向问题，所以会报错undefined，所以需要修改this的指向 this.setState({ mes: \"修改了\" + pig + dog }); }} bind的作用：为前面的函数，修改函数中的this指向，让函数内部的this，指向bind参数列表中的第一个参数 bind和call/apply之间的区别:call/apply修改完this的指向后会立即调用前面的函数，bind方法的返回值是改变了this指向的原函数的拷贝，但是不会对原函数的this进行改变 注意：bind中的第一个参数，是用来修改this指向的，第一个参数后面所有的参数，都会当作将来调用前面函数时的参数 第二种方式 在constructor中改变函数this 1234567891011121314151617181920212223242526272829import React from \"react\";export default class BindThist extends React.Component { constructor(props) { super(props); /*因为函数执行必然会执行constructor函数，所以我们在这对函数的this进行修改 注意：bind方法并不会修改原函数，而是返回一个修改后的原函数拷贝，就是返回一个修改了this的函数，所以我们需要接收一下 注意：这个时候我们使用原函数进行接收，这样就覆盖了没有修改this的函数 */ this.changeMes = this.changeMes.bind(this, \"🐖\", \"🐕\"); this.state = { mes: \"绑定this并传参\" }; } render() { return ( &lt;div&gt; &lt;h1&gt;绑定This传参的方式&lt;/h1&gt; {/* 因为在上面我们已经修改过this的指向了，所以在这里并不需要进行修改 */} &lt;button onClick={this.changeMes}&gt;绑定This传参&lt;/button&gt; &lt;h4&gt;{this.state.mes}&lt;/h4&gt; &lt;/div&gt; ); } changeMes(pig, dog) { this.setState({ mes: \"修改了\" + pig + dog }); }} 第三种方式 在调用时使用箭头函数 123456789101112131415161718192021222324252627282930import React from \"react\";export default class BindThist extends React.Component { constructor(props) { super(props); this.state = { mes: \"绑定this并传参\" }; } render() { return ( &lt;div&gt; &lt;h1&gt;绑定This传参的方式&lt;/h1&gt; {/* 因为此时的this就是我们的实例，这个时候去调用函数，那么被调用函数中this就是指向这个调用者，就是实例对象 */} &lt;button onClick={() =&gt; { this.changeMes(\"🐖\", \"🐕\"); }} &gt; 绑定This传参 &lt;/button&gt; &lt;h4&gt;{this.state.mes}&lt;/h4&gt; &lt;/div&gt; ); } changeMes(pig, dog) { this.setState({ mes: \"修改了\" + pig + dog }); }} 但是需要注意的是； &lt;button onClick={() =&gt; {this.changeMes(&quot;🐖&quot;, &quot;🐕&quot;);}}&gt;绑定This传参&lt;/button&gt;中我们不能省略()=&gt;写成&lt;button onClick={this.changeMes(&quot;🐖&quot;, &quot;🐕&quot;);}&gt;绑定This传参&lt;/button&gt;，这样的话React在解析的时候发现这个是一个函数调用，那么就会立即进行调用，如果使用的是箭头函数，它会解析成你点击的时候再来触发这个函数，这样才是我们想要的结果","link":"/2019/07/16/React中绑定this并传参的几种方式/"},{"title":"React-redux的使用","text":"React-Redux这是一个React生态中常用组件，它可以简化Redux流程 React-redux的使用 安装：yarn add react-redux 初始化store，src/store/index.js 12345import {createStore} from 'redux'import reducer from './reducer'const store = createStore(reducer)export default store src/store/reducer.js 1234567const defalueState = {inputValue: 'Mr zhong',list: []}export default (state = defalueState, action) =&gt; { return state} 初始化完毕后在需要使用的组件中引用store 123456789101112131415161718192021222324//TodoList.jsximport React, { Component } from \"react\";import { Button, Input } from \"antd\";import store from \"../store/index\";class TodoList extends Component { constructor(props) { super(props); this.state = store.getState(); } render() { return ( &lt;div&gt; &lt;Input style={{ width: 400 }} placeholder={this.state.inputValue} /&gt; &lt;Button type=\"primary\"&gt;按钮&lt;/Button&gt; &lt;ul&gt; &lt;li&gt;今天天气真不错！&lt;/li&gt; &lt;li&gt;万里无云&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ); }}export default TodoList; 初始化完毕！","link":"/2019/08/04/React-redux的使用/"},{"title":"React中Context的使用","text":"React中的context和vue中的vuex有些相似,可以实现数据的共享,让获取数据不再受组件嵌套的限制. Context的使用 在某些时候，当组件形成嵌套时，我们在父组件中像传值给孙子组件，那么我们可以使用先给子组件传值，在给孙组件传值，达到效果 1234567891011121314151617181920212223242526272829303132import React from \"react\";export default class Father extends React.Component { constructor(props) { super(props); this.state = { color: \"red\" }; } render() { return ( &lt;div&gt; &lt;h1&gt;父组件&lt;/h1&gt; &lt;SonOne color={this.state.color} /&gt; &lt;/div&gt; ); }}class SonOne extends React.Component { render() { return ( &lt;div&gt; &lt;h3&gt;子组件&lt;/h3&gt; &lt;GrandSon color={this.props.color} /&gt; &lt;/div&gt; ); }}class GrandSon extends React.Component { render() { return &lt;h5 style={{ color: this.props.color }}&gt;孙组件&lt;/h5&gt;; }} 但是，这样的话子组件本来是不需要做这个工作的，但是却让他担任了桥梁的角色，这个是不合理的 所以，我们可以使用Context来解决这个问题，实现属性值的共享 使用context实现数据的共享 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React from \"react\";import ReactTypes from \"prop-types\";export default class Father extends React.Component { constructor(props) { super(props); this.state = { color: \"red\" }; } //在父组件中，定义一个function，这个function有个固定的名称，叫做getChildContext，内部必须返回一个对象，这个对象就是需要共享给所有子孙组件的数据 getChildContext() { return { color: this.state.color }; } //这里对父组件要传递的数据做类型规定，需要定义一个静态的(static) childContextTypes 这个是固定的方法 static childContextTypes = { color: ReactTypes.string }; render() { return ( &lt;div&gt; &lt;h1&gt;父组件&lt;/h1&gt; &lt;SonOne /&gt; &lt;/div&gt; ); }}class SonOne extends React.Component { render() { return ( &lt;div&gt; &lt;h3&gt;子组件&lt;/h3&gt; &lt;GrandSon /&gt; &lt;/div&gt; ); }}class GrandSon extends React.Component { //上来之后先做属性校验，校验一下父组件传递的参数类型 static contextTypes = { color: ReactTypes.string //这里如果子组件想使用 通过context共享的数据，使用之前必须做类型校验 }; render() { return &lt;h5 style={{ color: this.context.color }}&gt;孙组件&lt;/h5&gt;; }} 快速识记这几个方法 记住这串单词getChildContextTypes 前三(getChildContext())、后三(static childContextTypes={})、后俩(static contextTypes={}) 一个方法，两个静态类型","link":"/2019/08/04/React中Context的使用/"},{"title":"React定义数据默认值和数据类型校验","text":"定义数据类型和校验主要是为了数据的安全性和准确性，可以让我们在使用数据的时候更为方便。 计数器 在下列的计数器组件中，我们给他传递了一个值 1234567//main.jsimport React from 'react'import ReactDOM from 'react-dom'import Count from './comments/count.jsx'ReactDOM.render(&lt;Count defalutNumber={1} /&gt;, document.getElementById('app')) 1234567891011121314151617//count.jsximport React from \"react\";export default class Count extends React.Component { constructor(props) { super(props);s } render() { return ( &lt;div&gt; &lt;h1&gt;计数器&lt;/h1&gt; &lt;input type=\"button\" value=\"+1\" /&gt; &lt;hr /&gt; &lt;h4&gt;当前的数值是:{this.props.defalutNumber}&lt;/h4&gt; &lt;/div&gt; ); }} 使用static defaultProps定义默认值 但是这样当用户没有传值时，没有默认值，在封装一个组件的时候，肯定有数据是必须的，哪怕用户没有传递参数，这时候组件内部尽量给自己提供一个默认值 使用static defaultProps来进行默认值的操作 123456789101112131415161718export default class Count extends React.Component { constructor(props) { super(props); } static defaultProps = { defaultNumber: 0 }; render() { return ( &lt;div&gt; &lt;h1&gt;计数器&lt;/h1&gt; &lt;input type=\"button\" value=\"+1\" /&gt; &lt;hr /&gt; &lt;h4&gt;当前的数值是:{this.props.defaultNumber}&lt;/h4&gt; &lt;/div&gt; ); }} 这样的话就设置好了，当你没有传入数据时，那么就会使用默认值 使用propType数据的类型校验 当用户在传入一些不合法数据时，组件对其验证后不进行处理，提示用户类型错误 注意：在react中 15.x版本后，propTypes被单独的抽离出来了，需要安装才能使用 安装: cnpm i prop-type -D即可 然后在组件中引入就可以使用了 1234567891011121314151617181920212223import React from \"react\";import ReactTypes from \"prop-types\";export default class Count extends React.Component { constructor(props) { super(props); } static defaultProps = { defaultNumber: 0 }; static propTypes = { defaultNumber: ReactTypes.number }; render() { return ( &lt;div&gt; &lt;h1&gt;计数器&lt;/h1&gt; &lt;input type=\"button\" value=\"+1\" /&gt; &lt;hr /&gt; &lt;h4&gt;当前的数值是:{this.props.defaultNumber}&lt;/h4&gt; &lt;/div&gt; ); }} 123456ReactDOM.render(&lt;div&gt; &lt;Count defaultNumber={1} /&gt; &lt;Count defaultNumber=\"哈啊哈\" /&gt;&lt;/div&gt;, document.getElementById('app')) 当我们进行了类型校验为number时，你传递字符串虽然会给你显示出来，但是会进行报错Failed prop type: Invalid propdefaultNumber of typestringsupplied toCount, expectednumber.in Count 修改后就没有问题了","link":"/2019/08/04/React定义数据默认值和数据类型校验/"},{"title":"React创建最基本的组件","text":"我们使用React创建一个最基本的组件，来看一下React的运行流程。 React创建最基本的组件 在React中，构造函数，就是一个最基本的组件 如果像把组件放到页面中，可以把构造函数的名称，当作组件的名称，以HTML标签的形式引入页面中即可 注意：在React解析标签的时候，是以标签首字母来区分的，首字母是小写按照HTML标签进行解析，首字母是大写，按照组件形式去渲染 所以组件的首字母必须是大写的 123456789// 入口文件import React from 'react'import ReactDOM from 'react-dom'function Hello() { return 'Hello React' //此时一定需要返回值，如果不需要返回内容，则直接返回 null}ReactDOM.render(&lt;Hello&gt;&lt;/Hello&gt;, document.getElementById('app')) 组件使用外部数据 我们在全局中定义的数据，组件中可以直接拿到并修改 123456function Hello() {username = 'ls'return &lt;div&gt;我是Hello---{username}&lt;/div&gt;}let username = 'zs'ReactDOM.render(&lt;Hello&gt;&lt;/Hello&gt;, document.getElementById('app')) 我们在传递一个对象时，组件中必须定义形参用来接收这个对象，并且这个对象不能被修改 12345678910function Hello() {return &lt;div&gt;我是Hello---{username}&lt;/div&gt; //报错 username 未定义}let person = { username: 'kobe', age: 12}ReactDOM.render(&lt;Hello&gt;&lt;/Hello&gt;, document.getElementById('app')) 123456789101112131415function Hello(props) {console.log(props); // {username: \"kobe\", age: 12} 此时已经接收到了person的全部属性props.name = 'zs' //如果我们修改属性名的话就会抛出异常 Cannot add property name, object is not extensiblereturn &lt;div&gt;我是Hello---{props.username}&lt;/div&gt;}let person = { username: 'kobe', age: 12}ReactDOM.render( &lt;Hello {...person}&gt;&lt;/Hello&gt;, //我们可以使用ES6的扩散符，这样我们就不需要挨个传递person对象中的每一个属性 document.getElementById('app')) 抽离组件 将组件放到Hello.js中 12345import React from 'react' //这里的React是规定死的必须这么写export default function Hello(props) { //暴露出这个组件 return &lt;div&gt;我是Hello---{props.username}&lt;/div&gt;} 在main.js中引入组件 1234567891011import Hello from './Hello' //这里可以不加后缀let person = { username: 'kobe', age: 12}ReactDOM.render( &lt;Hello {...person}&gt;&lt;/Hello&gt;, //我们可以使用ES6的扩散符，这样我们就不需要挨个传递person对象中的每一个属性 document.getElementById('app')) 使用jsx文件 我们在 .js中书写组件没有智能提示，开发效率不高，我们可以将js后缀改为jsx 那么改完之后我们需要在webpack.config.js中配置一下jsx文件处理的loader 方法一： 12345{ test: /\\.(js|jsx)$/, use: 'babel-loader', exclude: /node_modules/ } 方法二： 12345{ test: /\\.jsx?$/, //正则中的?表示可以要也可以不要 use: 'babel-loader', exclude: /node_modules/ } 注意：我们在使用jsx文件创建组件时，引入组件时后缀名不能省略","link":"/2019/08/04/React创建最基本的组件/"},{"title":"React的react-transition-group动画库","text":"react-transition-group动画库可以帮助我们很好的完成组件的动画，功能非常强大。 React的react-transition-group动画库 安装：cnpm install react-transition-group --save因为这是生产环境也需要用到的，也可以使用-S代替--save，使用yarn安装：yarn add react-transition-group 这个动画库是由 CSSTransition,Transition,TransitionGroup三个组成的 使用 组件中引入CSSTransition模块：import { CSSTransition } from 'react-transition-group' 将CSSTransition标签包裹在需要实现动画效果的元素外，然后进行相关属性的配置：12345678910111213141516171819202122232425262728293031323334353637 //jsxconstructor(props){ super(props); this.state = { isShow: true } } render() { return ( &lt;Fragment&gt; &lt;CSSTransition in={this.state.isShow} // 如果this.state.isShow从false变为true，则动画入场，反之out出场 timeout={1000} //动画执行1秒 classNames='css-style' //自定义的class名 unMountOnExit //可选，当动画出场后在页面上移除包裹的dom节点，删除DOM元素且不占位置 onEntered={(el) =&gt; { el.style.color='blue' //可选，动画入场之后的回调，el指被包裹的dom，让div内的字体颜色等于蓝色 }} onExited={() =&gt; { xxxxx //同理，动画出场之后的回调，也可以在这里来个setState啥的操作 }} &gt; &lt;div&gt;hello&lt;/div&gt; &lt;/CSSTransition&gt; &lt;button onClick={this.handleToggole}&gt;toggle&lt;/button&gt; &lt;/Fragment&gt; ) } handleToggole: ()=&gt; { this.setState({ isShow: !this.state.isShow }) } } 一旦动画入场，插件将会自动的在包裹住的标签上添加很多css样式，默认class名是fade，所以我们需要给CSSTransition标签加上classNames=’css-style’，然后去css文件进行配置： 1234567891011121314151617181920212223242526//enter是入场前的刹那（点击按钮），appear指页面第一次加载前的一刹那（自动）.css-style-enter, .css-style-appear { opacity: 0;}//enter-active指入场后到入场结束的过程，appear-active则是页面第一次加载自动执行.css-style-enter-active, .css-style-appear-active { opacity: 1; transition: opacity 1s ease-in;}//入场动画执行完毕后，保持状态.css-style-enter-done { opacity: 1;}//同理，出场前的一刹那，以下就不详细解释了，一样的道理.css-style-exit { opacity: 1;}.css-style-exit-active { opacity: 0; transition: opacity 1s ease-in;}.css-style-exit-done { opacity: 0;} 如果页面上一组dom都需要添加动画效果时我们需要在最外面再加一个TransitionGroup 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 import React, { Component, Fragment } from 'react';import { CSSTransition, TransitionGroup } from 'react-transition-group';import './style.css';class App extends Component { constructor(props){ super(props); this.state = { list: [] } this.handleAddItem = this.handleAddItem.bind(this); } render() { return ( &lt;Fragment&gt; &lt;TransitionGroup&gt; { this.state.list.map((item, index) =&gt; { return ( &lt;CSSTransition timeout={1000} classNames='fade' unmountOnExit onEntered={(el) =&gt; {el.style.color='blue'}} appear={true} key={index} &gt; &lt;div&gt;{item}&lt;/div&gt; &lt;/CSSTransition&gt; ) }) } &lt;/TransitionGroup&gt; &lt;button onClick={this.handleAddItem}&gt;toggle&lt;/button&gt; &lt;/Fragment&gt; ) } handleAddItem() { this.setState((prevState) =&gt; { return { list: [...prevState.list, 'item'] } }) } } export default App;","link":"/2019/08/04/React的react-transition-group动画库/"},{"title":"React使用class创建的类作为组件","text":"React的组件分为有状态组件和无状态组件，我们现在来学习一下无状态组件。 使用calss创建的类作为组件 使用class创建的类，通过extends关键字，继承了React.Component之后，这个类，就是一个组件的模板了 我们在定义class实现组件的内部，必须定义一个render函数 在render函数中必须要返回一个东西，如果你不想返回什么，那么就return null 123456789101112131415import React from 'react'import ReactDOM from 'react-dom'class Hello extends React.Component { //报错信息:No `render` method found on the returned component instance: you may have forgotten to define `render` render() { // Nothing was returned from render.This usually means a return statement is missing.Or, to render nothing, return null. return &lt;div&gt;React&lt;/div&gt; }}ReactDOM.render(&lt;div&gt; &lt;Hello&gt;&lt;/Hello&gt;&lt;/div&gt;, document.getElementById('app')) 组件内的一些注意事项： 12345678910111213141516171819import React from 'react'import ReactDOM from 'react-dom'class Hello extends React.Component { constructor(props) { // super() //继承的类必须使用super，否则会报错 console.log(this.props) //直接使用props拿数据输出 undefined console.log(props); //{name:'zs,age:'12'} //使用props拿数据是必须在constructor传递参数，并且不能使用this拿 } render() { console.log(this.props) //这里可以通过this直接访问到传递的数据不需要接收 // this.props.name = 'ls' //修改数据后报错，这个数据只是只读的不能修改 return &lt;div&gt; React&lt;/div &gt; }}ReactDOM.render(&lt;div&gt; &lt;Hello name='zs' age='12'&gt;&lt;/Hello&gt;&lt;/div&gt;, document.getElementById('app'))","link":"/2019/08/04/React使用class创建的类作为组件/"},{"title":"React的动画","text":"我们在React中也可以使用CSS来帮助我们完成一些普通的动画效果。 React的动画使用css来完成动画效果 在需要使用动画的元素中加入两个类，让他点击切换，然后每个类设置一下css动画 12345678910111213141516171819202122232425import React, { Component } from 'react';class CssStudy extends Component { constructor(props) { super(props) this.state = { isShow: true } } render() { return ( &lt;div&gt; &lt;div className={this.state.isShow ? 'show' : 'hide'}&gt;今天的天气真不错&lt;/div&gt; &lt;button onClick={this.toggle}&gt;你好&lt;/button&gt; &lt;/div&gt; ); } toggle = () =&gt; { this.setState({ isShow: !this.state.isShow }) }}export default CssStudy; css样式 12345678910.show { color: yellow; opacity: 1; transition: all 1s ease-in;}.hide { color: aqua; opacity: 1; transition: all 1s ease-in;} 使用关键帧制作动画 在css3中，动画还加入了关键帧，可以让我们更好的制作动画的效果 12345678910111213141516171819202122232425262728293031.show { color: yellow; opacity: 1; transition: all 1s ease-in;}.hide { opacity: 1; transition: all 1s ease-in; /* animation（两个必要参数，其他都是可选参数） 参数一：表示需要引入的关键帧动画名称 参数二：动画时间 参数三：动画的效果 参数四：动画完成后结束位置在100%还是0%，如果不加则默认是0% */ animation: hide-style 2s ease-in forwards;}@keyframes hide-style { 0% { color: green; font-size: 12px; } 50% { color: red; font-size: 20px; } 100% { color: yellow; font-size: 24px; }}","link":"/2019/08/04/React的动画/"},{"title":"React组件的状态","text":"React组件的状态分成两种，我们现在来分析一下它们的区别和使用场景，可以帮助我们更好的使用。 组件的状态使用function和class创建组件的区别 使用以上两种创建组件的方式，有本质的区别 使用function构造函数创建的组件，内部没有state私有数据，只有一个props来接收外界传递的数据 使用calss关键字创建的组件，内部除了有this.props这个只读的属性外，还有一个专门用于存放私有数据的this.state属性，这个state是可读可写的 基于以上的区别：我们可以为这两种创建组件的方式下定义了:使用了function创建的组件，叫做无状态组件，使用class创建的组件，叫做有状态组件有状态组件和无状态组件最本质的区别 有无状态就是有无state属性，同时。calss创建的组件，有自己的生命周期函数，但是function创建的组件，没有自己的生命周期函数适用场景 如果一个组件需要存放自己的私有数据，或者在组件中的不同阶段执行不同的功能。此时，适合使用class创建的有状态组件 如果一个组件，只需要根据外界传递过来的props，渲染固定的页面结构，此时，适合使用function创建出来的无状态组件，由于无状态组件没有生命周期，所以运行速度相对快一些","link":"/2019/08/04/React组件的状态/"},{"title":"React组件的生命周期","text":"Vue、React、angular都是基于组件化开发的，要想熟练使用，我们必须了解它们的生命周期，现在我们来学习一下React的组件生命周期。 组件的生命周期组件的概念 在组件创建、到加载到页面上运行、以及组件被销毁的过程中，总是伴随着各种各样的事件，这些在组件特定时期，触发的事件，统称为组件的生命周期组件生命周期 创建阶段:组件创建阶段的生命周期函数，有一个显著的特征：创建阶段的生命周期函数，在组件的一辈子中，只执行一次 componentWillMount:组件将要被挂载，此时还没有开始渲染虚拟DOM render:第一次开始渲染真正的虚拟DOM，当render执行完，内存中就有完整的虚拟DOM了 componentDidMount:组件完成了挂载，此时，组件已经显示到页面上了，当这个方法执行完，组件都进入运行阶段 组件运行阶段: 组件的运行阶段的生命周期函数，也有一个显著的特点，根据组件中的state和props的改变，有选择性的触发0次或者N次 componentWillReceiveProps：组件将要接收到新属性，此时只要这个方法被触发，就证明父组件为当前子组件传递了新的属性值 ShouldComponentWillUpdate：组件是否需要被更新，此时组件尚未被更新，但是state和props是最新的 componentWillUpdate：组件将要被更新，此时尚未开始更新，内存中的虚拟DOM树还是旧的 render：此时，根据新的state和props重新渲染在内存中渲染一颗新的虚拟DOM树，当render调用完毕后，内存中的旧DOM树已经被新DOM树替换了，但是页面还是旧的 componentDidUpdate：此时，页面被重新渲染，state和虚拟DOM的页面已经保持完全一致了 组件的销毁阶段:组件的销毁阶段的生命周期函数，也有一个显著的特点，一辈子只执行一次vue和react的生命周期图vuereact","link":"/2019/08/04/React组件的生命周期/"},{"title":"React脚手架创建项目","text":"使用React脚手架可以快速生成项目结构和基本组件。 React脚手架创建项目 在之前我们创建项目都是用npm init -y来初始化项目的，但是这样项目结构不清晰，所以在Vue中，也使用了脚手架，而React、Angular也有脚手架 安装:cnpm install -g create-react-app脚手架 创建项目：create-react-app react-demo 运行项目: cd react-demo,然后yarn start 打包项目:npm run build，打包之后build文件夹就有你需要发布的包了，启动node http-server服务即可运行打包后的项目","link":"/2019/08/04/React脚手架创建项目/"},{"title":"Redux-thunk中间件的配置","text":"Redux-thunk是Redux的一个插件，可以帮助我们更好的使用Redux。 Redux-thunk中间件的配置 在redux中需要使用redux-thunk的话，需要在store/index.js中配置一下 配置如下： 1234567891011121314151617// 1. 引入applyMiddleware、composeimport { createStore, applyMiddleware, compose } from 'redux'//引入reducerimport reducer from './reducer'// 2.引入redux-thunkimport thunk from 'redux-thunk'//3.由于createStore中只能接收两个参数，如果将applyMiddleware(thunk)直接放到参数中，那么我们配置的redux调试工具就无法执行//所以这个时候我们需要增强函数，redux已经帮助我们提供这个功能了const store = createStore( reducer, applyMiddleware(thunk), window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__())//暴露export default store 以上这种方式会导致我们配置的redux失效，因为它只能接收两个参数 使用增强函数配置redux-thunk 1234567891011121314151617181920212223// 1. 引入applyMiddleware、composeimport { createStore, applyMiddleware, compose } from 'redux'//引入reducerimport reducer from './reducer'// 2.引入redux-thunkimport thunk from 'redux-thunk'//判断是否有redux调试的配置项const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : composeconst enhancer = composeEnhancers(applyMiddleware(thunk))//3.由于createStore中只能接收两个参数，如果将applyMiddleware(thunk)直接放到参数中，那么我们配置的redux调试工具就无法执行//所以这个时候我们需要增强函数，redux已经帮助我们提供这个功能了const store = createStore( reducer, enhancer)//暴露export default store 这样就配置完成了","link":"/2019/08/04/Redux-thunk中间件的配置/"},{"title":"Redex的准备","text":"Redux 是 JavaScript 状态容器， 提供可预测化的状态管理。那什么是可以预测化，我的理解就是根据一个固定的输入，必然会得到一个固定的结果。redux是专门为react开发的，但并不是只能用于react,可以用于任何界面库 使用Ant Design 创建列表 创建一个列表 1234567891011121314151617181920212223242526//TodoList.jsximport React, { Component } from \"react\";import { Button, List, Input } from \"antd\";import \"antd/dist/antd.css\";const data = [\"今天的心情特别不好\", \"因为代码老是出问题\", \"感到很头疼\"];class TodoList extends Component { render() { return ( &lt;div&gt; &lt;div&gt; &lt;Input placeholder=\"please wirting\" style={{ width: 200 }} /&gt; &lt;Button&gt;增加&lt;/Button&gt; &lt;div&gt; &lt;List bordered={true} //是否使用边框 dataSource={data} //列表数据源 renderItem={item =&gt; &lt;List.Item&gt;{item}&lt;/List.Item&gt;} //自定义渲染列表项 /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); }}export default TodoList; 安装Redux 安装:yarn add redux 初始化 在src下创建一个store文件夹，文件夹下创建index.js、reducer.js两个文件 在index.js中，我们需要创建redux仓库 123456789import { createStore } from 'redux'//引入reducerimport reducer from './reducer'//创建仓库const store = createStore(reducer)//暴露export default store 在reducer.js中，我们需要创建管理程序,里面用来存放业务逻辑 1234567const defaultValue = {inputValue: 'Writing Something',list: [\"今天的心情真好\", \"代码问题解决了\", \"以后要多重启\"]}export default (state = defaultValue, action) =&gt; { return state} 获取store中的数据 在TodoLost.jsx中获取store中的数据 1234567891011121314151617181920212223242526272829303132333435363738import React, { Component } from \"react\";import { Input, List, Button } from \"antd\";//引入storeimport store from \"../store/index\";class TodoList extends Component { constructor(props) { super(props); //使用getstore()方法可以获取store的数据，就是存到store的数据 console.log(store.getState()); this.state = store.getState(); } render() { return ( &lt;div style={{ width: 500, margin: 20 }}&gt; &lt;div&gt; &lt;Input type=\"primary\" style={{ width: 200 }} placeholder={this.state.inputValue} /&gt; &lt;Button&gt;增加&lt;/Button&gt; &lt;/div&gt; &lt;div style={{ width: 200, marginTop: 20 }}&gt; &lt;List //使用store的数据进行渲染 dataSource={this.state.list} bordered renderItem={item =&gt; &lt;List.Item&gt;{item}&lt;/List.Item&gt;} /&gt; &lt;/div&gt; &lt;/div&gt; ); }}export default TodoList; 在chrome中使用redux调试工具 在chrome应用商店下载redux dev 然后在配置中勾选允许访问文件地址，然后重启chrome就可以在控制台看到redux了 配置redux，在store/index.js中创建store的时候加入一个参数 1234const store = createStore(reducer, /* preloadedState, */+ window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()); 这样就可以在调试工具中看到了","link":"/2019/08/04/Redex的准备/"},{"title":"TypeScript中的函数","text":"函数在 Javascript 中是一等一的公民 Typescript 中的函数TypeScript 中定义函数ES5 中定义函数的方式 1234&lt;!--函数声明--&gt;function getinfo() {return 'hello-world'} 1234&lt;!--匿名函数--&gt;var getinfo = function () {return 'hello-world'} ts 中的定义函数的方式 使用函数声明的方式，只定义函数的返回值类型 1234function getinfo():string { return 'This is getinfo'}getinfo() 注意：这样定义函数时，返回值的数据类型必须是 string,否则会报错 函数表达式的方式定义函数(匿名函数) 1234var getinfo=function():string { return 'This is getinfo'}getinfo() ts 中传递参数 使用函数声明定义函数，需要定义参数的类型和函数的返回值类型，且形参和实参类型与数据一一对应 12345function getinfo(name:string,age:number):string {return `${name}----${age}`}let value = getinfo('张三',12)console.log(value); 使用函数表达式(匿名函数)定义函数，传递参数，规则与使用函声明定义函数一样 12345let getinfo= function (name:string,age:number):string {return `${name}----${age}`}let value = getinfo('张三',40)console.log(value); 定义没有返回值的方法 1234function getinfo(name:string,age:number):void { console.log(`${name}----${age}`);}getinfo('张三',30) 定义可选参数 在 ES5 中，我们如果定义普通的形参时，形参个数和实参个数可以不一致，但是在 ts 中，不允许这样做 1234function getinfo(name:string,age:number):void {console.log(`${name}----年龄保密);} //这里提示报错了，没有将模板字符串写完getinfo('张三') 所以我们可以看到，如果写了形参，没有传递实参，就会编译错误,但是有时候我们并不传递，但是可以先定义预留位置 1234function getinfo(name:string,age?:number):void { age? console.log(`${name}----${age}`): console.log(`${name}---年龄保密`)}getinfo('张三',12) 在形参名后面加上 ? 表示对实参进行判断，如果有就使用，没有就不使用 定义默认参数 定义默认参数我们也可以不传递定义了默认值的参数 1234function getinfo(name:string,age:number=12):void {age? console.log(`${name}----${age}`): console.log(`${name}---年龄保密`)}getinfo('张三') //输出 张三 12 1234function getinfo(name:string,age:number=12):void {age? console.log(`${name}----${age}`): console.log(`${name}---年龄保密`)}getinfo('张三',45) //输出 张三 45 总结： 如果我们在形参中定义了默认的值的时候，你调用函数时可以不传递这个设有默认值的参数，他会使用默认值输出 如果我们在形参中定义了默认的值的时候，你调用函数时传递这个设有默认值的参数，他会使用你传递的值作为输出 剩余参数 当我们想要计算多个参数的值时，如下定义每一个参数会显得非常麻烦，所以我们需要换一种方式来解决这个累赘的定义 12345function sum(a:number,b:number,c:number,d:number):number{return a+b+c+d}var sun = sum(6,10,12,14)console.log(sun); 使用 ES6 中的三点运算符 123456789function sum(a:number,b:number,...result:number[]):number{var sum =a+bfor (var i = 0; i &lt; result.length; i++) { sum+=result[i]}return sum}var add = sum(1,2,3,4)console.log(add); 这样就不会有太多的重复代码 ts 函数重载 拓展： java 中方法的重载：重载指的是两个或者两个以上同名函数，但是它们的参数不一样，这时候会出现重载的情况 typescript 中的重载：通过为同一个函数提供多个函数类型定义来实现多种功能的目的 ts 中为了兼容 ES5 以及 ES6，重载的写法与 Java 有所区别 123456789&lt;!--在ES5中，如果出现了同名的方法，下面的会替换掉上面的--&gt;function a() {console.log('a')}function a() { console.log('b')}a() //输出 b 示例 1： 123456789function getinfo(age:number):numberfunction getinfo(name:string):stringfunction getinfo(str:any):any{ if(typeof str ==='string'){ return `我是:${str}` } return `我今年 ${str}岁`}console.log(getinfo('张三')) //我是张三 123456789function getinfo(age:number):numberfunction getinfo(name:string):stringfunction getinfo(str:any):any{ if(typeof str ==='string'){ return `我是:${str}` } return `我今年 ${str}岁`}console.log(getinfo(18)) //我今年18岁 示例 1 中，前面两个函数才是作为运行的方法，最后这个函数是判断调用哪个函数，判断的依据就是你传入的参数的数据类型和哪个方法中的形参的数据类型一致，那么他就调用哪个，如果传入的实参数据类型没有定义则报错 示例 2: 123456789101112function getinfo(name: string): string;function getinfo(name: string, age: number): string;function getinfo(name: string, age?: number): any { if (age) { return `我叫${name}，我今年：${age}岁`; } else { return `我叫:${name}`; }}console.log(getinfo(\"张三\")) //张三// getinfo(12) //报错，因为name是string ，只能在第二个参数传入number型数据console.log(getinfo(\"张三\", 12)); //我叫张三，我今年12岁 示例 2 中，我们定义了一个可选参数，当我们只有一个参数时他就调用第一个方法，如果有两个参数时，调用第二个方法 箭头函数 在 ES6 中，箭头函数的 this 指向的是上下文,但是在 ts 编译中采用的是严格模式，严格模式中禁止函数中的 this 指向 windowsetTimeout(() =&gt; { console.log(&quot;run&quot;); }, 3000) 以上就是我在学习中总结的一些关于函数的相关知识。","link":"/2019/07/08/TypeScript中的函数/"},{"title":"Redux-thunk的使用","text":"配置好Redux-thun接下来我就看看如何使用Redux-thun。 Redux-thunk的使用 Redux-thunk就是redux的中间件插件 安装:cnpm i -S redux-thunk 使用Redux-thunk处理异步任务 我们在请求数据的时候，在componentWillMount()生命周期函数中来请求数据，如果请求的数据过多，那么这个生命周期函数显得非常臃肿，所以我们需要把这个异步请求放到单独的一个文件中，其实异步请求我们需要它返回的就是一个action，然后，在componentWillMount生命周期函数中调用就可以得到数据放到store中 因为我们把所有的action逻辑都放在了actionCreatros.js，所以我们在这里编辑异步请求 12345678910111213141516171819202122232425262728293031import { ADD_ITEM, CHANGE_INPUT, DELETE_ITEM, GET_LIST } from './actionTypes'import axios from \"axios\";export const changeInput = (value) =&gt; ({ type: CHANGE_INPUT, value})export const addItem = () =&gt; ({ type: ADD_ITEM,})export const deleteItem = (index) =&gt; ({ type: DELETE_ITEM, index})export const getListAction = (data) =&gt; ({ type: GET_LIST, data})export const getListData = () =&gt; { return (dispatch) =&gt; { axios .get( \"https://www.easy-mock.com/mock/5d3fb5919101bd556dbe67cc/getlists/lists\" ) .then(res =&gt; { const data = getListAction(res.data.data.list) //调用上面的函数，这样就返回了一个我们想要的对象格式 dispatch(data) //这里可以在参数中定义dispatch，就不用写store。dispatch }) .catch(error =&gt; console.log(error)); }} 这样我们的TodoList.jsx文件就变成这样 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import React, { Component } from \"react\";//引入storeimport store from \"../store/index\";//引入actionCreatros.jsimport { changeInput, deleteItem, addItem, getListData} from \"../store/actionCreatros\";//引入ui组件import TodoListUI from \"./TodoListUI.jsx\";class TodoList extends Component { constructor(props) { super(props); //使用getstore()方法可以获取store的数据，就是存到store的数据 this.state = store.getState(); console.log(store.getState()); this.changeValue = this.changeValue.bind(this); this.storeChange = this.storeChange.bind(this); //订阅state，调用storeChange这个方法 store.subscribe(this.storeChange); this.deleteItem = this.deleteItem.bind(this); this.addList = this.addList.bind(this); } render() { return ( &lt;TodoListUI changeValue={this.changeValue} addList={this.addList} deleteItem={this.deleteItem} inputValue={this.state.inputValue} list={this.state.list} /&gt; ); } //实现store数据从服务端得到，然后存放到store中 componentWillMount() { const action = getListData(); store.dispatch(action); } storeChange() { //重新设置state为最新的store this.setState(store.getState()); } changeValue(e) { const action = changeInput(e.target.value); store.dispatch(action); //使用dispatch方法将action传递过去store就可以接收到值了,store接收到得值会直接发送到reducer中 } //点击增加按钮，增加数据到列表中 addList() { const action = addItem(); store.dispatch(action); } //点击列表项进行删除 deleteItem(index) { const action = deleteItem(index); store.dispatch(action); }}export default TodoList;","link":"/2019/08/04/Redux-thunk的使用/"},{"title":"React生命周期函数","text":"生命周期函数在组件从创建到销毁，在内部做的一系列操作，通过生命周期函数，可以帮助我们更好的了解和使用组件。 componentWillMount函数 在组件即将挂载到页面上的时候执行，此时，组件尚未挂载到页面中 虚拟DOM也还没有开始创建 此时无法获取到任何页面上的元素，因为虚拟DOM和页面都还没有开始渲染，在这个阶段中，也不能去操作页面上DOM元素 但是可以获取到props和state的值，也可以调用函数 这个函数等同于Vue中的created生命周期函数render函数 当执行到这个生命周期函数时，即将开始渲染内存中的虚拟DOM了，但是页面上尚未真正显示DOM元素 在render函数中，在return之前，虚拟DOM还没有开始创建，页面上也是空的，拿不到任何的元素 当render函数中的return执行完毕后，虚拟DOM创建好了，但是还没有真正的挂载到页面中componentDidMount函数 当组件挂载到页面上之后，会进入这个生命周期函数，只要进入这个生命周期函数了，说明页面上已经有可见DOM元素了 在这个函数中，可以放心的操作页面上你需要操作的DOM元素了 如果我们需要操作DOM元素。最早只能在这个生命周期函数中进行 componentDidMounti相当于vue中的mounted函数组件生命周期函数执行顺序 组件生命周期的执行顺序： Mounting： constructor() componentWillMount() render() componentDidMount() Updating： componentWillReceiveProps(nextProps) shouldComponentUpdate(nextProps, nextState) componentWillUpdate(nextProps, nextState) render() componentDidUpdate(prevProps, prevState) Unmounting： componentWillUnmount()","link":"/2019/08/04/React生命周期函数/"},{"title":"Redux修改store的数据","text":"在redux中，我们不能直接修改store中的数据，如果需要修改，则需要使用action来进行改变数据。 修改store中的数据 在redux中，我们不能直接修改store中的数据，如果需要修改，则需要使用action来进行修改(重新复制，并不是去修改)，action是一个对象，其中type属性是必须的，然后使用store.dispatch(action)将数据传递给reducer.js中进行处理 如:我们输入在Input输入数据的时候，将最新的数据发送到store中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import React, { Component } from \"react\";import { Input, List, Button } from \"antd\";//引入storeimport store from \"../store/index\";class TodoList extends Component { constructor(props) { super(props); //使用getstore()方法可以获取store的数据，就是存到store的数据 this.state = store.getState(); this.changeValue = this.changeValue.bind(this); } render() { return ( &lt;div style={{ width: 500, margin: 20 }}&gt; &lt;div&gt; &lt;Input type=\"primary\" style={{ width: 200 }} placeholder={this.state.inputValue} onChange={this.changeValue} /&gt; &lt;Button&gt;增加&lt;/Button&gt; &lt;/div&gt; &lt;div style={{ width: 200, marginTop: 20 }}&gt; &lt;List //使用store的数据进行渲染 dataSource={this.state.list} bordered renderItem={item =&gt; &lt;List.Item&gt;{item}&lt;/List.Item&gt;} /&gt; &lt;/div&gt; &lt;/div&gt; ); } changeValue(e) { const action = { //修改store需要使用action，type属性是必须的 type: \"changeInput\", value: e.target.value }; //使用dispatch方法将action传递过去store就可以接收到值了,store接收到得值会直接发送到reducer中 store.dispatch(action); }}export default TodoList; action发送数据后，store会收到值，但是他默认发送给了reduces，我们在reduces就可以获取到最新的数据 1234567891011121314151617181920 const defaultValue = { inputValue: 'Writing Something', list: [\"今天的心情真好\", \"代码问题解决了\", \"以后要多重启\"]}export default (state = defaultValue, action) =&gt; { //此时已经可以接收到TodoList中发送得值，那么我们就需要处理一些发送过来的数据 //注意:reducer不能直接state中的值，只能通过action来生成新的值，然后返回，store自己会监听值发生改变而变化 // console.log(state, action); if (action.type === 'changeInput') { //深度克隆原数据 const newState = JSON.parse(JSON.stringify(state)) //修改inputValue newState.inputValue = action.value console.log(newState); //返回新的state return newState } return state} 这个时候，我们已经能够在redux调试工具中看到redux中的state发生变化了，但是我们还需要订阅store，不然input如果含有value属性时会出BUG，订阅的作用是input的值改变后，重新设置state的值与store的值同步，因为每次Input改变都会向store发送最新的数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import React, { Component } from \"react\";import { Input, List, Button } from \"antd\";//引入storeimport store from \"../store/index\";class TodoList extends Component { constructor(props) { super(props); //使用getstore()方法可以获取store的数据，就是存到store的数据 this.state = store.getState(); this.changeValue = this.changeValue.bind(this); this.storeChange = this.storeChange.bind(this); //订阅state，调用storeChange这个方法 store.subscribe(this.storeChange); } render() { return ( &lt;div style={{ width: 500, margin: 20 }}&gt; &lt;div&gt; &lt;Input type=\"primary\" style={{ width: 200 }} placeholder={this.state.inputValue} value={this.state.inputValue} onChange={this.changeValue} /&gt; &lt;Button&gt;增加&lt;/Button&gt; &lt;/div&gt; &lt;div style={{ width: 200, marginTop: 20 }}&gt; &lt;List //使用store的数据进行渲染 dataSource={this.state.list} bordered renderItem={item =&gt; &lt;List.Item&gt;{item}&lt;/List.Item&gt;} /&gt; &lt;/div&gt; &lt;/div&gt; ); } changeValue(e) { const action = { //修改store需要使用action type: \"changeInput\", value: e.target.value }; store.dispatch(action); //使用dispatch方法将action传递过去store就可以接收到值了,store接收到得值会直接发送到reducer中 } storeChange() { //重新设置state为最新的store this.setState(store.getState()); }}export default TodoList;","link":"/2019/08/04/Redux修改store的数据/"},{"title":"TypeScript中的泛型","text":"泛型：软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性，组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能 前言 在像C#和java这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据，这样用户就可以以自己的数据类型来使用组件。 TypeScript中的泛型 通俗理解:泛型就是解决类接口方法的复用性、以及对不特定数据类型的支持 同时返回 string类型和number类型(但是代码冗余严重) 123456789101112131415function getData(value: string): string { return value;}function getData1(value: number): number { return value;}function getData3(value: any): any { if (typeof value === \"string\") { return `我是${value}`; } else { return `今年${value}`; }}console.log(getData3(\"张三\")); //我是张三console.log(getData3(12)); //我今年12 使用any也可以同时返回string和number类型，但是相当于放弃了类型检查 12345function getData(value:any):any{ return value}console.log(getData(12)); //12console.log(getData('张三'));//张三 泛型 一般我们定义泛型的时候，在函数名后面使用&lt;任意字母&gt;表示泛型，但是为了规范我们一般使用 T表示，函数定义了泛型后传入的参数也需要定义泛型，但是函数的返回值可以任意类型 12345function getData&lt;T&gt;(value: T): T { return value;}console.log(getData&lt;number&gt;(12)); //12console.log(getData&lt;string&gt;(\"张三\")); //张三 注意：在传入参数的时候定义的类型必须和参数类型一致 1234function getData&lt;T&gt;(value: T): any { //当函数的返回类型是any时，可以定义任意返回值 return \"hello\";}console.log(getData(\"zs\")); //hello 泛型类 普通取最小值 1234567891011121314151617181920class Sort { public list: number[] = []; add(num: number) { this.list.push(num); } min(): number { let min = this.list[0]; for (let i = 0; i &lt;= this.list.length; i++) { if (min &gt; this.list[i]) { min = this.list[i]; } } return min; }}let m = new Sort();m.add(10);m.add(1);m.add(20);console.log(m.min()); //1 这样定义的类我们不能往数组里面添加字母，不能实现字母的排序，所以需要使用泛型 123456789101112131415161718192021222324class Sort&lt;T&gt; { public list: T[] = []; add(value: T): void { this.list.push(value); } min(): T { let min = this.list[0]; for (let i = 0; i &lt;= this.list.length; i++) { if (min &gt; this.list[i]) { min = this.list[i]; } } return min; } } let m = new Sort&lt;number&gt;(); //实例化 并且指定了T代表number m.add(20); m.add(1); m.add(10); console.log(m.min()); // 1 let m2 = new Sort&lt;string&gt;(); // 实例化 并且指定了T代表string m2.add(\"a\"); m2.add(\"v\"); console.log(m2.min()); 泛型函数 如果我们在定义一个函数接口时，无法根据传入的参数类型作为返回数据类型，不够灵活 1234567interface Config { (name: string, age: number): string;}let getData: Config = function(name: string, age: number): string { return name + age;};console.log(getData(\"张三\", 12)); //张三 12 定义泛型函数接口的时候，并不是我们在函数中规定了数据的类型，而是在调用的时候传入类型，那么这个泛型就是传入的数据类型 第一种定义方法： 1234567interface Config { &lt;T&gt;(value: T): T;}let getinfo: Config = function&lt;T&gt;(value: T): T { return value;};console.log(getinfo&lt;number&gt;(12)); //12 此时，在这里我们传入了number，那么T就是指的number 定义方式二： 123456789interface Config&lt;T&gt; { //定义泛型接口 (value: T): T;}function getinfo&lt;T&gt;(value: T): T { return value;}let getData: Config&lt;number&gt; = getinfo; //给接口定义类型且getData使用这个接口console.log(getData(12)); //12 把类作为参数类型的泛型类 把类作为参数来约束数据传入的类型 示例1：定义User类，对数据库进行映射 1234567891011121314151617class User { username: string | undefined; password: string | undefined;}class Mydb { add(user: User): boolean { console.log(user); return true; }}let u = new User();u.username = \"张三\";u.password = \"123aaa\";let db = new Mydb();db.add(u); User{username:'张三',password:'123aaa'} 示例2： 123456789101112131415161718class ArticleCate { title: string | undefined; desc: string | undefined; status?: number | undefined;}class Mydb { add(info: ArticleCate): boolean { console.log(info); return true; }}let a = new ArticleCate();a.title = \"美味中国\";a.desc = \"江西美食\";let db = new Mydb();db.add(a); //ArticleCate { title: '美味中国', desc: '江西美食' } 我们可以使用不同的类作为参数进行数据的约束 示例3：泛型类 12345678910111213141516171819202122232425262728293031323334353637class Mydb&lt;T&gt; { add(info: T): boolean { //经过数据的校验，就可以将info传入数据库了 console.log(info); return true; } updata(info: T, id: number): boolean { //更新数据，info表示更新数据的内容，id表示更新数据的id console.log(info); console.log(id); return true; }}class ArticleCate { title: string | undefined; desc: string | undefined; status?: number | undefined; constructor(params: { //可以使用构造函数进行传参 title: string | undefined; desc: string | undefined; status?: number | undefined; }) { this.title = params.title; this.desc = params.desc; this.status = params.status; }}var a = new ArticleCate({ //直接传入参数 title: \"分类\", desc: \"000\", status: 200});var db = new Mydb&lt;ArticleCate&gt;();db.add(a); //ArticleCate { title: '分类', desc: '000', status: 200 }db.updata(a, 12); //ArticleCate { title: '分类', desc: '000', status: 200 } 12 以上就是Typescript中的泛型的一些使用方法。","link":"/2019/07/09/TypeScript中的泛型/"},{"title":"TypeScript中的模块以及命名空间","text":"关于TypeScript中的模块化在1.5版本中发生了变化，”内部模块”现在称为”命名空间”，外部模块现在简称为”模块” 前言 在模块化的概念中，模块(外部模块)在其自身的作用域里执行，而不是在全局作用域里，这也意味着定义一个模块的变量、函数、类等等在模块的外部都是不可见的，除非你明确地使用 export形式导出它们。相反，如果使用其他模块导出的变量、函数、接口时，必须导入，可以使用import形式导入。 TypeScript中的模块以及命名空间 使用 export 导出模块 123456//这是一个 db.ts文件export function getData(): any[] { //导出方法 console.log(\"获取数据库\"); return [{ title: \"中国美食\" }];}export var data = \"hello\"; //导出变量 使用 import 导入模块 1234//这是index.tsimport { getData, data } from \"./modules/db\";//这里的db不需要加 ts后缀getData(); //获取数据库console.log(data); //hello 因为在之前我们已经说过模块化的导入导出问题(模块的导入与导出) 命名空间和模块化的区别 命名空间:内部模块，主要用于组织代码，避免命名冲突 模块:ts的外部模块的简称，侧重代码的复用，一个模块可能会有多个命名空间 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061namespace A { interface Animal { name: string; eat(str: string): void; } class Dog implements Animal { name: string; //必须定义 constructor(name: string) { this.name = name; } eat() { //必须定义 return `${this.name}爱吃粮食`; } } var d = new Dog(\"小黑\"); console.log(d.eat()); //小黑爱吃粮食 class Cat implements Animal { name: string; constructor(name: string) { this.name = name; } eat(food: string) { return `${this.name}爱吃${food}`; } } var c = new Cat(\"小花猫\"); console.log(c.eat(\"小老鼠\")); //小花猫爱吃小老鼠}namespace B { interface Animal { name: string; eat(str: string): void; } class Dog implements Animal { name: string; //必须定义 constructor(name: string) { this.name = name; } eat() { //必须定义 return `${this.name}爱吃粮食`; } } var d = new Dog(\"小黑\"); console.log(d.eat()); //小黑爱吃粮食 class Cat implements Animal { name: string; constructor(name: string) { this.name = name; } eat(food: string) { return `${this.name}爱吃${food}`; } } var c = new Cat(\"小花猫\"); console.log(c.eat(\"小老鼠\")); //小花猫爱吃小老鼠} 这样我们就可以在一个文件中定义相同的名字的数据了，但是这样的数据是私有的，如果我们像使用里面的数据。需要暴露出来 使用暴露并使用命名空间中的数据 123456789101112131415161718192021222324252627namespace A { interface Animal { name: string; eat(str: string): void; } export class Dog implements Animal { //向外暴露类 name: string; //必须定义 constructor(name: string) { this.name = name; } eat() { //必须定义 return `${this.name}爱吃粮食`; } } export class Cat implements Animal { //向外暴露类 name: string; constructor(name: string) { this.name = name; } eat(food: string) { return `${this.name}爱吃${food}`; } }}var c = new A.Cat(\"小狼狗\");console.log(c.eat(\"狗粮\")); //小狼狗爱吃粮食 我们还可以将命名空间封装在一个模块中，我们在使用的时候只需要导入就可以使用了，一个模块中可以有多个命名空间 1234567891011121314151617181920212223242526//namespace.ts文件export namespace A { interface Animal { name: string; eat(str: string): void; } export class Dog implements Animal { name: string; //必须定义 constructor(name: string) { this.name = name; } eat() { //必须定义 return `${this.name}爱吃粮食`; } } export class Cat implements Animal { name: string; constructor(name: string) { this.name = name; } eat(food: string) { return `${this.name}爱吃${food}`; } }} 1234//index.ts文件import { A as namespaceA } from \"./namespace\"; //引入模块并重命名let dog = new namespaceA.Cat(\"小黑\");console.log(dog.eat(\"狗粮\")); //小黑爱吃狗粮 需要注意的是，模块并不能直接在浏览器中运行，如果需要，则需要使用webpack对文件进行打包生成ES5的代码浏览器才能识别，我们可以使用Nodejs的环境来运行 总结: 模块就是封装了一些功能的代码 命名空间在模块中，且一个模块中可以有多个命名空间","link":"/2019/07/09/TypeScript中的模块以及命名空间/"},{"title":"TypeScript中的类","text":"在 typescript 中，类的定义与 ES6的语法 稍有些差别，但是与 java,C++等更加相像了 Typescript 中的类 在 Typescript 中使用class关键字定义类 使用 class 定义类： 123456789101112131415class Person {name: string; //属性age: number;constructor(name: string, age: number) {//构造函数 实例化的时候触发的方法,相当于对实例化时传递的参数进行赋值this.name = name;this.age = age;}run() {console.log(this.name + \"---\" + this.age);}}var p = new Person(\"张三\", 12);p.run(); //张三 修改属性值 修改类中的属性值 1234567891011121314151617181920212223242526272829303132333435 class Person { name: string; //属性 constructor(name: string) { this.name = name; } getName(): void { console.log(this.name); } setName(name: string): void { this.name = name; } } var p = new Person(\"张三\"); p.getName(); //张三 p.setName(\"李四\"); //修改 name 的值 p.getName(); //李四 ```### 继承- 继承父类 ``` class Person { name: string; //属性 constructor(name: string) { this.name = name; } run() { console.log(this.name); } } var p = new Person(\"张三\"); class Web extends Person {} //如果直接继承，那么就是相当于复制了Person，继承了他的构造函数 var w = new Web(\"李四\"); w.run(); //李四 方法的继承 1234567891011121314151617181920class Person { name: string; //属性 constructor(name: string) { this.name = name; } run(): void { console.log(this.name); }}var p = new Person(\"张三\");class Web extends Person { constructor(name: string) { super(name); //这里表示继承父类的构造器，初始化自己的构造函数 } run(): void { console.log(`我是：${this.name}`); }}var w = new Web(\"李四\");w.run(); //我是李四，当子类和父类都有同一个方法时，子类会调用自己的 类的修饰符 typescript 中定义属性给我们提供了三种修饰符 public:表示公有 在类里面、子类、类外面都可以进行访问 protected：保护类型 在类里面、子类里面可以访问，在类外部没法访问 private：私有 在类里面可以进行访问，子类、类外部都不能进行访问 注意：属性如果不加修饰符，默认就是公有的(public) 公有属性(public) 在类外部访问 1234567891011class Person { public name: string; //公有属性 constructor(name: string) { this.name = name; } run() { console.log(this.name); }}var p = new Person(\"张三\");console.log(p.name); //张三 在类内部和子类内部访问 123456789101112131415161718192021class Person { public name: string; //公有属性 constructor(name: string) { this.name = name; } run(): string { return this.name; }}var p = new Person(\"张三\");console.log(p.run()); //张三class Web extends Person { constructor(name: string) { super(name); } work(): string { return `${this.name}在工作`; }}var w = new Web(\"李四\");console.log(w.work()); //李四在工作 保护属性(protected) 在类内部和子类内部访问 123456789101112131415161718192021class Person { protected name: string; //保护类型 constructor(name: string) { this.name = name; } run(): string { return `${this.name}在上班`; }}var p = new Person(\"张三\");console.log(p.run()); //张三在上班class Web extends Person { constructor(name: string) { super(name); } work() { return `${this.name}在工作`; }}var w = new Web(\"李四\");console.log(w.work()); //李四在工作 在类外部访问和子类外部访问 123456789101112131415161718192021class Person { protected name: string; //保护类型 constructor(name: string) { this.name = name; } run(): string { return `${this.name}在上班`; }}var p = new Person(\"张三\");console.log(p.name); //报错，name受保护class Web extends Person { constructor(name: string) { super(name); } work() { return `${this.name}在工作`; }}var w = new Web(\"李四\");console.log(w.name); //报错，name受保护 私有类型(private) 在类外部访问 1234567891011class Person { private name: string; //公有属性 constructor(name: string) { this.name = name; } run(): string { return this.name; }}var p = new Person(\"张三\");console.log(p.name); //报错，私有属性只能在内部中访问 在子类内部和外部访问 12345678910111213141516171819class Person { private name: string; //公有属性 constructor(name: string) { this.name = name; } run(): string { return this.name; }}var p = new Person(\"张三\");class Web extends Person { constructor(name: string) { super(name); } work(): string { return `${this.name}在工作`; //在这里就报错了，只能在Person内部中访问，所以外部没有试验的必要了 }}var w = new Web(\"李四\"); 在类内部访问 1234567891011class Person { private name: string; //公有属性 constructor(name: string) { this.name = name; } run(): string { return this.name; }}var p = new Person(\"张三\");console.log(p.run()); //张三 总结: 在类的定义中： + 公有的类里面，在当前类里面、子类、类外面都可以访问 + 在保护类里面，在当前类、子类里面都可以访问，在类外面不能访问 + 在私有类里面，在当前类里面可以访问，在子类，类外面都不能进行访问 一上就是在 TypeScript 中的类的相关知识。","link":"/2019/07/08/TypeScript中的类/"},{"title":"TypeScript中的数据类型","text":"JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。这里主要介绍前五种原始数据类型和一些其他的TypeScript的数据类型 Typescript中的数据类型布尔类型(boolean)1234&lt;!--在ES5中--&gt;var flag= true flag=123 console.log(flag) //123 12345678&lt;!--在Typescript中--&gt;var flag= true flag=123 //在这里时，编译器已经报错了&lt;!--正确的写法--&gt;var flag:boolean= true flag=false console.log(flag) //false 数字类型(number) 12345678910111213&lt;!--在ES5中--&gt;var num=123 num='aa' console.log(num) //aa&lt;!--在typesctipt--&gt;var num:number=123 num='str'// 编译器报错 &lt;!--正确的写法--&gt;var num:number = 123 num=456 console/log(num) //num 根据前两个我们已经可以看的出来.只要规定了该变量是什么类型或者是第一个赋值该变量的数据是什么类型的,这个变量就是什么类型的数据,并且赋值只能赋值相同的类型数据,否则直接报错 字符串类型(string) 1234&lt;!--在typescript中--&gt;let str:string = 'string' str = 'hello' console.log(str) //hello 数组类型(array)定义方式一: 在变量名后面跟上数组的类型 12345let arr:number[]= [12,11]arr=[\"123\",123] //这样就报错了arr=[123,456] //这样是正确的 定义方式二: 在变量名定义数组的时候在&lt;&gt;中定义数组的类型 12let arr:Array&lt;number&gt;=[12,123]console.log(arr) 定义方式三: 在下面有any类型的讲解 12let arr:any[]=['123',456,false]console.log(arr) //输出: [ '123', 456, false ] 元祖类型(tuple) 属于数组中的一种,可以定义多种数据类型,但是必须一一对应 12let arr:[number,string]=[123,\"123\"]arr=[\"123\",123] //这样是错误的,值必须与数据类型一一对应 枚举类型(enum) 123456enum Flag{ success=200, error=500}let s:Flag=Flag.successconsole.log(s) //输出:200 如果赋值了那么打印的就是你赋值的数字 123456enum Flag{ success=1, error=2}let s:Flag=Flag.successconsole.log(s) //输出:0 如果没有赋值那么输出的结果就是对应的下标,从 0 开始 1234567enum Flag{ success, 'error'=3, number}let s:Flag=Flag.numberconsole.log(s) //输出: 4,相当于前面的error=3赋值的是数组的下标,后面的值没有定义的话就是默认前面的下标+1 为了详细一点,我们在看一下这个代码就清楚了 12345678910111213141516enum Flag{ 'success'=-1, 'error'=999, number}let s:Flag=Flag.numberconsole.log(s) //输出 1000enum Flag{ 'success'=-10, 'error'=-15, number}let s:Flag=Flag.numberconsole.log(s) //输出 -14 注意: 在这个Flag中定义的名称可以加 ‘ ‘,也可以不加 ‘ ‘,但是值一定不能加‘ ‘,并且只能是数字,否则报错 任意类型(any)123let num:any[]=['123',123]num=['a',45]console.log(num); // 输出: ['a',45] any可以是任意的类型,但是我们在平时定义数据时不要随意使用any,不然其他的数据类型设计就没有意义了 any的正确用法: 12let app = document.getElementById('app')app.style.color= 'red' //报错了,对象可能为空 在Typescript中,并没有Object类型,所以无论定义什么具体类型,都会报错,这个时候我们就需要加入any 12let app:any = document.getElementById('app')app.style.color= 'red' 这样我们就完美的解决了这个错误 null和undefined 其他数据类型的子类型 示例: 12let num:numberconsole.log(num) //报错,在赋值前使用了num 这说明number类型的数据在赋值前都不能使用 12let num:undefinedconsole.log(num) //输出: undedined 有时候我们不管这个存不存在,存在的话就是number类型,不存在就是undefined类型 联合类型 123var num:undefined | number | nullnum=123console.log(num) //输出 123 并且不报错 12var num:undefined | number | nullconsole.log(num) //输出:undefined ,就算是没有赋值也不会报错 123var num:undefined | number | nullnum=nullconsole.log(num) //输出 null 这样就相当于有值就是number类型,没有值就是undefined,赋值为null就是null,因为undefined只能赋值为undefined,null只能赋值为null viod 类型 在typescript中,viod类型表示没有任何类型,一般定义没有返回值的方法 示例: 12345&lt;!--在ES5中--&gt;function run():void{ console.log('hello world')}run() //正常输出 1234function run():undefined{ console.log('aaa');}run() //报错,声明类型如果不是 viod 或者 any ,必须要有返回值 12345function run():undefined{ return null }run() //报错,不能返回数据类型不同的数据 never类型 never类型其他类型(包括了null,undefined)的子类型,代表从来不会出现的值,怎么理解呢? 12345let a:nevera=123 //报错let b:neverb=null //报错 这就说明了它不能是任意我们可以有的值,必须是没有的数据类型 1234let err:nevererr= (()=&gt;{ throw Error('error')})() 当我们使用never定义自执行函数抛出错误时,那么就可以使用never了,但是使用场景并不是很多,很多时候我们使用any来代替 总结的一些问题: 类型的推断 1234let num;num='45',num=123console.log(num) //123 我们可以推断,如果一开始没有给变量赋值,那么我们推断它默认就是 any 类型,可以赋任意值,和变量没有指定数据类型赋值一样,我们推断它是使用第一个赋值的数据类型作为该变量数据类型 在viod类型中,函数如果没有返回值那么使用 viod定义,如果有返回值,那么返回数据类型必须和定义函数的数据类型保持一致","link":"/2019/07/07/TypeScript中的数据类型/"},{"title":"TypeScript对类型、接口、类、泛型的综合运用","text":"定义一个操作数据库的类 Typescript对类型、接口、类、泛型的综合使用 综合使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687interface DBI&lt;T&gt; { add(info: T): boolean; updata(info: T, id: number): boolean; dalete(id: number): boolean; get(id: number): any[];}//定义一个操作mysql数据库的类//注意：如果需要实现泛型接口时，那么这个实现泛型接口的类也需要是一个泛型类class Mysqldb&lt;T&gt; implements DBI&lt;T&gt; { constructor() {// console.log(\"这里可以建立和数据库的连接\"); } add(info: T): boolean { //添加数据，这里可以进行对数据库的增加操作 console.log(info); return true; } updata(info: T, id: number): boolean { //根据id更新数据，对数据库进行更新操作 console.log(info); console.log(id); return true } dalete(id: number): boolean { //根据id删除数据，对数据库进行删除操作 console.log(id); return true } get(id: number): any[] { //根据id 得到数据，对数据库进行查找操作 console.log(id); let lits:any[]=[] return lits }}//定义操作mssql数据库的类class MssqlDB&lt;T&gt; implements DBI&lt;T&gt; { constructor() {// console.log(\"这里可以建立和数据库的连接\"); } add(info: T): boolean { console.log(info); return true; } updata(info: T, id: number): boolean { console.log(info, id); return true; } dalete(id: number): boolean { console.log(id) } get(id: number): any[] { console.log(id); let lits:any[]=[] return lits }}//定义一个User数据表做数据库的映射class User { username: string | undefined; password: string | undefined; constructor(params: { //使用构造函数传值 username: string | undefined; password: string | undefined; }) { this.password = params.password; this.username = params.username; }}//往数据表添加数据let u = new User({ username: \"张三\", password: \"123aaa\"});//操作mysql// let mysql = new Mysqldb(); //如果此时没有使用定义的user作为限制，add()中参数可以是任意值，没有做类型的校验// mysql.add('aaa');let mysql = new Mysqldb&lt;User&gt;(); //此时使用User类作为限制类型，那么在实例化后的add中我们只能传入User类mysql.add(u); //User { password: '123aaa', username: '张三' }let m = new User({ username: \"李四\", password: \"lisi\"});// 操作mssqllet mssql = new MssqlDB&lt;User&gt;();mssql.add(m); // User { password: 'lisi', username: '李四' }mssql.updata(m, 12); //User { password: 'lisi', username: '李四' } 12 这样我们定义一个数据库的，只需要调用对应的数据库进行数据操作，而且对不同的数据库都是兼容的。当然，这些代码还可以封装到模块里面去，每个数据库的类封装一个模块。这样我们调用的时候只需要引入模块即可进行增删改查的相关操作了。","link":"/2019/07/09/TypeScript对类型、接口、类、泛型的综合运用/"},{"title":"Redux的一些坑","text":"Redux的一些坑，可以帮助我们避免开发中的一些问题。 Redux的一些坑 reducer.js中不是修改state，对state的数据进步操作，而是返回数据，然后store会监听这个数据的变化做出变化 reducer必须是纯函数 如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。1234function priceAfterTax(productPrice) {return (productPrice * 0.20) + productPrice; } 这种不管外界怎么变化，时间怎么变化，运行多少次，结果都不会发生变化，这就是纯函数 1234var tax = 20;function calculateTax(productPrice) { return (productPrice * (tax/100)) + productPrice;} 这种数据计算结果依赖于外界数据的tax，这种函数就是不纯的","link":"/2019/08/04/Redux的一些坑/"},{"title":"TypeScript中的接口","text":"接口的作用，在面向对象编程中接口是一种规范的定义，它定义了行为和动作规范，在程序设计里面，接口起到了一种限制和规范的作用。接口定义了某一批类所需要遵守的规则，接口不关心这些类的内部状态数据，也不关心这些类里的方法细节，它只规定这批类里必须提供某些方法，提供这些方法的的类就可以满足实际需要，typescript的接口类似于Java，同时还增加了许多更灵活的接口类型，它包括属性、函数，可索引和类定义标准 TypeScript中的接口 对传入的参数进行约束 1234function getinfo(label:string): void { console.log(\"getinfo\");}getinfo(); //报错，提示需要传递一个参数 其实这个就是约束，就是规则 自定义方法传入参数对json进行约束 1234function getinfo(label: { name: string }): void { console.log(\"getinfo\");}getinfo({ name: \"zs\" }); //传入一个对象，且对象中第一个参数是name，还要string类型的数据 接口 行为和动作的规范，对批量方法进行约束 属性接口： 1234567891011interface FullName { firstName: string; secondName: string;}function printName(name: FullName) { console.log(name.firstName + \"---\" + name.secondName);}printName({ //使用这种方式传递只能传递interface定义好的属性 firstName: \"Mr\", secondName: \"Zhong\"}); //输出Mr Zhong 12345678910111213interface FullName { firstName: string; secondName: string;}function printName(name: FullName) { console.log(name.firstName + \"---\" + name.secondName + \"--\" + name.age);}let obj = { age: \"12\", firstName: \"Mr\", secondName: \"Zhong\"}; //使用外界定义对象传入的方式可以定义不同的属性但是必须有interface定义的属性printName(obj); //输出Mr Zhong 接口的可选属性 可选属性： 1234567891011interface FullName { firstName: string; secondName?: string; //定义可选属性}function printName(name: FullName) { console.log(name.firstName + \"---\" + name.secondName);}printName({ //可选属性可写可不写 firstName: \"firstname\"}); //输出Mr--undefined 属性类型封装的ajax 封装的ajax 12345678910111213141516171819202122232425262728interface Config { url: string; dataType: string; data?: string; type: string;}function ajax(config: Config) { var xhr = new XMLHttpRequest(); xhr.open(config.type, config.url, true); xhr.send(config.data); xhr.onreadystatechange = function() { if (xhr.readyState === 4) { if (xhr.status === 200) { if (config.dataType == \"json\") { console.log(JSON.parse(xhr.responseText)); } else { console.log(xhr.responseXML); } } } };}ajax({ url: \"http://a.itying.com/api/productlist\", //这个是api接口 dataType: \"json\", type: \"get\", data: \"name=zhangsan\"}); 函数类型的接口 加密的函数类型接口 1234567891011121314interface encrypt { //加密的函数类型接口 (key: string, value: string): string;}var md5: encrypt = function(key: string, value: string): string { return key + value; //真实的加密这里是经过一系列的算法进行加密，这里是模拟操作};console.log(md5(\"zhangsan\", \"14\")); //zhangsan14var info: encrypt = function(key: string, value: string): string { //这里继续使用加密接口 return key + \"---\" + value;};console.log(info(\"hello\", \"world\")); //hello--world 可索引的接口 对数组、对象的约束(不常用) 对数组: 12345interface UserArr { [index: number]: string; //下标是number，值是string}var arr: UserArr = [\"aaa\", \"bbb\"];console.log(arr[0]); //aaa 对对象： 12345interface UserArr { [index: string]: string;}var arr: UserArr = { name: \"张三\" };//name属性双引号可写可不写console.log(arr[\"name\"]); //张三 类类型接口 类类型接口 12345678910111213141516interface Animal { name: string; eat(str: string): void;}class Dog implements Animal { name: string; //必须定义 constructor(name: string) { this.name = name; } eat() { //必须定义 return `${this.name}爱吃粮食`; }}var d = new Dog(\"小黑\");console.log(d.eat()); //小黑爱吃粮食 12345678910111213141516171819202122232425262728interface Animal { name: string; eat(str: string): void;}class Dog implements Animal { name: string; //必须定义 constructor(name: string) { this.name = name; } eat() { //必须定义 return `${this.name}爱吃粮食`; }}var d = new Dog(\"小黑\");console.log(d.eat()); //小黑爱吃粮食class Cat implements Animal { name: string; constructor(name: string) { this.name = name; } eat(food: string) { return `${this.name}爱吃${food}`; }}var c = new Cat(\"小花猫\");console.log(c.eat(\"小老鼠\")); //小花猫爱吃小老鼠 接口的扩展 继承接口： 123456789101112131415161718192021interface Animal { eat(): void;}interface Person extends Animal { work(): void;}class Web implements Person { name: string; constructor(name: string) { this.name = name; } eat() { console.log(`${this.name}喜欢吃馒头`); } work() { console.log(`${this.name}是程序员`); }}var m = new Web(\"张三\");m.eat(); //张三喜欢吃馒头m.work(); //张三是程序员 继承类和继承接口 1234567891011121314151617181920212223242526272829303132import { closeSync } from \"fs\";interface Animal { eat(): void;}interface Person extends Animal { work(): void;}class Programmer { public name: string; constructor(name: string) { this.name = name; } coding(code: string) { console.log(this.name + code); }}class Web extends Programmer implements Person { //即继承programmer类 又使用继承的Person接口 constructor(name: string) { super(name); } eat() { console.log(`${this.name}喜欢吃馒头`); } work() { console.log(`${this.name}是程序员`); }}var m = new Web(\"张三\");m.eat(); //张三喜欢吃馒头m.work(); //张三是程序员 这些就是在Typescript中的接口的一些使用和说明。","link":"/2019/07/08/TypeScript中的接口/"},{"title":"Vuex的使用","text":"vuex是什么？Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 前言 我们在进行一些复杂的父子组件之间的传值的时候，尤其是组件嵌套传值时尤其麻烦，读取值不方便，如果有异步操作，还需要对值监听，这样获取一些值得时候对我们开发人员不友好，所以诞生了Vuex Vuex的使用vuex的安装配置 安装:npm install vuex -S 如果使用&lt;script&gt;&lt;/script&gt;标签引入的vue，那么自己会安装有vuex 安装插件： 1234import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex) 配置: 123456789101112// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)const store = new Vuex.Store({ state: { //这个就是相当于 vue中的 data，用来存放数据的 count: 0 }, mutations: { //这个相当于 vue 中的 methods ，存放了些方法 increment (state) { state.count++ } }}) 使用:实现一个小案例，官方也是这个案例来说明的： main.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 入口文件import Vue from 'vue'// 配置vuex的步骤// 1. 运行 cnpm i vuex -S // 2. 导入包import Vuex from 'vuex'// 3. 注册vuex到vue中Vue.use(Vuex) // 4. new Vuex.Store() 实例，得到一个 数据仓储对象var store = new Vuex.Store({ state: { // 大家可以把 state 想象成 组件中的 data ,专门用来存储数据的 // 如果在 组件中，想要访问，store 中的数据，只能通过 this.$store.state.*** 来访问 count: 0 },mutations: { // 注意： 如果要操作 store 中的 state 值，只能通过 调用 mutations 提供的方法，才能操作对应的数据，不推荐直接操作 state 中的数据，因为 万一导致了数据的紊乱，不能快速定位到错误的原因，因为，每个组件都可能有操作数据的方法； increment(state) { state.count++ }, // 注意： 如果组件想要调用 mutations 中的方法，只能使用 this.$store.commit('方法名') // 这种 调用 mutations 方法的格式，和 this.$emit('父组件中方法名') subtract(state, obj) { // 注意： mutations 的 函数参数列表中，最多支持两个参数，其中，参数1： 是 state 状态； 参数2： 通过 commit 提交过来的参数； console.log(obj) state.count -= (obj.c + obj.d) }},getters: { // 注意：这里的 getters， 只负责 对外提供数据，不负责 修改数据，如果想要修改 state 中的数据，请 去找 mutations optCount: function(state) { return '当前最新的count值是：' + state.count } // 经过咱们回顾对比，发现 getters 中的方法， 和组件中的过滤器比较类似，因为 过滤器和 getters 都没有修改原数据， 都是把原数据做了一层包装，提供给了 调用者； // 其次， getters 也和 computed 比较像， 只要 state 中的数据发生变化了，那么，如果 getters 正好也引用了这个数据，那么 就会立即触发 getters 的重新求值； }})import App from './App.vue'const vm = new Vue({ el: '#app', render: h =&gt; h(App), store // 5. 将 vuex 创建的 store 挂载到 VM 实例上， 只要挂载到了 vm 上，任何组件都能使用 store 来存取数据}) counter.vue文件内容 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div&gt; &lt;input type=\"button\" value=\"减少\" @click=\"remove\"&gt; &lt;input type=\"button\" value=\"增加\" @click=\"add\"&gt; &lt;br&gt; &lt;input type=\"text\" v-model=\"$store.state.count\"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { // count: 0 }; }, methods: { add() { // 不要这样使用，不符合 vuex 的设计理念，因为这样直接操作了state // this.$store.state.count++; this.$store.commit(\"increment\"); }, remove() { this.$store.commit(\"subtract\", { c: 3, d: 1 }); } }, computed:{ fullname: { get(){}, set(){} } }};&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt;&lt;/style&gt; amount.vue文件内容： 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;!-- &lt;h3&gt;{{ $store.state.count }}&lt;/h3&gt; --&gt; &lt;h3&gt;{{ $store.getters.optCount }}&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt;&lt;/style&gt; 这样，这两个兄弟节点，就可以通过state读写数据了，不需要进行组件之间的传值 总结： state中的数据，不能直接修改，如果想要修改，必须通过 mutations,不然的话就违背了vuex的设计初衷 如果组件想要直接 从 state 上获取数据： 需要 this.$store.state.*** 如果 组件，想要修改数据，必须使用 mutations 提供的方法，需要通过 this.$store.commit('方法的名称'， 唯一的一个参数) 如果 store 中 state 上的数据， 在对外提供的时候，需要做一层包装，那么 ，推荐使用 getters, 如果需要使用 getters ,则用 this.$store.getters.***","link":"/2019/07/05/Vuex的使用/"},{"title":"webpack打包图片","text":"在webpack中，我们使用其打包一些项目的时候，经常会遇到图片，但是如果直接打包图片则会抛出异常，以下是打包图片的一些详细配置文件和步骤 使用webpack打包图片 在平常中，我们在设置style中使用background:url 可以引入背景图片，在前面我们已经学会如何打包css、less、scss文件 安装url-loader和其依赖file-loader cnpm install url-loader file-loader -D 使用file-loader进行图片的打包 在webpack.config.js中配置，在与其他配置下添加如下即可 1234{ test: /\\.jpg|png|gif|bmp|jpeg/, //配置图片 use: ['file-loader'] } 可以简写成如下： 1234{ test: /\\.(jpg|png|gif|bmp|jpeg)/, //配置图片打包的格式 loader: 'file-loader' } 如果想要打包出来的图片不改变名字和格式，只需添加options即可 123456{ test: /\\.(jpg|png|gif|bmp|jpeg)/, //配置图片打包的格式 loader: 'file-loader' options: { //[name]表示名字,[ext]表示格式，而name属性其实就是图片打包后的路径 name: 'images/[name].[ext]' } 除了使用file-loader对图片进行打包处理外，我们同样也可以使用url-loader代替，另外我们还可以对小于某个大小的图片进行base64格式的转化处理。 使用url-loader打包 12345678{ test: /\\.(png|jpg|gif|svg)$/, loader: 'url-loader', options: { name: './images/[name].[ext]', limit: 8192 }} 这里limit属性的作用就是将小于8192B（8.192K）大小的图片转成base64格式，而大于这个大小的图片将会以file-loader的方式进行打包处理 注意：如果不写limit属性，那么url-loader就会默认将所有图片转成base64 这样打包出来的图片会自动转换成base64,但是我们多数是将小图片转成base64，而大图片不进行转换 而对于有些图片在不同路径下，但是文件名字一样时，我们需要在name:属性中增加hash值：定义[hash:8]定义 8位hash值最多32位，这样图片就不会存在不同 123456789{ test: /\\.(jpg|png|gif|bmp|jpeg)/, //配置图片 loader: 'url-loader', //在这里时，只有一个我们可以简化 loader，使用use则会报错 options: { limit: 2000, //limit 的值单位是 Byte ，如果图片小于limit的值，则转成base64格式的字符串，如果大于，则不转 name: '[hash:8]-[name].[ext]' //这是将文件名原样输出[name]指的是图片名，[ext]是图片格式， //[hash:8]表示生成8位hash值，否则在不同文件夹下同名图片会失效，用来区分 } }","link":"/2019/06/22/webpack打包图片/"},{"title":"TypeScript中的装饰器","text":"装饰器是过去几年中JavaScript最大成就之一，已是ES7的标准特性之一 TypeScript中的装饰器 装饰器：装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，属性或参数上，可以修改类的行为 常见的装饰器 类装饰器 属性装饰器 方法装饰器 参数装饰器 装饰器的写法 普通装饰器（不可传参） 工厂装饰器（可传参）类装饰器 类装饰器在类声明之前被声明(紧靠类声明)。类装饰器应用于构造函数，可以用来监视，修改或替换类定义。传入一个参数定义一个普通的装饰器(类装饰器) 12345678910111213function getData(params: any) { //普通模式是Http params.prototype.data = \"hello\"; params.prototype.run = function() { console.log(\"我是run\"); };}@getData //这里不能使用 ; 号class Http { constructor() {}}var http: any = new Http();console.log(http.data); //hellohttp.run(); //我是run 定义一个工厂装饰器 12345678910111213function getData(params: string) { //工厂装饰器params是传递的参数 return function run(targe: any) { console.log(targe); //[Function Http] 这个表示Http console.log(params); //hh 传递的参数 targe.prototype.api = params; };}@getData(\"hh\")class Http { constructor() {}}var http: any = new Http();console.log(http.api); //hh 123456789101112131415161718192021function getData(params: any) { return class extends params {//这里的params相当于是Http 继承它 api: any = \"我是修改后的api\"; getdata() { this.api = this.api + \"--\"; console.log(this.api); } };}@getDataclass Http { public api: string | undefined; constructor() { this.api = \"我是api\"; } getdata() { console.log(this.api); }}var h = new Http();h.getdata(); //我是修改后的api 属性装饰器 属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数： 一是：对于静态成员来说是类的构造函数，对于示例成员是类的原型对象 二是：成员的名字123456789101112131415161718192021222324252627282930// 类装饰器function logClass(params: string) { //params 是传递的参数 return function(target: any) { //target是 Htpp console.log(params); // xxx console.log(target); //[Function: Http] };}//属性装饰器function logUrl(params: any): any { console.log(params); //www.baidu.com return function(target: any, attr: any) { console.log(target); //http{} 第一个参数就是成员(在这里指的是url)实例的原型对象 console.log(attr); //url 第二个参数打印出来的就是装饰属性的名称 target[attr] = params; //因为attr是变量所以不能通过 . 的方式访问，而target是实例的原型对象，这里就相当于在实例的原型对象上添加了attr属性并且赋值 };}@logClass(\"xxx\")class Http { @logUrl(\"www.baidu.com\") public url: any; constructor() {} getdata() { console.log(this.url); }}var h = new Http();h.getdata(); //www.baidu.comconsole.log(h.url); //www.baidu.com 方法装饰器 方法装饰器：他会被应用到方法的属性描述符上，可以用来监视，修改或者替换方法定义 方法装饰会在运行时传入三个参数 1.对于静态成员来说是类的构造函数，对于实例成员是类的原型对象 2.成员的名称 3.成员的属性描述 方法装饰器一：(查看一些属性) 12345678910111213141516171819202122function logMethod(params: string) { return function(targe: any, methodName: any, desc: any) { // console.log(targe); // Http { getdata: [Function] } // console.log(methodName); // getdata console.log(desc); //{ value: [Function], writable: true,enumerable: true,configurable: true} targe.api = \"www.baidu.com\"; targe.run = function() { console.log(\"hello\"); }; };}class Http { public url: any; constructor() {} @logMethod(\"www.baidu.com\") getdata() { console.log(this.url); }}var h: any = new Http();console.log(h.api); //www.baidu.comh.run(); //hello 方法装饰器二：(修改方法) 123456789101112131415161718192021222324function logMethod(params: string) {return function(targe: any, methodName: any, desc: any) { console.log(desc.value); //这个就是方法的函数 var funDesc = desc.value; //保存一下原来的方法 desc.value = function(...args: any[]) {//修改方法 args = args.map(value =&gt; { return String(value); //将传递的参数全部变成String类型 }); console.log(args); funDesc.apply(this, args); //这样可以将保存到的getdata指向这个新的函数，然后传递已经处理好的数据 args };};}class Http {public url: any;constructor() {}@logMethod(\"www.baidu.com\")getdata(...args: any[]) { console.log(args); //[ 'ads', '123' ] console.log(\"hello\"); //hello}}var h = new Http();h.getdata(\"ads\", 123); // [ 'ads', '123' ] 方法参数装饰器 参数装饰器表达式会在运行时当作函数被调用，可与使用参数装饰器为类的原型增加一些元素数据，传入三个参数 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象 方法的名字 参数在函数参数列表中的索引 1234567891011121314151617function logMethod(params: any) {return function(targe: any, methodName: any, paramsIndex: any) { console.log(params); //装饰器传入的值 xxx console.log(targe); // Http { getdata: [Function] } 类的原型对象 console.log(methodName); //getdata 方法名称 console.log(paramsIndex); // 0 //参数索引};}class Http {public url: any;constructor() {}getdata(@logMethod(\"xxx\") params: any) { console.log(params); //123}}var h = new Http();h.getdata(123); 装饰器的执行顺序 执行顺序： 1.属性装饰器 2.方法装饰器 3.方法参数装饰器 4.类装饰器 注意：如果有多个同种装饰器，是从后往前执行 如：有两个参数装饰器限制性后面的参数装饰器，如果有两个属性装饰器，限制性后面定义的属性装饰器 以上就是关于TypeScript中的装饰器相关的知识。","link":"/2019/07/09/TypeScript中的装饰器/"},{"title":"webpack中引入vue","text":"在webpack使用vue，我们会遇到一些打包的问题，这个使用我们要使用打包工具来解决这个问题，以下是具体的一些说明和使用 两者区别 在webpack中，我们需要将所有的包在main.js这个入口文件中导入，在在我们安装vue(npm i vue -D)到本地时，我们在main.js导入这个包 1import Vue from \"vue\" 会爆出以下异常： You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build. 以下的问题解释是：在webpack中使用 import Vue from “vue” 引入的 vue构造函数 功能是不完整的，它只提供了runtime-only 的方式，并没有提供 像网页中使用 script引入的那些功能 解决方式一： 使用：import Vue from &quot;../node_modules/vue/dist/vue&quot;这种引入方式 解决方式二： 配置webpack.config.js文件，新增一个属性:resolve，在里面中还有一个属性:alias，配置如下 123456resolve: { alias: { 'vue$': 'vue/dist/vue.esm.js' }} 这样使用import Vue from &quot;vue&quot;引入也不会报错了 说明 由于webpack是使用Node架构的，所以合法的Node语法都支持，当然，引入包的规则也是一致的 如下： Nodejs中包的查找规则: 找项目根目录中是否有安装 node_modules 的文件夹 在node_modules 中根据包名，找对应的 vue 文件夹 在 vue中，找到一个叫packahe.json的配置文件 在package.json 文件夹中，查找一个 main 属性，这个属性指定了这个包被加载时的入口文件","link":"/2019/06/23/webpack中引入vue/"},{"title":"使用JS对数据表进行批量插入和vscode工具","text":"我们可以在js文件中对数据库进行批量操作,更方便. 使用JS对数据表进行批量插入 使用循环插入数据 123456789var startTime = (new Date()).getTime()var db = connect('User') //连接数据库for (let i = 0; i &lt; 1000; i++) { db.user.insert({ \"num\": 1 }) //往数据表循环添加数据}var runTime = (new Date()).getTime() - startTimeprint(runTime + 'ms') //604ms 使用批量插入 12345678910var startTime = (new Date()).getTime()var db = connect('User') //连接数据库var dataArray = []for (let i = 0; i &lt; 1000; i++) { dataArray.push({ \"num\": 1 })}db.user.insert(dataArray) //批量操作var runTime = (new Date()).getTime() - startTimeprint(runTime + 'ms') //34ms 总结: 使用批量操作对数据表进行数据的插入比循环插入性能快了几十倍 尽量使用批量插入vsode操作mongodb 在vscode中，我们打开了数据库服务之后，可以直接在终端调试工具执行这个mongo 我们在js文件中写好了要插入的数据后，我们可以在终端使用 mongo js文件名,这样自动会执行我们的js代码进行数据库的操作 或者使用mongo后进入数据库界面使用load('./文件名的方式')，但是这个前提是要终端的路径打开在文件的路径中，而且需要use了当前数据表的数据库，可以不要连接数据库直接插入数据或者查找数据","link":"/2019/08/04/使用JS对数据表进行批量插入和vscode工具/"},{"title":"使用Koa脚手架创建Koa项目和EXpress脚手架创建express项目","text":"如果每次项目都是手动进行创建，一个是浪费时间，二是没有必要，使用EXpress脚手架和Koa脚手架快速生成项目 使用Koa脚手架创建Koa项目 Koa脚手架和Vue、Angular、React脚手架一样，都是快速生成项目结构和启动代码的一个工具 使用脚手架 全局安装koa脚手架:cnpm i koa-generator -g 创建项目:koa 项目名 安装依赖：cd项目名-&gt;cnpm i 启动项目:npm start,注意启动项目不再是node app.js 创建参数 创建的时候可以选择模板引擎和其他选项 123456789101112C:\\Users\\Mr zhong&gt;koa -hUsage: koa [options] [dir]Options: -V, --version output the version number -e, --ejs add ejs engine support (defaults to jade) --hbs add handlebars engine support -H, --hogan add hogan.js engine support -c, --css &lt;engine&gt; add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css) --git add .gitignore -f, --force force on non-empty directory -h, --help output usage information 我们创建一个名字为myapp的项目使用ejs模板引擎 1koa -e myapp 使用Express脚手架创建Express项目使用脚手架 全局安装脚手架:npm install express-generator -g 创建的参数 1234567891011121314151617 express -hUsage: express [options] [dir]Options: -h, --help 输出使用方法 --version 输出版本号 -e, --ejs 添加对 ejs 模板引擎的支持 --hbs 添加对 handlebars 模板引擎的支持 --pug 添加对 pug 模板引擎的支持 -H, --hogan 添加对 hogan.js 模板引擎的支持 --no-view 创建不带视图引擎的项目 -v, --view &lt;engine&gt; 添加对视图引擎（view） &lt;engine&gt; 的支持 (ejs|hbs|hjs|jade|pug|twig|vash) （默认是 jade 模板引擎） -c, --css &lt;engine&gt; 添加样式表引擎 &lt;engine&gt; 的支持 (less|stylus|compass|sass) （默认是普通的 css 文件） --git 添加 .gitignore -f, --force 强制在非空目录下创建 比如创建了一个名称为 myapp 的 Express 应用。此应用将在当前目录下的 myapp 目录中创建，并且设置为使用 ejs 模板引擎 1express --view=pug myapp 安装项目依赖：cd myapp,然后cnpm i 启动项目：npm start","link":"/2019/08/12/使用Koa脚手架创建Koa项目和EXpress脚手架创建express项目/"},{"title":"关联多个远程仓库","text":"我们在日常的开发中，由于GitHub是外国的服务器，所以上传速度较慢，但是我们国内也有托管的网站，比如码云 前言 在实际的开发过程中，团队协作开发项目是必不可少的，我们将项目托管到远程仓库上，就是为了解决多人合作开发和代码托管备份的作用，而有时候我们需要将一个项目托管到多个仓库中，现在我们就一起来学习一下如何操作 使用码云 要想使用码云现需要注册 注册成功后在个人中心，配置ssh，因为我们在github中，已经生成了ssh，所以我们直接拿公钥即可 然后在个人中心旁边有个 + 号 新建仓库即可关联github和码云 在git的使用我们已经详细的简述了如何托管到GitHub中，现在我们讲述一下托管到GitHub和码云中 git remote rm origin；先删除已经关联的origin远程仓库 git remote add github git@github.com:ZhongYueHui/vue-001.git 注意：，远程仓库名是github了不是origin了 接着关联码云的仓库 git remote add gitee git@gitee.com:zhongyuehui/vue-001.git 注意：，远程仓库名是gitee了不是origin了 现在我们使用git remote -v就可以查看到远程库的信息了 1234gitee git@gitee.com:zhongyuehui/vue-001.git (fetch)gitee git@gitee.com:zhongyuehui/vue-001.git (push)github git@github.com:ZhongYueHui/vue-001.git (fetch)github git@github.com:ZhongYueHui/vue-001.git (push) 推送到GitHub和码云 推送到GitHub：git push github master 推送到码云:git push gitee master 这样，我们的项目将就分别在git和码云中了","link":"/2019/07/02/关联多个远程仓库/"},{"title":"初识Angular","text":"Angular是web前端三大框架之一，和React、Vue相比，在中大型企业中，更具优势 初识Angular Angular是一款来自谷歌的开源web框架，诞生于2009年，是一款优秀的JS框架，由Misko Hevery等人创建，后被Google收购 根据项目统计angular是现在网上使用量最大的框架 Angular适用的场景 Angular基于Typescript和React、Vue相比，更适合中大型企业级项目环境搭建步骤 需要安装Nodejs，这个是框架开发必备的环境了，就不多说了-&gt;Nodejs官网 由于国内网络问题，尽量使用cnpm淘宝镜像 安装Angular脚手架cnpm i -g @angular/cli 查看是否安装成功ng v 创建angular项目:例如创建以一个名为my-app的项目：ng new my-app,你也可以使用ng new my-app --skip-install跳过npm安装 安装完之后会问你是否需要路由，可以按需选择，然后选择预处理器LESS和SCSS，也可以不选，直接选择CSS,选择后回车 这个时候如果使用ng new my-app会自动安装依赖，我们直接Ctrl+C停止，因为npm安装容易被墙安装失败，我们使用cnpm i即可安装，当然，如果你的电脑安装了yarn也可以直接使用yarn命令进行安装，如果使用ng new my-app --skip-install，则直接使用cnpm i 安装完毕之后cd my-app使用ng serve --open即可打开这个项目 使用cnpm安装： 使用yarn安装: 启动项目 注意：IE版本较低的浏览器不支持，如果默认是IE浏览器可以修改默认浏览器或者黏贴网址到其他浏览器打开补充： 有时候我们经常因为依赖包安装出错导致项目不能运行，这个时候需要删除node_modules，如果直接删除因为目录层级太深，需要好久，在这里我们只需要使用如下步骤即可超快删除 安装cnpm install rimraf -g 使用：cd到你要删除的文件夹运行rimraf 你要删除的文件或者文件夹 当然这个包功能还是很强大的,可以去官网查看其他用途 -&gt; rimraf创建组件 在src下的app创建一个文件夹名为components的news组件ng g componet components/news，如果不指定文件夹，就会创建到app根目录下 使用命令行创建它自动会关联组件，使用的时候只需要在根组件放置对应的标签即可，标签名在组件种的组件名.component.ts中的selector属性值，内容就是组件名.component.html中的内容 找到app根目录下的app.component.html，以标签形式放置selector的属性值即可展示对应组件的内容","link":"/2019/07/22/初识Angular/"},{"title":"webpack配置的一些总结","text":"在配置webpack打包项目时，有些必要的插件安装与配置，才能保证项目完整的被打包，这里总结了一些基础的webpack配置，可以满足基础的打包运行要求 全局安装webpack npm install webpack -g 生成package.json npm init -y 安装webpack-dev-server到本地 npm install webpack-dev-server -D 仍然需要在本地安装webpack作为webpack-dev-server的依赖 npm install webpack -D 配置webpack.config.js文件 创建webpack.config.js文件 配置文件出入口 1234567891011121314151617181920212223//由于webpack是由Nodejs构建的，所以任何的Nodejs语法都支持//引入路径模块var path = require('path')//当以命令形式运行webpack或者webpack-dev-server的时候，工具会发现，我们没用提供要打包的文件入口和出口命令//此时，就会检查项目根目录中的配置文件 webpack.config.js 并读取这个文件，就拿到了导出的这个配置对象，然后根据对象进行打包//向外暴露出这个对象module.exports = { entry: path.join(__dirname, './src/main.js') //入口文件，需要打包的文件 , output: { //出口文件，需要打包到哪里去 path: path.join(__dirname, './dist/bundle.js') //输出路径 , filename: 'bundle.js' }, mode: 'development', //设置mode，在4.0新增 } 配置一些功能：在webpack.config.js中配置 123456 devServer: { //配置webpack-dev-server open: true, //是否打开浏览器 contentBase: 'src', //指定托管的目录 hot: true, //是否启用热更新 port: 6000 //代理的端口}, 在package.json中配置 123\"script\":{\"start:dev\": \"webpack --open --port 3000 --contentBase src --hot\"} 需要将打包好的文件从虚拟内存中传入过来 安装html-webpack-plugin npm install html-webpack-plugin -D 在webpack.config.js中配置这个插件 作用： 在内存中，根据只当的模板页面，生成一份内存中的首页，同时把打包好的bundle.js注入到页面底部 如果需要配置插件，需要在导出的对象中挂载一个 plugins:[] 注意：所有的第三方插件都在 plugins:[]中配置 与entry、output同级1234567plugins: [ new htmlWebpackPlugin({ template: path.join(__dirname, './src/index.html'), //指定模板文件的目录 filename: 'index.html' //设置生成的页面名称 }) ] 配置css-loader、less-loader、sass-loader 在main.js中引入css文件 import ‘./css/style.css’ 安装css-loader插件：npm install css-loader style-loader --save-dev import ‘./css/style.less’ 安装css-loader插件：npm install less-loader less --save-dev import ‘./css/style.sass’ 安装css-loader插件：npm install sass-loader node-sass --save-dev 配置文件 在webpack.config.js配置sass 注意：使用npm命令时安装node-sass可能会报错，无法打包，此时建议切换成cnpm 切换方法 cmd运行nrm ls查看,然后切换nrm use cnpm即可，但是前提应该先在全局中安装nrm 12345678910111213module.exports = { ... module: { rules: [{ test: /\\.scss$/, use: [ \"style-loader\", // creates style nodes from JS strings \"css-loader\", // translates CSS into CommonJS \"sass-loader\" // compiles Sass to CSS, using Node Sass by default ] }] }}; 在webpack.config.js配置css 12345678910module.exports = {module: { rules: [ { test: /\\.css$/i, use: ['style-loader', 'css-loader'], }, ],},}; 在webpack.config.js配置less 12345678910module.exports = {module: { rules: [ { test: /\\.less$/, loader: 'less-loader', // compiles Less to CSS }, ],},}; 配置好基本的webpack.config.js文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//由于webpack是由Nodejs构建的，所以任何的Nodejs语法都支持//引入路径模块var path = require('path')//在内存中，根据只当的模板页面，生成一份内存中的首页，同时把打包好的bundle.js注入到页面底部//如果需要配置插件，需要在导出的对象中挂载一个 plugins:[]const htmlWebpackPlugin = require('html-webpack-plugin')//当以命令形式运行webpack或者webpack-dev-server的时候，工具会发现，我们没用提供要打包的文件入口和出口命令//此时，就会检查项目根目录中的配置文件 webpack.config.js 并读取这个文件，就拿到了导出的这个配置对象，然后根据对象进行打包//向外暴露出这个对象module.exports = { entry: path.join(__dirname, './src/main.js') //入口文件，需要打包的文件 , output: { //出口文件，需要打包到哪里去 path: path.join(__dirname, './dist') //输出路径 , filename: 'bundle.js' }, module: { rules: [{ test: /\\.css$/i, //配置css use: ['style-loader', 'css-loader'], }, { test: /\\.less$/i, //配置less use: ['style-loader', 'css-loader', 'less-loader'] }, { test: /\\.scss$/i, //配置sass use: ['style-loader', 'css-loader', 'sass-loader'] }], }, devServer: { //配置webpack-dev-server open: true, //是否打开浏览器 contentBase: 'src', //指定托管的目录 hot: true, //是否启用热更新 port: 2000 //代理的端口 }, mode: 'development', plugins: [ new htmlWebpackPlugin({ template: path.join(__dirname, './src/index.html'), //指定模板文件的目录 filename: 'index.html' //设置生成的页面名称 }) ]} 注意事项： 在webpack4.0以后，webpack新增了mode属性 打包命令有所变化 webpack 要打包的文件 -o 打包生成存放文件的路径 而且在package.json文件中，需要配置如下代码： 1234\"scripts\": { \"dev\": \"webpack --mode development\", // 开发环境 \"build\": \"webpack --mode production\", // 生产环境 }, 在webpack.config.js中，同样需要配置如下代码：1mode: 'development' // 设置mode 如果需要下载指定版本，输入以下命令： npm i -D webpack@3 // 3： webpack版本3最新","link":"/2019/06/22/webpack配置的一些总结/"},{"title":"初识Koa","text":"官方简介:Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程 初始Koakao的优点 Koa基于最新的Es6Es7语法运行速度相比Express更快，Koa中用了Es7 中的Async 和Await完美的解决了异步开发中的回调问题。，koa2.x开发方式和Express基本相似，开发速度、运行速度比Express更快。 koa 是由 Express 原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。koa不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。 koa的简单使用 安装:cnpm i koa -save 使用: 123456789const Koa = require('koa');const app = new Koa();// responseapp.use(ctx =&gt; { ctx.body = 'Hello Koa';});app.listen(3000); 其实我觉得koa框架就像是express框架的浓缩版本，更轻便简洁，但是学习的时候我觉得应该先学习express，这样的话学习路线不会太陡峭。","link":"/2019/08/09/初识Koa/"},{"title":"启动MongoDB","text":"mongodb是在非关系型数据库中最接近关系型数据库的，关系型数据库能实现的功能MongoDb基本上都可以实现。 启动MongoDB 安装完成后使用mongod启动数据库 连接:mongo连接数据库 连接远程数据库:mongo ip:端口 查询数据库 ：show dbs 定位当前数据库:db 使用数据库(创建数据库):use 数据库名 查询数据表:show collections 向表中插入数据(创建表):db.表名.insert({&quot;name&quot;:&quot;zs&quot;,&quot;age&quot;:12}) 查询数据表的内容:db.数据表.find() 注意： mongodb数据库没有创建表和数据库的指令，你直接当做有就行，没有自己会创建，有就直接使用 数据表使用json格式的字符串","link":"/2019/08/04/启动MongoDB/"},{"title":"在Koa中使用Nodejs原生的方式获取post数据和使用koa-bodyparser中间件获取post数据","text":"在Koa中使用原生的Nodejs获取post数据，和在Express中使用原生的Nodejs获取post数据不一样，因为Koa中的方法是异步的。 在Koa中使用Nodejs原生的方式获取get、post数据 在Koa中使用原生的Nodejs获取post数据，和在Express中使用原生的Nodejs获取post数据不一样，因为Koa中的方法是异步的。 创建获取post数据模块 在根目录下创建common目录，新建postCommon.js 123456789101112131415161718//暴露模块exports.getPostData = ctx =&gt; {//返回一个promise对象，这样就可以在调用的时候 awitreturn new Promise((reslove, reject) =&gt; { try { //获取成功 let data = '' ctx.req.on('data', chunk =&gt; { data += chunk }) ctx.req.on('end', chunk =&gt; { reslove(data) }) } catch (err) { //如果获取失败 reject(err) }})} 在app.js中使用这个模块 12345678910111213141516171819202122const koa = require('koa')const app = new koa()const Router = require('koa-router')const router = new Router()const views = require('koa-views')const common = require('./modules/common')app.use(views('views'), { extension: 'ejs' })router.get('/', async (ctx, next) =&gt; { await ctx.render('index.ejs')})router.post('/doAdd', async ctx =&gt; { //因为在这里是异步的，如果需要使用await，那么调用的函数也需要是异步的，我们使用Promise封装 let data = await common.getPostData(ctx) ctx.body = data})app .use(router.routes()) .use(router.allowedMethods()) .listen(3000, console.log(\"http://localhost:3000\")) 以上已经可以获取到post数据，但是这样过于繁琐，而且数据并没有格式化好，所以我们可以使用第三方的中间件来解决这个问题 使用koa-bodyparser中间件获取表单提交的数据 安装：cnpm i koa-bodyparser --save 引入:const bodyParser=require('koa-bodyparser') 配置：app.use(bodyParser()) 使用: ctx.body =awit ctx.request.body 123456789101112131415161718192021222324const koa = require('koa')const app = new koa()const Router = require('koa-router')const router = new Router()const views = require('koa-views')//1.引入const bodyParser = require('koa-bodyparser')app.use(views('views'), { extension: 'ejs' })//2.配置app.use(bodyParser())router.get('/', async (ctx, next) =&gt; { await ctx.render('index.ejs')})router.post('/doAdd', async ctx =&gt; { //3.使用 ctx.body = await ctx.request.body})app .use(router.routes()) .use(router.allowedMethods()) .listen(3000, console.log(\"http://localhost:3000\")) 这个时候就可以获取post数据了，非常的简单，而且数据已经帮你格式化成了JSON对象，直接使用即可","link":"/2019/08/12/在Koa中使用Nodejs原生的方式获取post数据和使用koa-bodyparser中间件获取post数据/"},{"title":"在koa中使用art-template模板引擎","text":"art-template模板引擎性能接近极限，相对其他的模板引擎性能高出几倍到几十倍，并且可以在浏览器运行使用，强大而方便 在koa中使用art-template模板引擎 可能在浏览器端我们已经使用过这个模板引擎，它不仅可以在浏览器端运行，支持koa、express、webpack等 性能接近极限，是ejs的4倍，pug的2倍，同时支持Nodejs和浏览器端，而且语法上与Angular相似使用art-template模板引擎 安装：cnpm i art-template koa-art-template --save这两个模块，如果你需要在浏览器端或者express、webpack中使用这个模板引擎，可以查看art-template官方文档 配置模板引擎 1234567891011121314151617//引入const Koa = require('koa');const render = require('koa-art-template');const app = new Koa();render(app, { root: path.join(__dirname, 'view'),//模板文件的路径 extname: '.art',//文件的后缀名，可以选择使用html debug: process.env.NODE_ENV !== 'production' //是否开启调试模式});app.use(async function (ctx) { //渲染模板 await ctx.render('user');});app.listen(8080); art-template语法 在这里有原始语法和标准语法，我们先来说一下原始语法，因为原始语法与ejs几乎一样，绑定数据，循环，判断，解析html都是一样的，就引入子模板(公共的模板)有些差别 12345//ejs&lt;%-include public/header.ejs%&gt;//art-template&lt;% include ('public/header.html') %&gt; 接下来我们看一下标准语法的使用方式 首先我们定义好数据如下 12345678910111213141516171819202122232425262728const koa = require('koa')const app = new koa()const path = require('path')const Router = require('koa-router')const router = new Router()const render = require('koa-art-template');render(app, { root: path.join(__dirname, 'views'), extname: '.html', debug: process.env.NODE_ENV !== 'production'});router.get('/', async (ctx, next) =&gt; { let data = { name: 'Mr zhong', age: 20, html: '&lt;h2&gt;我的爱好是：&lt;/h2&gt;', list: ['苹果', '香蕉', '西瓜'] } await ctx.render('index', { data })})app .use(router.routes()) .use(router.allowedMethods()) .listen(3000, console.log(\"http://localhost:3000\")) 数据输出 在index.html输出名字 1我的名字是：{{data.name}} 判断 在index.html判断年龄是否小于20 12345{{if data.age&gt;20}}&lt;p&gt;我的年龄大于20&lt;/p&gt;{{ else }}&lt;p&gt;我的年龄小于等于20&lt;/p&gt;{{/if}} 在这里需要注意的是需要结束标签 原文输出 在index.html中输出html标签的内容 1{{@ data.html}} 循环 在index.html中输出我的爱好 1{{each data.list}}&lt;li&gt;{{$index+1}}、{{$value}} &lt;/li&gt;{{/each}} 子模版 在index.html引入公共的尾部模板 1{{ include './public/foot.html' }} 总结： index.html 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\"&gt;&lt;/head&gt;&lt;body&gt; 我的名字是：{{data.name}} {{if data.age&gt;20}} &lt;p&gt;我的年龄大于20&lt;/p&gt; {{ else }} &lt;p&gt;我的年龄小于等于20&lt;/p&gt; {{/if}} {{@ data.html}} {{each data.list}}&lt;li&gt;{{$index+1}}、{{$value}} &lt;/li&gt;{{/each}} {{ include './public/foot.html' }}&lt;/body&gt;&lt;/html&gt; 打印的页面 12345678我的名字是：Mr zhong我的年龄小于等于20我的爱好是： 1、苹果 2、香蕉 3、西瓜我是尾部","link":"/2019/08/12/在koa中使用art-template模板引擎/"},{"title":"在koa中使用Cookie","text":"在Koa中使用Cookie非常简单，因为它不需要安装第三方的插件，自身就有这个功能 Koa中使用Cookie Cookie的作用我们在express中说到过，这里就不再重复，我们直接来看如何使用Cookie 在Koa中使用Cookie非常简单，因为它不需要安装第三方的插件，自身就有这个功能 Cookie的使用说明 在koa中设置cookie的值 1ctx.cookies.set(name,value,[options]) 获取cookie的值 1let name = ctx.cookies(name) options选项 domain: 域名 name=value：键值对，可以设置要保存的 Key/Value，注意这里的 name 不能和其他属性项的名字 一样 Expires： 过期时间（秒），在设置的某个时间点后该 Cookie 就会失效，如 expires=Wednesday,09-Nov-99 23:12:40 GMT maxAge： 最大失效时间（毫秒），设置在多少后失效 - secure： 当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效 Path： 表示 cookie 影响到的路由，如 path=/。如果路径不能匹配时，浏览器则不发送这个 Cookie httpOnly：是微软对 COOKIE 做的扩展。如果在 COOKIE 中设置了“httpOnly”属性，则通过程序（JS 脚本、applet 等）将无法读取到COOKIE 信息，防止 XSS 攻击产生 singed：表示是否签名cookie, 设为true 会对这个 cookie 签名，这样就需要用 res.signedCookies 而不是 res.cookies 访问它。被篡改的签名 cookie 会被服务器拒绝，并且 cookie 值会重置为它的原始值 overwrite:表示是否覆盖住原来同名的cookie，true表示覆盖，false表示不覆盖 cookie的使用 12345678910111213141516171819202122232425262728const koa = require('koa')const app = new koa()const path = require('path')const Router = require('koa-router')const router = new Router()const render = require('koa-art-template');render(app, { root: path.join(__dirname, 'views'), extname: '.html', debug: process.env.NODE_ENV !== 'production'});router.get('/', async ctx =&gt; { ctx.cookies.set('username', 'Mr zhong', {//设置cookie maxAge: 60 * 1000 * 60//设置过期时间 }) await ctx.render('index')})router.get('/user', async ctx =&gt; { let name = ctx.cookies.get('username') //获取cookie await ctx.render('news', { name }) //传递cookie的值})app .use(router.routes()) .use(router.allowedMethods()) .listen(3000, console.log(\"http://localhost:3000\")) 每次我们进入/的时候都会设置cookie，我们进入/user的时候就可以获取到设置的cookie值，通过显示出来 cookie的参数使用说明 123456789 ctx.cookies.set('username', 'Mr zhong',{//设置cookie maxAge: 60 * 1000 * 60, //设置过期时间 path:'/user', //设置cookie可以访问的页面 domain:'.baidu.com', //设置可以访问的二级域名，一般不做修改，默认就是当前的域名 httpOnly:true //表示只有在服务端才能访问})/* domain: 表示 'a.baidu.com','xxx.baidu.com'都可以访问这个cookie*/ httpOnly说明：如果为true，我们只能在服务器端访问，在客户端使用document.cookie是访问不到cookie的，但是如果为false，在客户端使用document.cookie可以访问到cookie，并且服务端也可以访问 cookie的value说明 在koa中，value是不能直接被设置成汉字的，会报错，可能是开发团队有意为之，但是我们在处理用户信息的时候，难免会使用中文，我们可以对中文进入base64编码 123456789101112131415161718192021222324252627282930313233const koa = require('koa')const app = new koa()const path = require('path')const Router = require('koa-router')const router = new Router()const render = require('koa-art-template');render(app, { root: path.join(__dirname, 'views'), extname: '.html', debug: process.env.NODE_ENV !== 'production'});router.get('/', async ctx =&gt; { //将中文转换成base64 let name = new Buffer('张三').toString('base64') ctx.cookies.set('username', name, {//设置cookie maxAge: 60 * 1000 * 60,//设置过期时间 }) await ctx.render('index')})router.get('/user', async ctx =&gt; { let name = ctx.cookies.get('username') //获取cookie，这个时候usename是base64编码 //将base64转换成中文 let username = new Buffer(name, 'base64').toString() await ctx.render('news', { username }) //传递cookie的值})app .use(router.routes()) .use(router.allowedMethods()) .listen(3000, console.log(\"http://localhost:3000\")) 我们在设置cookie之前转换成base64编码，获取之后转换成中文，传递到页面，这样就可以设置中文了","link":"/2019/08/12/在koa中使用Cookie/"},{"title":"在Express使用ejs模板引擎以及静态文件的托管","text":"ejs模板引擎在Express中有集成渲染的中间件,不需要配置即可使用. 在Express使用ejs模板引擎 在之前我们使用ejs模板需要先安装，再引入，才能使用，但是在express中，安装后就可以直接使用 安装:cnpm i ejs --save-dev 使用express的render渲染页面 12345678910111213const express = require('express')const app = express()const port = 3000//配置模板引擎app.set(\"View engine\", \"ejs\")//使用express的render渲染页面app.get('/', (req, res) =&gt; { //这里使用render表示渲染哪个页面，默认从views中查找 res.render('index.ejs')})app.listen(port, () =&gt; console.log(`Example app listening on port port!`)) 渲染页面并传值 123456789101112131415161718192021const express = require('express')const app = express()const port = 3000//配置模板引擎app.set(\"View engine\", \"ejs\")//使用express的render渲染页面app.get('/', (req, res) =&gt; { //这里使用render表示渲染哪个页面，默认从views中查找 res.render('index.ejs')})//使用express的render渲染页面并传递参数app.get('/news', (req, res) =&gt; { let list = ['number', 'string', 'boolean', 'undefined', 'null', 'object'] res.render('news.ejs', { list: list //可以简写成list })})app.listen(port, () =&gt; console.log(`Example app listening on port port!`)) 获取传递的值news.ejs 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;news&lt;/h2&gt; &lt;% for(let i=0;i&lt;list.length;i++){%&gt; &lt;p&gt;&lt;%=list[i] %&gt;&lt;/p&gt; &lt;% } %&gt;&lt;/body&gt;&lt;/html&gt; 补充： 在渲染页面的时候默认会在views中进行查找，如果需要改变默认视图页面的目录可以使用如下方式 app.set(&quot;views&quot;,__dirname + &quot;/设置的目录名称&quot;) 但是这种方式不被推荐，一般使用默认的目录 在使用ejs模板引擎的时候，如果你想使用html的文件后缀名，可以使用如下配置 123456//引入ejsvar ejs = require('ejs')//配置ejsapp.engine('html', ejs.__express)//配置模板引擎app.set(\"View engine\", \"html\") 但是一般我们不需要去修改 静态文件的托管 如果我们定义了一些页面的样式，样式被其他页面引入，这时候如果直接使用css样式会报错，因为路径不唯一，那么这个时候我们就需要使用静态资源的托管，在express中已经为我们提供了这项功能 1234567891011121314const express = require('express') const app = express() const port = 3000 //配置静态资源文件,第一个参数是使用的文件名，第二个参数的设置静态资源的文件夹 app.use('/public/', express.static('./public')) // http://localhost:3000/public/css/style.css可以使用css文件,其中第一个参数中的这个public可以不写， //通过http://localhost:3000/css/style.cs来使用文件，也可以修改任意名，这个时候就形成了虚拟目录，只要使用的时候带上这个路由名即可 // app.use(express.static('./public')) app.set(\"View engine\", \"ejs\") app.get('/', (req, res) =&gt; { res.render('index.ejs') }) app.listen(port, () =&gt; console.log(`Example app listening on port port!`)) 使用静态文件下的css样式文件,公共样式表哪里引入公共样式就在那里引入样式 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 因为配置了静态web服务 我们只需要使用这个路径就可以使用public下的css文件夹下的文件 --&gt; &lt;link rel=\"stylesheet\" href=\"/public/css/style.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 引入公共样式 --&gt; &lt;%include ./header.ejs %&gt; &lt;h2&gt;你好ejs&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2019/08/04/在Express使用ejs模板引擎以及静态文件的托管/"},{"title":"Vs code中Git工具的使用","text":"在一些开发工具中，集成了许多的功能，在我喜欢的vscode中，就集成了git的一些功能，非常方便我们使用 vscode中的Git工具 当我们在对一些推送到远程的项目进行修改时，我们在VS code中发现修改的内容在侧边会有标记 红色的箭头标识表示这里删除了一些东西 绿色标识表示这里修改了一些东西 蓝色标识标识增加了一些东西 当然，我们要说的并不是只有这些，最主要的是我们修改的文件内容后需要推送到远程，再也不需要git add ''、git commit -m '' ，git push了，我们在侧边栏找到这个工具 在这里工具会显示你修改了几个文件，而在更多这里显示你修改了哪些文件，鼠标指针放在修改的文件可以对文件进行一些操作，比如撤回修改 我们继续往下看，在这里有一个 message这里需要添加的是你提交的描述，和git commit -m '' 这里的一致，添加消息后点击 √就可以保存到暂存区了 如果需要推送到远程，点击推送即可、 注意：如果你关联了多个远程，那么直接点击推送可能会报错，因为它不知道你需要推送到哪一个，所以选择推送到...然后选择即可 这样我们在以后的开发中可以减少一点工作量","link":"/2019/07/02/Vs code中Git工具的使用/"},{"title":"使用Vue脚手架搭建项目","text":"使用vue-cli搭建项目，可以快速生成项目和项目结构。 vue-cli 安装Nodejs环境，这个是必须要的，使用了npm 就标识需要使用 Nodejs 如果需要使用vue-cli 3.x,那么需要卸载1.x,2.x版本安装 安装：npm install -g @vue/cli 查看版本号：vue -V或者vue --version建立项目 cd 到你的项目文件夹 vue create 项目名称 这个时候如果有一些配置信息，选择默认的即可，除非你已经很熟悉每个配置文件的作用，可以手动配置 这个时候项目的基本开发环境已经配置好了 cd 到 项目名称文件夹下 运行：npm run serve 这样他会提供两种方式进入运行的项目中，在浏览器中输入即可进入部署 在项目文件夹下:npm run build 这样会在项目的生成dist目录，这个目录就是你需要发布的文件","link":"/2019/08/04/使用Vue脚手架搭建项目/"},{"title":"Angular中父子组件传值","text":"之前我们已经看过了Angular中的DOM，现在我们来了解一下Angular中的组件之间的传值 Angular中父子组件之间的传值父子组件之间的传值父组件给子组件传值 父组件一般是挂载到app渲染的组件，子组件一般是被父组件使用的组件 我们创建两个组件分别为父组件home和子组件header,将home组件挂载到app根组件中后，我们在home组件中想使用header组件为我们的home组件设置页面的header部分，但是内容是通过home传递过去的，代码如下 12345678910111213//home.tsimport { Component, OnInit } from '@angular/core';@Component({ selector: 'app-home', templateUrl: './home.component.html', styleUrls: ['./home.component.scss']})export class HomeComponent implements OnInit { public title: string = '首页' constructor() {} ngOnInit() { }} 父组件的业务逻辑里面只需要在逻辑中定义一个要传递的数据即可 使用[要传递的属性名]=”要传递的属性值“,就可以将父组件的title传递给header组件 1234//home.html&lt;app-header [title]=\"title\"&gt;&lt;/app-header&gt;&lt;h2&gt;我是home组件&lt;/h2&gt; 这个时候，header组件需要接收一下home组件传过来的值。引入{Input}组件，定义@input()装饰器装饰器后面跟上传递过来的属性名就接收完成了，这个时候，我们就可以在header.html中直接使用了 12345678910111213141516//header.tsimport { Component, OnInit, Input } from '@angular/core';@Component({ selector: 'app-header', templateUrl: './header.component.html', styleUrls: ['./header.component.scss']})export class HeaderComponent implements OnInit { @Input() title: string constructor() { } ngOnInit() { }} 12//header.html&lt;header&gt;{{ title }}&lt;/header&gt; 父组件给子组件传递方法 其实传值和传递方法是一样的，我们在home父组件组件中定义一个run方法 1234//home.tsrun(){ console.log('这是home组件的run方法')} 将方法传递过去 12//home.html&lt;app-header [title]=\"title\" [message]=\"message\" [run]=\"run\"&gt;&lt;/app-header&gt; 注意：传递方法的时候也不需要加()，否则会执行，只需要传递方法名就可以了 在header子组件中接收该方法，并创建一个点击事件调用该方法 12// header.html&lt;button (click)=\"UseRun()\"&gt; 执行父组件的run方法&lt;/button&gt; 123456// header.ts@Input() run: any UseRun() {this.run()} 我们在执行的时候需要使用()表示执行这个方法，因为他传递过来的就是一个函数，这个时候我们点击这个button就可以执行home组件传递过来的方法了。 将整个父组件传递给子组件 如果需要传递的数据太多了，每一个我们都传递过去，一个是太繁琐了，对开发人员不友好，于是有了将整个父组件传递给子组件的功能 其实传递父组件给子组件和普通传值都是一样的，只需要传递一个this即可 12//home.html&lt;app-header [home]=\"this\"&gt;&lt;/app-header&gt; 这样就把父组件整个对象传递过去了 接收也是和以前一样的 123456789101112//header.ts @Input() home: any constructor() { } ngOnInit() { } getParMes() { console.log(this.home.message) } UseRun() { this.home.postSonRun() } 使用这中方式就避免了繁琐的传值。 父组件获取子组件的值(@Viewchild) 在DOM操作中，其实就已经说到了使用@Viewchild获取到子组件的整个DOM实例 我们创建一个news组件作为父组件，一个footer组件作为子组件 子组件的定义属性和方法 12345//footer.tspublic mes: string = '我是footer组件的message'run() {console.log('我是footer组件的run方法');} 定义标识 1234567//news.html&lt;app-footer #footer&gt;&lt;/app-footer&gt;&lt;!-- 定义footer，就像id一样作为标识 --&gt;&lt;br&gt;&lt;hr&gt;&lt;h1&gt;这是news组件&lt;/h1&gt;&lt;button (click)=\"getSon()\"&gt;获取子组件的数据和方法&lt;/button&gt; 调用子组件的方法和属性 12345678910111213141516171819import { Component, OnInit, ViewChild } from '@angular/core'; //引入Viewchild@Component({ selector: 'app-news', templateUrl: './news.component.html', styleUrls: ['./news.component.scss']})export class NewsComponent implements OnInit { @ViewChild('footer', { static: false }) footer: any //定义属性装饰器 constructor() { } ngOnInit() { } getSon() { console.log(this.footer.mes); //打印子组件的mes this.footer.run() //调用父组件的run方法 }} 子组件通过@Output触发父组件的方法并传值 子组件引入Output组件和EvenEmitter事件驱动 1import { Component, OnInit, Output, EventEmitter } from '@angular/core'; 子组件实例化 EventEmitter 1@Output() public getFa = new EventEmitter() 我们在footer子组件中定义一个button注册一个点击事件，向父组件发送数据 12//footer.html&lt;button (click)=\"postFa()\"&gt;给父组件传递方法&lt;/button&gt; 然后定义一下这个事件函数并传值 123456789101112131415161718192021//footer.tsimport { Component, OnInit, Output, EventEmitter } from '@angular/core';@Component({ selector: 'app-footer', templateUrl: './footer.component.html', styleUrls: ['./footer.component.scss']})export class FooterComponent implements OnInit { public mes: string = '我是footer组件的message' @Output() public getFa = new EventEmitter() constructor() { } ngOnInit() { } postFa() { this.getFa.emit(this.mes) // 这个getFa就是实例化对象，所以我们接下来在父组件中需要使用它进行接收值 }} 这里表示传递了子组件中的mes属性给父组件 父组件接收子组件的值 12//news.html&lt;app-footer #footer (getFa)=\"run($event)\"&gt;&lt;/app-footer&gt; 在上面，()内表示的是子组件传递的那个实例化对象，并且需要使用父组件的run方法，而这个$event参数就是子组件传递的那个参数this.mes 父组件接收子组件传递的值 12345 //news.ts run(mes) { console.log('我是父组件的run') console.log(mes) //我是footer组件的message} 其实使用@output调用父组件的方法就是创建一个实例化对象，通过这个实例化对象传递参数，然后在子组件中通过 (实例化对象)=&quot;需要调用的父组件方法名(子组件需要传递的参数)&quot;，然后使用父组件的这个方法逻辑处理这个参数就完成了需求。 非父子组件之间的传值 使用localStorage来实现非父子组件之间的通讯 使用Angular提供的服务功能实现 总结： 使用@Input()–[属性名]=&quot;要传递的值或方法&quot;-可以通过属性传递的方式给子组件传值，可以传递方法、属性、甚至是整个父组件对象,只需要使用@Input() 属性名:数据类型就可以使用传递过来的值 使用@VIewchild–#标识-可以让父组件使用子组件的属性和方法，只需使用 @Viewchild('标识名',{static:false}) 标识名:数据类型,就可以使用(注意：第二个标识名相当于传递过来的标识名的赋值，可以任意起名字，以供后面使用) 使用@Output–[驱动事件实例化对象]=&quot;要使用父组件的方法名(要传递给方法的参数)&quot;可以使用父组件的方法并且传递参数 以上就是Angular中的组件传值的一些知识了。","link":"/2019/07/24/Angular中父子组件传值/"},{"title":"Angular中的生命周期函数","text":"生命周期函数通俗的讲就是组件创建、组件更新、组件销毁的时候会触发一系列的方法，也叫生命周期钩子方法 Angular 中的生命周期函数 当 Angular 使用构造函数新建一个组件或指令后，就会按下面的顺序在特定时刻调用这些生命周期钩子方法。 方法 用途及时机 constructor 构造函数中除了使用简单的值对局部变量进行初始化之外，什么都不应该做。 （非生命周期函数） ngOnChanges() 当 Angular（重新）设置数据绑定输入属性时响应。 该方法接受当前和上一属性值的 SimpleChanges 对象。当被绑定的输入属性的值发生变化时调用，首次调用一定会发生在 ngOnInit() 之前。 ngOnInit() 在 Angular 第一次显示数据绑定和设置指令/组件的输入属性之后，初始化指令/组件。在第一轮 ngOnChanges() 完成之后调用，只调用一次。使用 ngOnInit() 有两个原因：1、在构造函数之后马上执行复杂的初始化逻辑2、在 Angular 设置完输入属性之后，对该组件进行准备. ngDoCheck() 检测，并在发生 Angular 无法或不愿意自己检测的变化时作出反应。在每个 Angular 变更检测周期中调用，ngOnChanges() 和 ngOnInit() 之后。 ngAfterContentInit() 当把内容投影进组件之后调用。第一次 ngDoCheck() 之后调用，只调用一次。 ngAfterContentChecked() 每次完成被投影组件内容的变更检测之后调用。ngAfterContentInit() 和每次 ngDoCheck() 之后调用。 ngAfterViewInit() 初始化完组件视图及其子视图之后调用,第一次 ngAfterContentChecked() 之后调用，只调用一次。 ngAfterViewChecked() 每次做完组件视图和子视图的变更检测之后调用。ngAfterViewInit()和每次 ngAfterContentChecked() 之后调用。 ngOnDestroy() 当 Angular 每次销毁指令/组件之前调用并清扫。在这儿反订阅可观察对象和分离事件处理器，以防内存泄漏。在 Angular 销毁指令/组件之前调用。 - 接口 在生命周期函数中，可以去实现接口，也可以不实现，如果实现了那么就必须按照接口的规范,每个接口都有一个对应的唯一的钩子方法 默认为 ngOnInit 启用了接口 123456789101112import { Component, OnInit } from '@angular/core';@Component({ selector: 'app-name', templateUrl: './name.component.html', styleUrls: ['./name.component.scss']})export class NameComponent implements OnInit { constructor() { } ngOnInit(): void { }} 删除接口 123456789101112 import { Component } from '@angular/core';@Component({ selector: 'app-name', templateUrl: './name.component.html', styleUrls: ['./name.component.scss']})export class NameComponent { constructor() { } ngOnInit(): void { }} 增加接口 12345678910111213 import { Component, OnInit,ngOnChanges } from '@angular/core';@Component({ selector: 'app-name', templateUrl: './name.component.html', styleUrls: ['./name.component.scss']})export class NameComponent implements OnInit,ngOnChanges { constructor() { } ngOnInit(): void { } ngOnChanges(){}} 生命周期函数1234567891011121314151617181920212223242526272829303132333435363738import { Component, OnInit } from '@angular/core';@Component({ selector: 'app-home', templateUrl: './home.component.html', styleUrls: ['./home.component.scss']})export class HomeComponent implements OnInit { public mes: string = '生命周期函数的过程' constructor() { console.log('00构造函数执行了，--除了使用简单的值对局部变量进行初始化之外，什么都不应该做'); } ngOnChanges() { console.log('001-ngOnChanges执行了，当绑定的输入属性发生变化时调用(父子组件传值的时候会触发)'); } ngOnInit() { console.log('002ngOnInit执行了,一般在这里发送请求数据'); } ngDoCheck() { //写一些自定义的操作 console.log('03ngDocheck执行了--检测，并在发生angular无法或不愿意自己检测的变化做出反应'); } ngAfterContentInit() { console.log('004ngAfterContentInit方法执行了，当把内容投影进组件之后调用') } ngAfterContentChecked(): void { console.log('05ngAfterContentChecked执行了--每次完成被投影组件内容的变更检测之后调用'); } ngAfterViewInit(): void { console.log('06ngAfterViewInit执行了，初始化完成组件以及子视图之后调用（DOM操作放在这里）'); } ngAfterViewChecked(): void { console.log('07ngAfterViewChecked执行了-每次做完组件视图的变更检测之后调用'); } ngOnDestroy(): void { console.log('08ngOnDestroy执行了'); }} 如果什么都不做那么它执行的顺序是这样的 如果我们将自己身上的 mes 属性渲染到页面上 12//home.html&lt;h1&gt;{{ mes }}&lt;/h1&gt; 那么生命周期函数执行顺序是这样的 如果我们定义一个函数来改变mes的值，它是这样的 12//home.html&lt;button (click)=\"changeMes()\"&gt;改变mes&lt;/button&gt; 12345//hoem.tschangeMes() {console.log('--------------------')this.mes = '改变了mes'} 如果我们在 app 根组件中为 home 组件定义一个 flag，再定义按钮控制 flag，这样就可以达到卸载挂载组件的效果 1234//app.html&lt;app-home *ngIf=\"flage\"&gt;&lt;/app-home&gt;&lt;button (click)=\"removeCom()\"&gt;卸载组件&lt;/button&gt; 12345//app.tspublic flage: boolean = trueremoveCom() {this.flage = !this.flage} 总结 如果我们创建一个父组件向子组件传值的话，那么它就会执行第一个生命周期函数 如果我们修改了视图上的数据，那么所有Checked()(3、5、7)函数都会执行 如果是请求数据，我们可以在ngOnInit(){}中进行 如果是 DOM 操作，我们可以在ngAfterViewInit()中进行 如果是卸载组件，那么就会执行最后一个生命周期函数ngOnDestroy 以上就是一些关于 Angular 中的生命周期函数的一些知识。","link":"/2019/07/24/Angular中的生命周期函数/"},{"title":"Angular中的Rxjs","text":"这篇文章主要给大家介绍了关于JS异步执行结果获取的3种解决方式，文中通过示例代码介绍的非常详细，对大家的学习或者工作具有一定的参考学习价值 Angular中的Rxjs前言 JS异步执行机制具有非常重要的地位，尤其体现在回调函数和事件等方面。JS异步执行结果获取的3种解决方式 前面两种大家应该非常熟悉了，一个是使用传递一个函数的参数作为结果的返回值进行取值，另外一个是Promise，当然还有那些async,但是这些都是基于Promise封装的回调函数 这种方式在ES6的Promise还没有出来时是主要的解决方式 12345678function foo(callback) {setTimeout(() =&gt; { callback('222')}, 1000);}foo(function (result) { console.log(result);}) Promise 它是ES6里加入的新对象，专门用来解决回调地域的问题，但是ES7经过封装产生了async，更加完美的解决了回调地狱的问题，使用同步的编程方式解决异步 1234567891011121314function foo() { return new Promise((resolve, reject) =&gt; { setTimeout(function() { //这里可以写一些业务逻辑 resolve('1'); // 通过 resolve 参数把成功的结果返回 // reject('error'); // 通过 reject 参数把错误信息返回 }, 2000); })}// 调用foo() .then(result =&gt; console.log(result)) .catch(error =&gt; console.log(error)); Promise取值使用的是 .then() 函数，异常处理用的是 .catch() 函数,但是我们也可以传递两个参数，因为它默认第一个参数是成功的回调，第二个参数是失败的回调 12345678910111213function foo() {return new Promise((resolve, reject) =&gt; { setTimeout(function () { // resolve(1); // 通过 resolve 参数把成功的结果返回 reject('error'); // 通过 reject 参数把错误信息返回 }, 1000); })}// 调用foo().then(result =&gt; console.log(result), error =&gt; console.log(error))// .catch(error =&gt; console.log(error)); Rxjs 今天的话题主要是Rxjs，因为在Angular中使用的就是这个这个东西，超级厉害 首先，需要引入在自己的项目中，如果是浏览器环境可以自己下载js文件，但是Angular中已经集成了，直接可以引入使用 因为一般我们使用它发送ajax请求数据，可能会经常使用，所以我们把他定义到服务中，我这里使用request服务 12345678910111213//request.service.tsimport {Observable} from 'rxjs'getObservablese() {return new Observable(observable =&gt; { setTimeout(() =&gt; { let username = 'kebo' observable.next(username)//返回成功的数据 // observable.error('error')//返回失败的数据 }, 1000)})} 那么既既然是在服务中定义的方法，我们需要使用就要在组件中引入服务，我以创建的home组件为例子 1234567891011121314151617181920import { Component, OnInit } from '@angular/core';import { RequestService } from '../../services/request.service' //引入服务@Component({ selector: 'app-home', templateUrl: './home.component.html', styleUrls: ['./home.component.scss']})export class HomeComponent implements OnInit {constructor(public resquest: RequestService) { } //实例化服务ngOnInit() {this.resquest.getObservablese().subscribe((data) =&gt; { //使用subscribe来获取返回的数据，相当于promise的.then console.log(data);})}} 如果获取失败的话你只传入一个参数那么这个data就是失败的数据，只不过他是一种相当于规范性报错，在浏览器是红色的显示,但是不能在函数中定义了成功和失败两种状态，但是只定义一个参数接收，那么就会报错 如果你传入两个参数，如下代码，那么就会对应显示结果，第一个参数表示成功的，第二个参数表示失败的，而且错误的结果不会飘红 1234567891011121314151617181920212223import { Component, OnInit } from '@angular/core';import { RequestService } from '../../services/request.service'@Component({ selector: 'app-home', templateUrl: './home.component.html', styleUrls: ['./home.component.scss']})export class HomeComponent implements OnInit { constructor(public resquest: RequestService) { } ngOnInit() { this.resquest.getObservablese() .subscribe(data =&gt; { console.log(data); }, error =&gt; { console.log(error); }) }} 通过上面的代码说明，我们感觉这个和promise基本上一样，为什么还要使用Rxjs呢，因为RXjs比Promise厉害的多 Rxjs取消操作(取消订阅) promise创建之后，动作是无法撤回的，但是使用Rxjs却不一样，它在中途可以撤回 我们在service中改变一下定时器的时间 12345678910 //request.service.ts getObservablese() { return new Observable(observable =&gt; { setTimeout(() =&gt; { let username = 'kebo' observable.next(username)//返回成功的数据 //observable.error('data faile') }, 3000) })} 调用 1234567891011121314151617181920212223242526import { Component, OnInit } from '@angular/core';import { RequestService } from '../../services/request.service'@Component({ selector: 'app-home', templateUrl: './home.component.html', styleUrls: ['./home.component.scss']})export class HomeComponent implements OnInit { constructor(public resquest: RequestService) { } ngOnInit() { let un = this.resquest.getObservablese() .subscribe(data =&gt; { console.log(data); }, error =&gt; { console.log(error); }) setTimeout(() =&gt; { un.unsubscribe() //取消订阅 }, 1000) //这个时间要少于service中的时间 }} 注意：调用的时候必须定义一个变量接收一下，然后设置一个定时器，表示1秒后取消订阅，取消操作，但是这个时间一定要小于service发送的时间，不然数据已经获取到了，就无法取消了 Rxjs执行多次 我们使用延时器setTimeout时，表示多少秒后执行这个延时器，且只执行一次，但是如果我们改成定时器，就会执行多次 在Promise中，是不支持执行多次的，但是在Rxjs中却是可以的 1234567891011//service.tsgetObservablese() {let count = 0;return new Observable(observable =&gt; { setInterval(() =&gt; { //将延时器改成定时器 count++ let username = 'kebo' observable.next(`${username}+${count}`)//返回成功的数据 // observable.error('data faile') }, 2000)}) 123456789 //home.html ngOnInit() { this.resquest.getObservablese() .subscribe(data =&gt; { console.log(data); }, error =&gt; { console.log(error); })} 这样就完成了不断的执行了 Rxjs使用工具方法对返回的数据进行处理 注意：angular6以后这些 类似于创建之类的用的API都是从rxjs引入的，类似于map 之类的操作都是从rxjs/operators引入的 比如使用filter对返回的count取偶数 12345678910 getObservablese() { let count = 0; return new Observable&lt;any&gt;(observable =&gt; { setInterval(() =&gt; { //将延时器改成定时器 count++ observable.next(count)//返回成功的数据 // observable.error('data faile') }, 2000) })} 1234567891011121314151617 //home.ts import { filter,map } from 'rxjs/operators' ngOnInit() { let result = this.resquest.getObservablese() .pipe( filter(value =&gt; { if (value % 2 == 0) { return true } }) ) .subscribe(data =&gt; { console.log(data); }, error =&gt; { console.log(error); })} 使用map函数对数据进行综合处理 1234567891011121314 import { map, filter } from 'rxjs/operators' ngOnInit() { let result = this.resquest.getObservablese() .pipe( map(value =&gt; { return value * value }) ) .subscribe(data =&gt; { console.log(data); }, error =&gt; { console.log(error); })} 当然，清楚pipe都知道它是管道的意思，我个人感觉和过滤器差不多，都是对数据进行处理的，那么管道可以有多个，这个也可以有多个，比如我们先把偶数过滤出来，然后让偶数*偶数 1234567891011121314151617181920import { map, filter } from 'rxjs/operators'ngOnInit() {let result = this.resquest.getObservablese() .pipe( filter(value =&gt; { if (value % 2 == 0) { return true } }) map(value =&gt; { return value * value }) ) .subscribe(data =&gt; { console.log(data); }, error =&gt; { console.log(error); })} 这样就完成了这个多个过滤 参考文章 angular6的RXjs新特性 走心干货-angular6新特性简述","link":"/2019/08/04/Angular中的Rxjs/"},{"title":"Express中Cookie的基本使用与Cookie二级域名之间的共享、Cookie的加密","text":"cookie是存储于访问者的计算机中的变量。可以让我们用同一个浏览器访问同一个域名时共享数据 Cookie的基本使用认识cookie cookie是存储于访问者的计算机中的变量。可以让我们用同一个浏览器访问同一个域名时共享数据。 HTTP 是无状态协议。简单地说，当你浏览了一个页面，然后转到同一个网站的另一个页面，服务器无法认识到这是同一个浏览器在访问同一个网站。每一次的访问，都是没有任何 关系的。 Cookie 是一个简单到爆的想法：当访问一个页面的时候，服务器在下行 HTTP 报文中， 命令浏览器存储一个字符串; 浏览器再访问同一个域的时候，将把这个字符串携带到上行 HTTP 请求中。第一次访问一个服务器，不可能携带 cookie。 必须是服务器得到这次请求， 在下行响应报头中，携带 cookie 信息，此后每一次浏览器往这个服务器发出的请求，都会 携带这个 cookie。 Cookie 特点 cookie 保存在浏览器本地 正常设置的 cookie 是不加密的，用户可以自由看到; 用户可以删除 cookie，或者禁用它 cookie 可以被篡改 cookie 可以用于攻击 cookie 存储量很小。未来实际上要被 localStorage 替代，但是后者 IE9 兼容 cookie的用途 用来保存用户登陆状态 用来获取商品浏览信息，进行相似商品的推送 用来保存浏览的历史记录 cookie的使用 安装:cnpm i cookie-parser --save 因为cookie也是一个中间件 12345var express = require('express')var cookieParser = require('cookie-parser') var app = express()app.use(cookieParser()) 实例 1234567891011121314151617181920212223242526const express = require('express')const app = express()var cookie = require('cookie-parser')app.use(cookie())const port = 3000app.get('/', (req, res) =&gt; { //读取cookie的值 console.log(req.cookies); console.log(req.signedCookies) res.send('Hello Nodejs')})app.get('/setcookie', (req, res) =&gt; { //设置cookie /* 参数一:'cookie的名字' 参数二：cookie的值 参数三：cookie的配置信息 */ res.cookie('userinfo', \"zs\", { maxAge: 60000 }) //表示6000毫秒后过期 //这个时候cookie的值时这样的[{userinfo:'zs}]，如果需要设置多个cookie值，那么就需要多次使用res.cookie res.send('设置cookie完成')})app.getapp.listen(port, () =&gt; console.log(`Example app listening on port port!`)) cookie的一些属性说明 domain: 域名 name=value：键值对，可以设置要保存的 Key/Value，注意这里的 name 不能和其他属性项的名字 一样 Expires： 过期时间（秒），在设置的某个时间点后该 Cookie 就会失效，如 expires=Wednesday,09-Nov-99 23:12:40 GMT maxAge： 最大失效时间（毫秒），设置在多少后失效 - secure： 当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效 Path： 表示 cookie 影响到的路由，如 path=/。如果路径不能匹配时，浏览器则不发送这个 Cookie httpOnly：是微软对 COOKIE 做的扩展。如果在 COOKIE 中设置了“httpOnly”属性，则通过程序（JS 脚本、applet 等）将无法读取到COOKIE 信息，防止 XSS 攻击产生 singed：表示是否签名cookie, 设为true 会对这个 cookie 签名，这样就需要用 res.signedCookies 而不是 res.cookies 访问它。被篡改的签名 cookie 会被服务器拒绝，并且 cookie 值会重置为它的原始值 Cookie多个二级域名之间的共享 在一般的网站中，难免会有二级域名，如果需要在二级域名中使用一级域名的Cookie数据，那么就需要在设置cookie的时候加入一些参数 比如我们在hosts文件下添加以下域名解析 12127.0.0.1 www.hello.com127.0.0.1 news.hello.com 这是时候news.hello.com就是二级域名，我们如果需要在二级域名也使用cookie。就需要如下添加domain 123456789101112131415161718192021222324252627const express = require('express')const app = express()var cookie = require('cookie-parser')app.use(cookie())const port = 3000app.get('/', (req, res) =&gt; { //读取cookie的值 console.log(req.cookies); console.log(req.signedCookies) res.send('Hello Nodejs')})app.get('/setcookie', (req, res) =&gt; { //设置cookie /* 参数一:'cookie的名字' 参数二：cookie的值 参数三：cookie的配置信息 */ // -domain表示主域名 设置后我们可以在 xxx.hello.com中使用cookie的值 res.cookie('userinfo', \"zs\", { maxAge: 60000, domain: \".hello.com\" }) //表示60000毫秒后过期 //这个时候cookie的值时这样的[{userinfo:'zs}] res.send('设置cookie完成')})app.getapp.listen(port, () =&gt; console.log(`Example app listening on port port!`)) 设置cookie使用路径 有时候我们并不希望所有的页面都可以访问到cookie那么我们可以设置指定的路由地址才能访问到cookie，使用path 1234567891011121314151617181920212223242526272829303132const express = require('express')const app = express()var cookie = require('cookie-parser')app.use(cookie())const port = 3000app.get('/', (req, res) =&gt; { //读取cookie的值 console.log(req.cookies); console.log(req.signedCookies) res.send('Hello Nodejs')})app.get('/news', (req, res) =&gt; { console.log(req.cookies); res.send('news ')})app.get('/setcookie', (req, res) =&gt; { //设置cookie /* 参数一:'cookie的名字' 参数二：cookie的值 参数三：cookie的配置信息 */ //path表示需要访问cookie的路由，这个时候只有/news才能访问cookie res.cookie('userinfo', \"zs\", { maxAge: 60000, path: '/news' }) //这个时候cookie的值时这样的[{userinfo:'zs}] res.send('设置cookie完成')})app.getapp.listen(port, () =&gt; console.log(`Example app listening on port port!`)) 设置cookie的访问权限 在cookie中添加httpOnly可以使得只能在服务端访问cookie，在js中是不能访问得，增加了安全性 1234567891011121314151617181920212223242526272829303132const express = require('express')const app = express()var cookie = require('cookie-parser')app.use(cookie())const port = 3000app.get('/', (req, res) =&gt; { //读取cookie的值 console.log(req.cookies); console.log(req.signedCookies) res.send('Hello Nodejs')})app.get('/news', (req, res) =&gt; { console.log(req.cookies); res.send('news ')})app.get('/setcookie', (req, res) =&gt; { //设置cookie /* 参数一:'cookie的名字' 参数二：cookie的值 参数三：cookie的配置信息 */ //path表示需要访问cookie的路由，这个时候只有/news才能访问cookie,并且只有在服务端才能使用cookie res.cookie('userinfo', \"zs\", { maxAge: 60000, path: '/news', httpOnly: true }) //这个时候cookie的值时这样的[{userinfo:'zs}] res.send('设置cookie完成')})app.getapp.listen(port, () =&gt; console.log(`Example app listening on port port!`)) cookie的加密 使用singed属性加密，获取加密cookie需要使用res.singedCookie而不是re.cookie，需要配置中间件，不然不能起作用 1234567891011121314151617181920212223242526272829const express = require('express')const app = express()var cookie = require('cookie-parser')app.use(cookie('a12a')) //配置加密，可以是任意字符串const port = 3000app.get('/', (req, res) =&gt; { console.log(req.signedCookies) //读取加密的cookie res.send('Hello Nodejs')})app.get('/news', (req, res) =&gt; { console.log(req.cookies); res.send('news ')})app.get('/setcookie', (req, res) =&gt; { //设置cookie /* 参数一:'cookie的名字' 参数二：cookie的值 参数三：cookie的配置信息 */ res.cookie('userinfo', \"zs\", { maxAge: 60000, signed: true }) //表示需要加密，这个加密是在浏览器显示的时候加密 //这个时候cookie的值时这样的[{userinfo:'zs}] res.send('设置cookie完成')})app.getapp.listen(port, () =&gt; console.log(`Example app listening on port port!`))","link":"/2019/08/04/Cookie的基本使用与Cookie二级域名之间的共享、Cookie的加密/"},{"title":"Koa中ejs模板引擎的使用","text":"Koa中使用ejs模板引擎和Express中除了配置不同其他的一摸一样，如果你直接接触过ejs模板引擎，只需要查看如何配置就可以了 Koa中ejs模板引擎的使用 之前express中，已经说明了ejs模板引擎的语法和使用方式，但是在koa中，配置方式稍微和express有些差别，但是ejs的语法是一样的安装和配置 安装koa-views和ejs 安装：koa-views: cnpmi koa-views –save(-S) 安装:ejs: cnpm i ejs –save(-S) 引入及配置模板引擎中间件 123456789101112131415161718192021222324const koa = require('koa')const app = new koa()const Router = require('koa-router')const router = new Router()//引入koa-viewsconst views = require('koa-views')/* 配置模板引擎中间件 配置方式一： app.use(views('views', { map: { html: 'ejs' } })) 配置方式二: app.use(views('views'), { extension: 'ejs' })*/app.use(views('views'), { extension: 'ejs' })router.get('/', async (ctx, next) =&gt; { ctx.body='首页'}) app .use(router.routes()) .use(router.allowedMethods()) .listen(3000, console.log(\"http://localhost:3000\")) 这样最基本的配置就配置完成了，我们接下来看一下渲染页面和页面传值 1234567891011121314151617181920212223242526272829303132const koa = require('koa')const app = new koa()const Router = require('koa-router')const router = new Router()//引入koa-viewsconst views = require('koa-views')/* 配置模板引擎中间件 配置方式一： app.use(views('views', { map: { html: 'ejs' } })) 配置方式二: app.use(views('views'), { extension: 'ejs' })*/app.use(views('views'), { extension: 'ejs' })router.get('/', async (ctx, next) =&gt; { //渲染模板 await ctx.render('index.ejs') //这里如果没有后缀默认是.html格式，哪种都可以}) .get('/news', async ctx =&gt; { //定义需要传递的数据 let name = \"kobe\" //render参数 //参数一：需要渲染的模板页面，参数二：需要传递的数据 await ctx.render('news.ejs', { name }) })app .use(router.routes()) .use(router.allowedMethods()) .listen(3000, console.log(\"http://localhost:3000\")) 在路由/news中我们传递到news.ejs的值，这样就可以获取了 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的名字是:&lt;%=name%&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 还有一些其他的语法参见在express中我写的ejs模板引擎的使用ejs循环数据 比如我们循环一个数组 123456789101112131415161718192021222324252627282930313233const koa = require('koa')const app = new koa()const Router = require('koa-router')const router = new Router()//引入koa-viewsconst views = require('koa-views')/* 配置模板引擎中间件 配置方式一： app.use(views('views', { map: { html: 'ejs' } })) 配置方式二: app.use(views('views'), { extension: 'ejs' })*/app.use(views('views'), { extension: 'ejs' })router.get('/', async (ctx, next) =&gt; { //渲染模板 await ctx.render('index.ejs') //这里如果没有后缀默认是.html格式，哪种都可以}) .get('/news', async ctx =&gt; { //定义需要传递的数据 let name = \"kobe\" let list = ['苹果', '香蕉', '西瓜'] //render参数 //参数一：需要渲染的模板页面，参数二：需要传递的数据 await ctx.render('news.ejs', { name, list }) })app .use(router.routes()) .use(router.allowedMethods()) .listen(3000, console.log(\"http://localhost:3000\")) 在news.ejs中这样循环 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的名字是:&lt;%=name%&gt;,我喜欢吃:&lt;% for(let i=0;i&lt;list.length;i++){ %&gt; &lt;%=list[i]%&gt; &lt;%}%&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 引入公共模板 引入导航栏或者尾部 在views目录下新建public目录，新建一个文件header.ejs，然后再news.ejs中添加如下代码 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 引入公共的头部 --&gt; &lt;%-include public/header.ejs%&gt; &lt;h1&gt;我的名字是:&lt;%=name%&gt;,我喜欢吃:&lt;% for(let i=0;i&lt;list.length;i++){ %&gt; &lt;%=list[i]%&gt; &lt;%}%&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 使用include就可以引入你需要引入的公共模板了 判断语句 在ejs模板中判断数据显示内容 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 引入公共的头部 --&gt; &lt;%-include public/header.ejs%&gt; &lt;!-- 判断语句 --&gt; &lt;h1&gt;我的名字是:&lt;% if(name=='kobe'){%&gt; &lt;p&gt;科比&lt;/p&gt; &lt;%}else{%&gt; &lt;p&gt;詹姆斯&lt;/p&gt; &lt;%}%&gt; ,我喜欢吃:&lt;% for(let i=0;i&lt;list.length;i++){ %&gt; &lt;%=list[i]%&gt; &lt;%}%&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 这样输出就是我的名字叫科比了，其实这个语法就是和js的一样只不过使用&lt;%%&gt;标签包裹，因为它的底层是使用正则来进行数据的替换的。 ejs模板引擎的标签 123456789&lt;% '脚本' 标签，用于流程控制，无输出。（当作标签使用）&lt;%_ 删除其前面的空格符&lt;%= 输出数据到模板（输出是转义 HTML 标签）（输出你的数据）&lt;%- 输出非转义的数据到模板(当你的内容是一个html时使用这个)&lt;%# 注释标签，不执行、不输出内容(写注释的)&lt;%% 输出字符串 '&lt;%'%&gt; 一般结束标签-%&gt; 删除紧随其后的换行符_%&gt; 将结束标签后面的空格符删除 配置ejs全局数据 如果我们在多个ejs页面中需要使用一个同样的数据，比如说用户的session，那么这个时候我们就可以通过配置全局数据，这样就不需要传递到各个页面去我们也可以获取 123456789101112131415161718192021222324252627282930const koa = require('koa')const app = new koa()const Router = require('koa-router')const router = new Router()const views = require('koa-views')app.use(views('views'), { extension: 'ejs' })//配置公共信息的中间件app.use(async (ctx, next) =&gt; { ctx.state = { username: 'kobe' } await next() //需要继续匹配路由，不然会报错})router.get('/', async (ctx, next) =&gt; { await ctx.render('index.ejs')}) .get('/news', async ctx =&gt; { let name = \"kobe\" let list = ['苹果', '香蕉', '西瓜'] let info = '&lt;h3&gt;我喜欢科比&lt;/h3&gt;' await ctx.render('news.ejs', { name, list, info }) })app .use(router.routes()) .use(router.allowedMethods()) .listen(3000, console.log(\"http://localhost:3000\")) 在这里我们使用配置公共信息的中间件之后，就可以在任意的ejs页面上使用&lt;%=username%&gt;来获取配置的信息了，当然你也可以添加其他的信息，这里只是做一个简单的示范。","link":"/2019/08/10/Koa中ejs模板引擎的使用/"},{"title":"MongoDB数据库与数据表数据的增加、删除和修改","text":"数据库中最常用的就是增加数据和修改数据。 数据库与数据表的删除和修改删除数据表(集合) 使用:db.表名.drop() 1234567891011121314&gt; show dbs //查看数据库Mrzhong 0.000GBadmin 0.000GBconfig 0.000GBlocal 0.000GBtest 0.000GB&gt; use Mrzhong //使用数据库switched to db Mrzhong&gt; show collections //查看数据表textuser&gt; db.text.drop() //删除数据表true&gt; 如果将一个数据库的数据表全部删除了，那么数据库也会自动删除 1234567891011121314151617181920212223&gt; show dbs //查看数据库Mrzhong 0.000GBadmin 0.000GBconfig 0.000GBlocal 0.000GBtest 0.000GB&gt; use Mrzhong //使用数据库switched to db Mrzhong&gt; show collections //查看数据表textuser&gt; db.text.drop() //删除数据表true&gt; show collectionsuser&gt; db.user.drop() //删除数据表true&gt; show dbs //查看数据库admin 0.000GBconfig 0.000GBlocal 0.000GBtest 0.000GB&gt; 删除数据库 删除当前所在的数据库，使用db.数据库名称.dropDatabase() 进行删除 123456789101112131415161718&gt; show dbs //查看数据库MyDb 0.000GBadmin 0.000GBconfig 0.000GBlocal 0.000GBtest 0.000GB&gt; use MyDb //使用数据库switched to db MyDb&gt; dbMyDb&gt; db.dropDatabase() //删除数据库{ \"dropped\" : \"MyDb\", \"ok\" : 1 }&gt; show dbs //再次查看数据库admin 0.000GBconfig 0.000GBlocal 0.000GBtest 0.000GB&gt; 修改数据表的数据 使用db.数据表.update({修改的条件},{$set:{修改的内容}}) update接收的参数update({更新条件},{更新的数据},不符合条件的时候是否增加条件(true),是否更新全部(true)) db.user.update({“sex”:”男”},{$set:{“money”:1000}},false,true) – 表示查找性别为男的数据，新增一个money属性。属性值为1000，如果没有查到数据不增加条件，将满足条件的全部更新 比如：我们将以下数据表的内容的name改成zs666 12345&gt; db.user.update({\"name\":\"zs\"},{$set:{\"name\":\"zs666\"}})WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 })&gt; db.user.find(){ \"_id\" : ObjectId(\"5d42a57e96bf23841b62eabd\"), \"name\" : \"zs666\" }&gt; 这样就修改成功了 替换数据表中的数据 使用db.数据表.update({替换的条件},{替换的内同}) 如将下面的数据表的内容替换成{&quot;name&quot;:'ls',&quot;age&quot;::20} 1234&gt; db.user.update({\"name\":\"zs666\"},{\"name\":\"ls\",age:20})WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 })&gt; db.user.find(){ \"_id\" : ObjectId(\"5d42a57e96bf23841b62eabd\"), \"name\" : \"ls\", \"age\" : 20 } 删除数据表中的数据 使用db.数据表.remove({删除条件}) 比如我们删除name=&quot;ls&quot;的数据 123456&gt; db.user.find() //删除前{ \"_id\" : ObjectId(\"5d42a57e96bf23841b62eabd\"), \"name\" : \"ls\", \"age\" : 20 }&gt; db.user.remove({\"name\":\"ls\"}) //删除WriteResult({ \"nRemoved\" : 1 }) &gt; db.user.find()//删除后，因为每页数据了，所以没有显示&gt; 如果数据表中有多条数据符合删除条件，那么都会被删除，如果我们只想要删除一个可以这样删除db.数据表.update({删除条件},{justOne:true}) 1234567&gt; db.user.find(){ \"_id\" : ObjectId(\"5d42abf696bf23841b62eabe\"), \"name\" : \"ls\", \"age\" : 12 }{ \"_id\" : ObjectId(\"5d42abfa96bf23841b62eabf\"), \"name\" : \"ls\", \"age\" : 20 }&gt; db.user.remove({\"name\":\"ls\"},{justOne:true})WriteResult({ \"nRemoved\" : 1 })&gt; db.user.find(){ \"_id\" : ObjectId(\"5d42abfa96bf23841b62eabf\"), \"name\" : \"ls\", \"age\" : 20 } 数组属性修改 如果数据表中有数据是一个数组形式的，比如一个人的爱好，如果我们需要删除爱好中的最后几个或者前面几个，我们可以使用$pop来删除，它接收1或-1，整数表示从末端删除，负数表示从开头删除 123456&gt; db.user.find() //删除前{ \"_id\" : ObjectId(\"5d42cdf7677cf75a716796c5\"), \"name\" : \"zs\", \"age\" : 20, \"like\" : [ \"游泳\", \"游戏\", \"写代码\", \"打篮球\", \"踢足球\", \"唱歌\" ] }&gt; db.user.update({\"name\":\"zs\"},{$pop:{\"like\":1}})WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 })&gt; db.user.find() //删除后{ \"_id\" : ObjectId(\"5d42cdf7677cf75a716796c5\"), \"name\" : \"zs\", \"age\" : 20, \"like\" : [ \"游泳\", \"游戏\", \"写代码\", \"打篮球\", \"踢足球\" ] } 有时候我们需要修改数组中的某一项替换成别的数据，比如爱好写错了，我们需要修改，这个时候我们就需要使用数组定位修改，比如将爱好中的游戏修改成电脑游戏 123456&gt; db.user.find() //修改前{ \"_id\" : ObjectId(\"5d42cdf7677cf75a716796c5\"), \"name\" : \"zs\", \"age\" : 20, \"like\" : [ \"游泳\", \"游戏\", \"写代码\", \"打篮球\", \"踢足球\" ] }&gt; db.user.update({\"name\":\"zs\"},{$set:{\"like.1\":\"电脑游戏\"}}) //修改like.1表示修改like数组中的第一项，数组是0开始的WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 })&gt; db.user.find() //修改后{ \"_id\" : ObjectId(\"5d42cdf7677cf75a716796c5\"), \"name\" : \"zs\", \"age\" : 20, \"like\" : [ \"游泳\", \"电脑游戏\", \"写代码\", \"打 篮球\", \"踢足球\" ] } 数组查询 有时候我们需要查询数组中含有某些特定值的数据，如果我们想知道有那些人的爱好是画画的,并且只显示它的爱好有哪些 12&gt; db.user.find({\"like\":\"游泳\"},{\"like\":true}){ \"_id\" : ObjectId(\"5d42cdf7677cf75a716796c5\"), \"like\" : [ \"游泳\", \"电脑游戏\", \"写代码\", \"打篮球\", \"踢足球\" ] } 但是有时候我们需要即会游泳、又会写代码的，那么这个时候上面的查询不能满足我们的需求，所以需要使用$all来查询 12&gt; db.user.find({\"like\":{$all:[\"游泳\",\"写代码\"]}}){ \"_id\" : ObjectId(\"5d42cdf7677cf75a716796c5\"), \"name\" : \"zs\", \"age\" : 20, \"like\" : [ \"游泳\", \"电脑游戏\", \"写代码\", \"打 篮球\", \"踢足球\" ], \"money\" : 1000 } 有时候我们需要满足其中一项就可以的，需要使用$in来查询 12&gt; db.user.find({\"like\":{$in:[\"游泳\",\"写代码\"]}})){ \"_id\" : ObjectId(\"5d42cdf7677cf75a716796c5\"), \"name\" : \"zs\", \"age\" : 20, \"like\" : [ \"游泳\", \"电脑游戏\", \"写代码\", \"打 篮球\", \"踢足球\" ], \"money\" : 1000 } 有时候我们需要只有一个爱好的,使用$size来查询 123&gt; db.user.find({\"like\":{$size:1}}){ \"_id\" : ObjectId(\"5d42ddad677cf75a716796c6\"), \"name\" : \"ls\", \"age\" : 20, \"money\" : 1000, \"like\" : [ \"跑步\" ] }&gt; 有时候我们需要只需要爱好中的第一项，使用$slice来进行处理,如果需要查询最后一项，使用负数就可以了 123&gt; db.user.find({\"age\":20},{\"like\":{$slice:1}}){ \"_id\" : ObjectId(\"5d42cdf7677cf75a716796c5\"), \"name\" : \"zs\", \"age\" : 20, \"like\" : [ \"游泳\" ], \"money\" : 1000 }{ \"_id\" : ObjectId(\"5d42ddad677cf75a716796c6\"), \"name\" : \"ls\", \"age\" : 20, \"money\" : 1000, \"like\" : [ \"跑步\" ] } 增加数据表中的数据 有时候我们需要对表中的数据进行增加操作，使用db.数据表.update({增加条件},{$push:{要增加的数据}}) 123456&gt; db.user.find(){ \"_id\" : 1, \"name\" : \"zs\" }&gt; db.user.update({\"name\":\"zs\"},{$push:{\"age\":20,\"sex\":\"男\"}})WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 })&gt; db.user.find() ){ \"_id\" : 1, \"name\" : \"zs\", \"age\" : [ 20 ], \"sex\" : [ \"男\" ] } 判断后增加数据或不增加数据 有时候我们需要对表中的数据进行判断数据，比如爱好，查看爱好中是否有某个选项，有则不添加，没有则添加，那么使用$ne可以来处理这个查询 1234567 &gt; db.user.find() //查看数据 { \"_id\" : ObjectId(\"5d42cdf7677cf75a716796c5\"), \"name\" : \"zs\", \"age\" : 20, \"like\" : [ \"游泳\"] }&gt; db.user.update({\"name\":\"zs\",like:{$ne:\"游戏\"}},{$push:{like:\"游戏\"}}) //查看爱好中是否有游泳，没有则使用$push添加WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 })&gt; db.user.find() \"}})){ \"_id\" : ObjectId(\"5d42cdf7677cf75a716796c5\"), \"name\" : \"zs\", \"age\" : 20, \"like\" : [ \"游泳\", \"游戏\" ] }&gt; 但是上面的方式用来增加数据过于麻烦，我们可以使用$addToSet来做这个功能，上述的$ne修饰符做其他功能较为合适 123456&gt; db.user.find(){ \"_id\" : ObjectId(\"5d42cdf7677cf75a716796c5\"), \"name\" : \"zs\", \"age\" : 20, \"like\" : [ \"游泳\", \"游戏\" ] }&gt; db.user.update({\"name\":\"zs\"},{$addToSet:{\"like\":\"写代码\"}})WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 })&gt; db.user.find() }}){ \"_id\" : ObjectId(\"5d42cdf7677cf75a716796c5\"), \"name\" : \"zs\", \"age\" : 20, \"like\" : [ \"游泳\", \"游戏\", \"写代码\" ] } 自定义数据id 在mongodb中，数据库默认会给给我们添加一个id，而且是不重复的，但是很多时候我们需要使用id进行数据增删改查，所以我们可以自己定义id 123456&gt; db.user.insert({\"_id\":1,\"name\":\"wangmazi\",\"age\":20})WriteResult({ \"nInserted\" : 1 })&gt; db.user.find(){ \"_id\" : ObjectId(\"5d42abfa96bf23841b62eabf\"), \"name\" : \"ls\", \"age\" : 20 }{ \"_id\" : 1, \"name\" : \"wangmazi\", \"age\" : 20 }&gt; 插入id其实和插入其他数据一样，一直插入即可，如果id有重复的话，那么它会报错的","link":"/2019/08/04/MongoDB数据库与数据表数据的增加、删除和修改/"},{"title":"Ionic新增一个tabs和定义公共模块","text":"因为单页面应用在移动端应用的比较广泛，所以tbas选项是必不可少的，我们可以查看如何增加. 新增一个tabs 在ionic中，默认tabs是有三个tab1-3组成，如果我们们需要添加一个的话，那么我们就需要添加一个页面模块，还需要配置一下新增的路由添加模块 ionic g page tab4 删除app.routing.module.ts文件中的tab4路由配置，因为我们不需要配置到这里，而是配置到tabs.routing.module.ts中，然后追加到tab3后面 12345678//删除app.routing.module.ts中,tab4路由配置const routes: Routes = [ { path: '', loadChildren: './tabs/tabs.module#TabsPageModule' }, { path: 'button', loadChildren: './button/button.module#ButtonPageModule' }, //删除这个 { path: 'tab4', loadChildren: './tab4/tab4.module#Tab4PageModule' }]; 在tabs.routing.module.ts追加tab4 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import { NgModule } from '@angular/core';import { RouterModule, Routes } from '@angular/router';import { TabsPage } from './tabs.page';const routes: Routes = [ { path: 'tabs', component: TabsPage, children: [ { path: 'tab1', children: [ { path: '', loadChildren: '../tab1/tab1.module#Tab1PageModule' } ] }, { path: 'tab2', children: [ { path: '', loadChildren: '../tab2/tab2.module#Tab2PageModule' } ] }, { path: 'tab3', children: [ { path: '', loadChildren: '../tab3/tab3.module#Tab3PageModule' } ] }, {//追加tab4 path: 'tab4', children: [ { path: '', loadChildren: '../tab4/tab4.module#Tab4PageModule' } ] }, { path: '', redirectTo: '/tabs/tab1', pathMatch: 'full' } ] }, { path: '', redirectTo: '/tabs/tab1', pathMatch: 'full' }];@NgModule({ imports: [ RouterModule.forChild(routes) ], exports: [RouterModule]})export class TabsPageRoutingModule { } 然后在tabs根组件下的tabs.page.html引入tab4就完成了 12345&lt;!--增加tab4 --&gt;&lt;ion-tab-button tab=\"tab4\"&gt; &lt;ion-icon name=\"settings\"&gt;&lt;/ion-icon&gt; &lt;ion-label&gt;Tab Four&lt;/ion-label&gt;&lt;/ion-tab-button&gt; 新增tab总结： 创建的tab4其实就是一个模块，我们可以在模块创建子组件实现功能，因为ionic一开始就是为Angular量身定制的，所以兼容成程度和适应性比较强，跟为Vue量身定制的Mui、React量身定制的ant design一样，还有Element UI组件库都是很好的UI组件定义公共模块 在ionic中，页面都是由模块组成的，当然，模块下也可以定义组件，但是我们如果由这样的需求，在多个模块中有一样的功能，如果在Angular中是可以实现多个模块共用一个组件的，但是在ionic中，无法在多个模块中使用一个组件，这时候就需要把组件封装成模块，让模块引入模块 创建公共的模块以及组件，这里以轮播图组件为例 1234//创建模块ionic g module module/slide//创建模块的组件ionic g component module/slide 创建好模块和组件后，就需要在slide.module.ts中声明和暴露这个模块 12345678910111213import { NgModule } from '@angular/core';import { CommonModule } from '@angular/common';//引入模块import { SlideComponent } from './slide.component'@NgModule({ declarations: [SlideComponent], //声明这个模块 imports: [ CommonModule ], exports: [SlideComponent] //暴露这个模块})export class SlideModule { } slide模块被导出后，那么我们在需要这个模块的模块中引入就行了。例如在tab1中引入这个模块 1234567891011121314151617181920import { IonicModule } from '@ionic/angular';import { RouterModule } from '@angular/router';import { NgModule } from '@angular/core';import { CommonModule } from '@angular/common';import { FormsModule } from '@angular/forms';import { Tab1Page } from './tab1.page';//引入模块import { SlideModule } from '../module/slide/slide.module'@NgModule({ imports: [ IonicModule, CommonModule, FormsModule, SlideModule,//声明挂载这个模块 RouterModule.forChild([{ path: '', component: Tab1Page }]) ], declarations: [Tab1Page]})export class Tab1PageModule { } 引入和挂载这个组件后，我们就可以在tab1.component.html中使用&lt;app-slide&gt;&lt;/app-slide&gt;这个标签来引用这个组件了，当然，如果需要在其他的模块中使用这个模块，重复上面的引入步骤就可以了引入公共模块的子组件 如果我们在使用公共模块时，还需要使用公共模块下的子组件，那么我们再将子组件暴露出去即可 以list模块为例子，建立一个listInfo的子组件，并在tab4中使用该子组件 创建list模块:ng g module module/list 创建list根组件:ng g component module/list 创建listInfo组件：ng g component module/list/listInfo，这里需要注意的是，使用驼峰命名会装换成成-小写的格式 在list.module.ts中将根组件和子组件导入并暴露，当然你可以根据自己的需要暴露相关的组件 12345678910111213141516import { NgModule } from '@angular/core';import { CommonModule } from '@angular/common';//导入根组件import { ListComponent } from './list.component'//导入子组件import { ListInfoComponent } from './list-info/list-info.component'@NgModule({//声明组件 declarations: [ListInfoComponent, ListComponent], imports: [ CommonModule ],//暴露组件 exports: [ListInfoComponent, ListComponent]})export class ListModule { } 在tab4模块中使用这个list模块 1234567891011121314151617181920212223242526272829//tab4.module.tsimport { NgModule } from '@angular/core';import { CommonModule } from '@angular/common';import { FormsModule } from '@angular/forms';import { Routes, RouterModule } from '@angular/router';import { IonicModule } from '@ionic/angular';import { Tab4Page } from './tab4.page';//引入list模块import { ListModule } from '../module/list/list.module'const routes: Routes = [ { path: '', component: Tab4Page }];@NgModule({ imports: [ CommonModule, FormsModule, IonicModule, ListModule, //挂载list模块 RouterModule.forChild(routes) ], declarations: [Tab4Page]})export class Tab4PageModule { } 在tab4中使用list组件和listInfo子组件 12345678910111213//tab4.page.html&lt;ion-header&gt; &lt;ion-toolbar&gt; &lt;ion-title&gt;tab4&lt;/ion-title&gt; &lt;/ion-toolbar&gt;&lt;/ion-header&gt;&lt;ion-content&gt; &lt;!-- 使用list模块的根组件 --&gt; &lt;app-list&gt;&lt;/app-list&gt; &lt;!-- 使用list模块的子组件 --&gt; &lt;app-list-info&gt;&lt;/app-list-info&gt;&lt;/ion-content&gt; 定义公共模块总结： 如果需要定义一个公共模块，只需要将该模块需要暴露的组件声明一下再暴露出去，然后在需要引入该模块的组件的模块引入这个模块，然后挂载一下这个模块，就可以在自己的模块中使用这个组件了，当然，如果这个模块有子组件，那么要使用这个子组件，只需要暴露这个子组件就行了 自定义公共模块中使用ionic 在自定义的模块中，我们是无法直接使用ionic的组件的，因为我们自定义组件中并没有引入ionic的依赖，如果需要使用，那么需要在自定义模块中的module.ts中引入和挂载一下 123456789101112131415161718192021import { NgModule } from '@angular/core';import { CommonModule } from '@angular/common';//引入ionic依赖import { IonicModule } from '@ionic/angular'//导入根组件import { ListComponent } from './list.component'//导入子组件import { ListInfoComponent } from './list-info/list-info.component'@NgModule({//声明组件 declarations: [ListInfoComponent, ListComponent], imports: [ CommonModule, //挂载ionic依赖 IonicModule ],//暴露组件 exports: [ListInfoComponent, ListComponent]})export class ListModule { } 这样的话那么该模块下所有的组件都可以使用ionic提供的组件了","link":"/2019/08/04/Ionic新增一个tabs和定义公共模块/"},{"title":"Express-session的使用","text":"session是另一种记录客户状态的机制，不同的cookie保存在客户端的浏览器中，而session保存在服务器上 Session的使用什么是session session是另一种记录客户状态的机制，不同的cookie保存在客户端的浏览器中，而session保存在服务器上 session的用途 session运行在服务器端，当客户端第一次访问服务器时，可以将客户的登录信息保存。当客户访问其他页面时，可以判断客户的登录状态，做出提示，相当于登录拦截。 session可以和Redis或者数据库等结合做持久化操作，当服务器挂掉时也不会导致某些客户信息（购物车）丢失。 Session的工作流程 当浏览器访问服务器并发送第一次请求时，服务器端会创建一个session对象，生成一个类似于key,value的键值对，然后将key(cookie)返回到浏览器(客户)端，浏览器下次再访问时，携带key(cookie)，找到对应的session(value)。客户的信息都保存在session中 session的使用 安装:cnpm i express-session -save 引入： 1234567891011121314151617181920212223242526var session = require('express-session')`const express = require('express')const app = express()const port = 3000const session = require('express-session')//配置中间件app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true}))app.get('/', (req, res) =&gt; { if (req.session.username) { //判断session res.send('欢迎你' + req.session.username) //获取session } else { res.send('未登陆') }})app.get('/setsession', (req, res) =&gt; { req.session.username = \"zs\" //设置session res.send('session设置成功')})app.get('/', (req, res) =&gt; res.send('Hello World!'))app.listen(port, () =&gt; console.log(`Example app listening on port port!`)) 与cookie不同的是，cookie获取数据是在request请求的时候获取，设置数据是response响应的时候设置，因为这个时候才可以获得需要设置的数据，比如路由传递的值，但是session都是在请求的时候获取和发送，因为获取也要去服务端中进行key/value的验证，而设置的时候value也是设置到服务端去的，所以需要在请求的时候带上要设置的数据 cookie中只要数据不过期，就可以一直使用，但是session只要你关闭了浏览器，本地数据就没了，需要重新请求 session的一些配置项参数|作用 -|:–:|secret|一个 String 类型的字符串，作为服务器端生成 session 的签名。name | 返回客户端的 key 的名称，默认为 connect.sid,也可以自己设置。resave | 强制保存 session 即使它并没有变化,。默认为 true。建议设置成 false。 don’tsavesessionifunmodifiedsaveUninitialized | 强制将未初始化的session存储。当新建了一个session且未设定属性或值时，它就处于未初始化状态。在设定一个 cookie 前，这对于登陆验证，减轻服务端存储压力，权限控制是有帮助的。（默 认：true）。建议手动添加。cookie | 设置返回到前端 key 的属性，默认值为{path: ‘/’, httpOnly: true,secure:false,maxAge: null}。rolling | 在每次请求时强行设置 cookie，这将重置 cookie 过期时间（默认：false） 相关的使用 12345678910111213141516171819202122232425262728293031323334const express = require('express')const app = express()const port = 3000const session = require('express-session')//配置中间件app.use(session({ secret: 'keyboard cat', //这个字符可以随便写，生命session的前面，但是一般不要些太长 name: 'session_id',//保存到cookie的名称，默认是connect_sid 可以不设置 resave: false, //强制保存session 即使它没变化，一一般我们是设置有变化再保存 saveUninitialized: true, //强制将未初始化的session存储，就是你没有session的时候会帮你建一个名为session_id的cookie cookie: { //这里的cookie设置与express-cookie相似 maxAge: 50000 //过期时间，就算不关闭窗口也会过期 }, rolling: true //只要你在操作，每次操作重置cookie的过期时间}))app.get('/', (req, res) =&gt; { if (req.session.username) { //判断session res.send('欢迎你' + req.session.username) //获取session } else { res.send('未登陆') }})app.get('/login', (req, res) =&gt; { res.send('登陆成功')})app.get('/setsession', (req, res) =&gt; { req.session.username = \"zs\" //设置session res.send('session设置成功')})app.get('/', (req, res) =&gt; res.send('Hello World!'))app.listen(port, () =&gt; console.log(`Example app listening on port port!`)) session的常用方法 注意：设置和获取都是在request请求中的，因为session的value是传递到服务端的，所以需要在请求的时候传递过去，而获取是根据key来向服务端获取value的，也需要在请求的时候验证 设置session 123req.session.(key)=\"(value)\"如：req.sesssion.username=\"zs\" 获取session 123req.session.(key)如：req.session.username 重新设置过期时间 1req.session.cookie.maxAge=60000 session的销毁 如果我们在过期时间内想要退出账号，那么必须销毁session 1234567app.get('/loginOut', (req, res) =&gt; {// req.session.cookie.maxAge = 0 //重新设置cookie的过期时间为0，马上过期 实现账号的退出req.session.destroy((req, res) =&gt; { console.log(\"销毁成功\");})res.send('退出登陆')}) 销毁session的两种方式 设置过期时间为0 使用destory来主动销毁sessionsession的负载均衡 一般的我们都是将session保存到数据库中，请求的时候通过Nginx判断服务器负载信息，比如广州的用户数据在广州的服务器，而且有两台这个时候Nginx做出负载判断后随机向负载教低的服务器传送数据，服务器再去数据库中取数据返回到我们的客户端中，这个就是负载均衡 将session保存到数据库中 首先需要安装两个模块 12cnpm i express-session --save //session模块cnpm i connect-mongo --save //连接数据库的模块 配置并使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const express = require('express')const app = express()const port = 3000const session = require('express-session')//使用connect-mongoconst MongoStore = require('connect-mongo')(session)//配置中间件app.use(session({ secret: 'keyboard cat', //这个字符可以随便写，生命session的前面，但是一般不要些太长 name: 'session_id',//保存到cookie的名称，默认是connect_sid 可以不设置 resave: false, //强制保存session 即使它没变化，一一般我们是设置有变化再保存 saveUninitialized: true, //强制将未初始化的session存储，就是你没有session的时候会帮你建一个名为session_id的cookie cookie: { //这里的cookie设置与express-cookie相似 maxAge: 5000 //过期时间，就算不关闭窗口也会过期 }, rolling: true, //只要你在操作，每次操作重置cookie的过期时间 store: new MongoStore({ //连接数据库 url: 'mongodb://127.0.0.1:27017/study', //数据库的地址 touchAfter: 24 * 3600 //设置时间 })}))app.get('/', (req, res) =&gt; { if (req.session.username) { //判断session res.send('欢迎你' + req.session.username) //获取session } else { res.send('未登陆') }})app.get('/login', (req, res) =&gt; { res.send('登陆成功')})app.get('/setsession', (req, res) =&gt; { req.session.username = \"ls\" //设置session res.send('session设置成功')})app.get('/loginOut', (req, res) =&gt; { // req.session.cookie.maxAge = 0 //重新设置cookie的过期时间为0，马上过期 实现账号的退出 req.session.destroy((req, res) =&gt; { console.log(\"销毁成功\"); }) res.send('退出登陆')})app.get('/', (req, res) =&gt; res.send('Hello World!'))app.listen(port, () =&gt; console.log(`Example app listening on port port!`)) 这个时候我们设置的session就会保存到数据库中去了","link":"/2019/08/04/Express-session的使用/"},{"title":"MongoDB索引","text":"使用索引可以帮助我们更快速的查找到数据，我们现在插入200W条数据到数据库，进行性能的测试。 MongoDB索引插入200w条数据 我们先插入两百万条数据到数据库中 123456789101112131415161718192021222324252627282930313233343536373839404142//生成随机数function getRandomNumber(min, max) { let range = max - min let rand = Math.random() let number = (min + Math.round(rand * range)) return number}// //生成随机用户名function getRandomName(min, max) { //将每个字符串切割成数组 let userNameString = \"0123456789azqwsxedcrfvtgbyhnujmikolp\".split('') let outName = '' //定义名字的长度，随机生成区间的长度,每次循环从userNameString取一个数组出来拼接到outName for (let i = 1; i &lt; getRandomNumber(min, max); i++) { //生成名字，从userNameString数组种，随机从0到userNameString数组的长度中抽取 outName = outName + userNameString[getRandomNumber(0, userNameString.length)] } return outName}//随机生成200w条数据插入到数据库中var stratTime = new Date().getTime()var DataArray = []for (let i = 0; i &lt; 2000000; i++) { DataArray.push({ username: getRandomName(6, 15), regeditemTime: new Date(), randNumber: getRandomNumber(100000, 999999) })}var db = connect('User')db.random.drop() //先删除数据库，防止数据出错db.random.insert(DataArray) //插入数据var endTime = new Date().getTime()var useTime = endTime - stratTimeprint(useTime + \"ms\") 耗时两分多钟，插入完毕后，我们可以使用db.random.stats()查看数据的条数是否正确，其实在中途我有查看大概的插入时间实际上都在是js在做数组插入工作，少数时间插入到数据库中，这跟我们使用批量插入是离不开的 查询数据并遍历 设计查询程序 123456789101112var startTime = new Date().getTime()var db = connect('User')var res = db.random.find({ \"usermae\": \"7xo6cg\" }) //使用db.random.find().skip(50000)查询到的一个名字res.forEach(res =&gt; { printjson(res)});var endTime = new Date().getTime() - startTimeprint('查询结束，耗时\"' + endTime / 1000 + \"s\") //稳定在0.9s 查询结果 1234567&gt; load('./demo05.js')connecting to: mongodb://127.0.0.1:27017/UserImplicit session: session { \"id\" : UUID(\"66dab01f-697b-4529-a2d5-106eecf3dbca\") }MongoDB server version: 4.0.10查询结束，耗时\"0.928strue&gt; 建立索引 使用db.数据表名.ensureIndex({&quot;username&quot;:1})来建立索引，1表示true，就是建立索引的意思 查看索引：db.数据表名.getIndexes()来查看索引，结果是一个数组，里面有一个对象代表有几个索引，一般地我们不会使用_id因为这个是系统随机生成的不好查找 建立索引后查找: 123456789101112var startTime = new Date().getTime()var db = connect('User')var res = db.random.find({ \"username\": \"ux5suyundefinednn\" }) //使用db.random.find().skip(50000)查询到的一个名字res.forEach(res =&gt; { printjson(res)});var endTime = new Date().getTime() - startTimeprint('查询结束，耗时\"' + endTime / 1000 + \"s\") //第一次在0.01s之间，以后有查询缓存稳定在0.005s左右 查询结果: 1234567{ \"_id\" : ObjectId(\"5d43aefc04d831b959b4175c\"), \"username\" : \"ux5suyundefinednn\", \"regeditemTime\" : ISODate(\"2019-08-02T03:31:00.788Z\"), \"randNumber\" : 806500}查询结束，耗时\"0.006s 使用索引的注意事项 数据不超万条时，不需要使用索引。性能的提升并不明显，而大大增加了内存和硬盘的消耗。 查询数据超过表数据量30%时，不要使用索引字段查询。实际证明会比不使用索引更慢，因为它大量检索了索引表和我们原表。 数字索引，要比字符串索引快的多，在百万级甚至千万级数据量面前，使用数字索引是个明确的选择。 把你经常查询的数据做成一个内嵌数据（对象型的数据），然后集体进行索引。 复合索引 两条以上的索引称为符合索引 复合索引查询 12345678910111213var startTime = new Date().getTime()var db = connect('User')var res = db.random.find({ \"username\": \"ux5suyundefinednn\", \"randNumber\": 806500 })res.forEach(res =&gt; { printjson(res)});var endTime = new Date().getTime() - startTimeprint('查询成功,耗时' + endTime / 1000 + \"s\") //第一次耗时0.02s左右,后面查询都为0.01s左右 默认复合查找的索引顺序其实不是以我们写的索引顺序为准，而是以设置索引的顺序，就是db.数据表.getIndexes()查询到的顺序为准的，但是由于数字所以速度比字符串索引要快，我们有时候需要改变其索引的顺序，就需要使用hint关键字进行优先指定索引查找 12345678910111213var startTime = new Date().getTime()var db = connect('User')var res = db.random.find({ \"username\": \"elhm4th\", \"randNumber\": 364231 }).hint({ \"randNumber\": 1 })res.forEach(res =&gt; { printjson(res)});var endTime = new Date().getTime() - startTimeprint('查询成功,耗时' + endTime / 1000 + \"s\") //第一次耗时0.006s左右,后面查询都为0.01s左右 查询结果： 12345678910111213&gt; load('./demo06.js')connecting to: mongodb://127.0.0.1:27017/UserImplicit session: session { \"id\" : UUID(\"07312a2c-b849-4862-a53d-6dd796b5cfaf\") }MongoDB server version: 4.0.10{ \"_id\" : ObjectId(\"5d43af0f04d831b959c2964b\"), \"username\" : \"elhm4th\", \"regeditemTime\" : ISODate(\"2019-08-02T03:31:40.391Z\"), \"randNumber\" : 364231}查询成功,耗时0.005strue&gt; 在这里其实看不出来有太明显的效果，因为200W条数据太少了 删除索引 有时候我们建立索引错了，需要删除，使用db.数据表.dropIndex(&quot;&quot;)这里的内容填的是索引的名字,使用db.数据表.getIndexes()查询你要删除的索引名字name属性的值，不是key属性的值 建立全文索引 在一些很大的数据中，比如一篇长文，这个时候我们如果想查找文章内容的某一部分，这个时候就需要使用全文索引来帮助我们查找 使用db.数据表.ensureIndex({需要建立全文索引的属性:&quot;text&quot;})这里需要跟上text表示建立全文索引，而不是1或true表示建立索引 全文索引查找: $text:表示要在全文索引中查东西。 $search:后边跟查找的内容。1db.info.find({$text:{$search:\"programmer\"}}) 查找多个词: 全文索引是支持多个次查找的，比如我们希望查找数据中有programmer，family，diary，drink的数据（这是或的关系），所以两条数据都会出现。 1db.info.find({$text:{$search:\"programmer family diary drink\"}}) 如果我们这时候希望不查找出来有drink这个单词的记录，我们可以使用“-”减号来取消,就相当于查找的记录要前面的，不要带-的 1dbd .info.find({$text:{$search:\"programmer family diary -drink\"}}) 转义符 全文搜索中是支持转义符的，比如我们想搜索的是两个词（love PlayGame和drink），这时候需要使用\\斜杠来转意。 1db.info.find({$text:{$search:\"\\\"love PlayGame\\\" drink\"}})","link":"/2019/08/04/MongoDB索引/"},{"title":"MongoDB查询数据表","text":"在所有数据库中，查询数据表都是一些操作数据库的最基本操作。 查询数据表条件查询 查询名字为:zs 12&gt; db.user.find({name:'zs'}){ \"_id\" : ObjectId(\"5d4246624239b28d6b556da7\"), \"name\" : \"zs\", \"age\" : 12 } 查询年龄大于20 12&gt; db.user.find({\"age\":{$gt:20}}){ \"_id\" : ObjectId(\"5d424ba1e28fa15fcd55b0d3\"), \"name\" : \"ls\", \"age\" : 25 } 查询年龄小于20 12&gt; db.user.find({\"age\":{$lt:20}}){ \"_id\" : ObjectId(\"5d4246624239b28d6b556da7\"), \"name\" : \"zs\", \"age\" : 12 } 查询年龄大于等于12 123&gt; db.user.find({\"age\":{$gte:12}}){ \"_id\" : ObjectId(\"5d4246624239b28d6b556da7\"), \"name\" : \"zs\", \"age\" : 12 }{ \"_id\" : ObjectId(\"5d424ba1e28fa15fcd55b0d3\"), \"name\" : \"ls\", \"age\" : 25 } 查询年龄小于等于12 12&gt; db.user.find({\"age\":{$lte:12}}){ \"_id\" : ObjectId(\"5d4246624239b28d6b556da7\"), \"name\" : \"zs\", \"age\" : 12 } 如果有名字相同的时候，我们需要多个条件查询 1234&gt; db.user.find(){ \"_id\" : ObjectId(\"5d4246624239b28d6b556da7\"), \"name\" : \"zs\", \"age\" : 12 }{ \"_id\" : ObjectId(\"5d424ba1e28fa15fcd55b0d3\"), \"name\" : \"ls\", \"age\" : 25 }{ \"_id\" : ObjectId(\"5d424e06e28fa15fcd55b0d4\"), \"name\" : \"zs\", \"age\" : 20 } 12&gt; db.user.find({\"name\":\"zs\",\"age\":12}){ \"_id\" : ObjectId(\"5d4246624239b28d6b556da7\"), \"name\" : \"zs\", \"age\" : 12 } 查询年龄大于10岁小于30 12&gt; db.user.find({\"age\":{$gt:20,$lt:30}}){ \"_id\" : ObjectId(\"5d424ba1e28fa15fcd55b0d3\"), \"name\" : \"ls\", \"age\" : 25 } 模糊查询 如下一个数据表，有以下数据 12345&gt; db.text.find(){ \"_id\" : ObjectId(\"5d42504fe28fa15fcd55b0d5\"), \"title\" : \"精品男装、时尚\" }{ \"_id\" : ObjectId(\"5d425077e28fa15fcd55b0d6\"), \"title\" : \"精品女装包包、潮流\" }{ \"_id\" : ObjectId(\"5d425085e28fa15fcd55b0d7\"), \"title\" : \"精品女装皮靴、g复古\" }{ \"_id\" : ObjectId(\"5d4250a7e28fa15fcd55b0d8\"), \"title\" : \"精品男装牛仔裤、韩国风\" } 查询含有男装的数据123&gt; db.text.find({\"title\":/男装/}){ \"_id\" : ObjectId(\"5d42504fe28fa15fcd55b0d5\"), \"title\" : \"精品男装、时尚\" }{ \"_id\" : ObjectId(\"5d4250a7e28fa15fcd55b0d8\"), \"title\" : \"精品男装牛仔裤、韩国风\" } 查询含有女装的数据 123&gt; db.text.find({\"title\":/女装/}){ \"_id\" : ObjectId(\"5d425077e28fa15fcd55b0d6\"), \"title\" : \"精品女装包包、潮流\" }{ \"_id\" : ObjectId(\"5d425085e28fa15fcd55b0d7\"), \"title\" : \"精品女装皮靴、g复古\" } 查询名字以z开头的 123456//数据表&gt; db.user.find(){ \"_id\" : ObjectId(\"5d4246624239b28d6b556da7\"), \"name\" : \"zs\", \"age\" : 12 }{ \"_id\" : ObjectId(\"5d424ba1e28fa15fcd55b0d3\"), \"name\" : \"ls\", \"age\" : 25 }{ \"_id\" : ObjectId(\"5d424e06e28fa15fcd55b0d4\"), \"name\" : \"zs\", \"age\" : 20 }{ \"_id\" : ObjectId(\"5d425231e28fa15fcd55b0d9\"), \"name\" : \"zhong\", \"age\" : 22 } 12345//查询后&gt; db.user.find({\"name\":/^z/}){ \"_id\" : ObjectId(\"5d4246624239b28d6b556da7\"), \"name\" : \"zs\", \"age\" : 12 }{ \"_id\" : ObjectId(\"5d424e06e28fa15fcd55b0d4\"), \"name\" : \"zs\", \"age\" : 20 }{ \"_id\" : ObjectId(\"5d425231e28fa15fcd55b0d9\"), \"name\" : \"zhong\", \"age\" : 22 } 查询名字以g结尾的 12&gt; db.user.find({\"name\":/g$/}){ \"_id\" : ObjectId(\"5d425231e28fa15fcd55b0d9\"), \"name\" : \"zhong\", \"age\" : 22 } 查询指定列 查询name，第一个字段是条件，第二个是指定列 12345&gt; db.user.find({},{name:1}){ \"_id\" : ObjectId(\"5d4246624239b28d6b556da7\"), \"name\" : \"zs\" }{ \"_id\" : ObjectId(\"5d424ba1e28fa15fcd55b0d3\"), \"name\" : \"ls\" }{ \"_id\" : ObjectId(\"5d424e06e28fa15fcd55b0d4\"), \"name\" : \"zs\" }{ \"_id\" : ObjectId(\"5d425231e28fa15fcd55b0d9\"), \"name\" : \"zhong\" } 升序降序 按照年龄升序排序 12345&gt; db.user.find({}).sort({\"age\":1}){ \"_id\" : ObjectId(\"5d4246624239b28d6b556da7\"), \"name\" : \"zs\", \"age\" : 12 }{ \"_id\" : ObjectId(\"5d424e06e28fa15fcd55b0d4\"), \"name\" : \"zs\", \"age\" : 20 }{ \"_id\" : ObjectId(\"5d425231e28fa15fcd55b0d9\"), \"name\" : \"zhong\", \"age\" : 22 }{ \"_id\" : ObjectId(\"5d424ba1e28fa15fcd55b0d3\"), \"name\" : \"ls\", \"age\" : 25 } 按照年龄降序排序 12345&gt; db.user.find({}).sort({\"age\":-1}){ \"_id\" : ObjectId(\"5d424ba1e28fa15fcd55b0d3\"), \"name\" : \"ls\", \"age\" : 25 }{ \"_id\" : ObjectId(\"5d425231e28fa15fcd55b0d9\"), \"name\" : \"zhong\", \"age\" : 22 }{ \"_id\" : ObjectId(\"5d424e06e28fa15fcd55b0d4\"), \"name\" : \"zs\", \"age\" : 20 }{ \"_id\" : ObjectId(\"5d4246624239b28d6b556da7\"), \"name\" : \"zs\", \"age\" : 12 } 查询指定条数数据 查询前2条数据并降序(当然也可以先排序再数据) 123&gt; db.user.find({}).limit(2).sort({\"age\":-1}){ \"_id\" : ObjectId(\"5d424ba1e28fa15fcd55b0d3\"), \"name\" : \"ls\", \"age\" : 25 }{ \"_id\" : ObjectId(\"5d425231e28fa15fcd55b0d9\"), \"name\" : \"zhong\", \"age\" : 22 } 查询第3条以后的数据并升序 123&gt; db.user.find({}).skip(2).sort({\"age\":1}){ \"_id\" : ObjectId(\"5d425231e28fa15fcd55b0d9\"), \"name\" : \"zhong\", \"age\" : 22 }{ \"_id\" : ObjectId(\"5d424ba1e28fa15fcd55b0d3\"), \"name\" : \"ls\", \"age\" : 25 } 分页查询 查询第几页，每页多少条数据，可以用来做分页查询 skip表示的是从第几条数据开始，从0开始计算，limit表示截取几条数据,假设我们以下数据 12345&gt; db.user.find({}){ \"_id\" : ObjectId(\"5d4246624239b28d6b556da7\"), \"name\" : \"zs\", \"age\" : 12 }{ \"_id\" : ObjectId(\"5d424ba1e28fa15fcd55b0d3\"), \"name\" : \"ls\", \"age\" : 25 }{ \"_id\" : ObjectId(\"5d424e06e28fa15fcd55b0d4\"), \"name\" : \"zs\", \"age\" : 20 }{ \"_id\" : ObjectId(\"5d425231e28fa15fcd55b0d9\"), \"name\" : \"zhong\", \"age\" : 22 } 如果我们将这个数据分成两页，那么第一页就是skip(0).limit(2),第二页就是skip(2).limit(2) 1234//第一页&gt; db.user.find({}).skip(0).limit(2){ \"_id\" : ObjectId(\"5d4246624239b28d6b556da7\"), \"name\" : \"zs\", \"age\" : 12 }{ \"_id\" : ObjectId(\"5d424ba1e28fa15fcd55b0d3\"), \"name\" : \"ls\", \"age\" : 25 } 1234//第二页&gt; db.user.find({}).skip(2).limit(2){ \"_id\" : ObjectId(\"5d424e06e28fa15fcd55b0d4\"), \"name\" : \"zs\", \"age\" : 20 }{ \"_id\" : ObjectId(\"5d425231e28fa15fcd55b0d9\"), \"name\" : \"zhong\", \"age\" : 22 } 如果有100条数据，每页10条那么我们可以这样进行切割 skip((页数-1)*10).limit(10) or与查询 当我们查询条件是具体的时候，但是又是多个的时候，以上查询方式并不适合我们，比如：查询age:20或者age:24这种情况，我们就需要使用 $or来查询 查询年龄age=20或者age=22 123&gt; db.user.find({$or:[{\"age\":20},{\"age\":22}]}){ \"_id\" : ObjectId(\"5d424e06e28fa15fcd55b0d4\"), \"name\" : \"zs\", \"age\" : 20 }{ \"_id\" : ObjectId(\"5d425231e28fa15fcd55b0d9\"), \"name\" : \"zhong\", \"age\" : 22 } 查询名字为zs或者age=20 123&gt; db.user.find({$or:[{\"name\":\"zs\"},{\"age\":20}]}){ \"_id\" : ObjectId(\"5d4246624239b28d6b556da7\"), \"name\" : \"zs\", \"age\" : 12 }{ \"_id\" : ObjectId(\"5d424e06e28fa15fcd55b0d4\"), \"name\" : \"zs\", \"age\" : 20 } 使用 $or查询，如果有多个筛选项那么只需要满足一项即可，如果不适用$or表示并且，就需要都满足 查询一条数据 使用findOne()查询时返回第一个数据 12&gt; db.user.findOne(){ \"_id\" : ObjectId(\"5d4246624239b28d6b556da7\"), \"name\" : \"zs\", \"age\" : 12 } 查询结果符合的条数 有时候我们用于统计，比如查询年龄大于20岁的有多少人，但是不需要具体的姓名性别等信息 123&gt; db.user.find({\"age\":{$gt:20}}){ \"_id\" : ObjectId(\"5d424ba1e28fa15fcd55b0d3\"), \"name\" : \"ls\", \"age\" : 25 }{ \"_id\" : ObjectId(\"5d425231e28fa15fcd55b0d9\"), \"name\" : \"zhong\", \"age\" : 22 } 12&gt; db.user.find({\"age\":{$gt:20}}).count()2","link":"/2019/08/04/MongoDB查询数据表/"},{"title":"Nodejs连接并操作MongoDB数据库","text":"使用原生的Ndeojs来操作数据库进行增删改查 Nodejs连接并操作MongoDB数据库 在项目中安装生产依赖项:cnpm i mongodb --save-dev连接并创建数据库 要在 MongoDB 中创建一个数据库，首先我们需要创建一个 MongoClient 对象，然后配置好指定的 URL 和 端口号。如果数据库不存在，MongoDB 将创建数据库并建立连接。 创建连接 12345678var MongoClient = require('mongodb').MongoClient; //调用mongodb模块var url = \"mongodb://localhost:27017/student\"; //使用数据库地址和端口号以及数据库名 MongoClient.connect(url, { useNewUrlParser: true }, function(err, db) { //连数据库 if (err) throw err; //如果错误 抛出错误 console.log(\"数据库已创建!\"); //成功则打印创建成功 db.close(); //关闭数据库}); 创建集合 使用createCollection()方法来创建集合 12345678910111213var MongoClient = require('mongodb').MongoClient; //调用mongodb模块var url = \"mongodb://localhost:27017/\"; //使用数据库地址和端口号以及数据库名MongoClient.connect(url, { useNewUrlParser: true }, function (err, db) { //连数据库，并使用新的url解析器，这是新版的 if (err) throw err; //如果错误 抛出错误 console.log(\"数据库已创建!\"); //成功则打印创建成功 var dbase = db.db('student') //要创建集合的数据库 dbase.createCollection('students', function (err, res) { //创建集合students if (err) throw err console.log(\"集合已创建\"); db.close(); //关闭数据库 })}); 注意：此时因为没有插入数据，所以数据表(集合不会显示) 数据库操作插入一条数据 我们使用insertOne()表示插入一条数据，使用这个方法插入多条会报错 1234567891011121314var MongoClient = require('mongodb').MongoClient; //调用mongodb模块var url = \"mongodb://localhost:27017/\"; //使用数据库地址和端口号以及数据库名MongoClient.connect(url, { useNewUrlParser: true }, function (err, db) { //连数据库 if (err) throw err; //如果错误 抛出错误 console.log(\"数据库已创建!\"); //成功则打印创建成功 var dbase = db.db('student') //要插入信息的数据库 var mydata = { \"name\": \"zhongyuehui\", \"age\": 20, \"hobby\": [\"看电影\", \"听音乐\", \"敲代码\"] } //准备插入的信息 dbase.collection(\"students\").insertOne(mydata, function (err, res) { //插入到student数据库的students表中 if (err) throw err console.log(\"信息插入成功\"); db.close() })}); 这个时候信息插入成功后就可以查看信息了 123 &gt; db.students.find() { \"_id\" : ObjectId(\"5d44f4aac5878526fc1e4dff\"), \"name\" : \"zhongyuehui\", \"age\" : 20, \"hobby\" : [ \"看电影\", \"听音乐\", \"敲代码\" ] } 插入多条数据 我们使用insertMany()插入多条数据的对象 1234567891011121314151617181920var MongoClient = require('mongodb').MongoClient; //调用mongodb模块var url = \"mongodb://localhost:27017/\"; //使用数据库地址和端口号以及数据库名MongoClient.connect(url, { useNewUrlParser: true }, function (err, db) { //连数据库 if (err) throw err; //如果错误 抛出错误 console.log(\"数据库已创建!\"); //成功则打印创建成功 var dbase = db.db('student') //要插入信息的数据库 var mydata = [ { \"name\": \"zhongyuehui\", \"age\": 20, \"hobby\": [\"看电影\", \"听音乐\", \"敲代码\"] }, { \"name\": \"zhangsan\", \"age\": 13, \"hobby\": [\"吃饭\", \"睡觉\", \"打游戏\"] }, { \"name\": \"wangmazi\", \"age\": 15, \"hobby\": [\"打牌\", \"看电视\", \"看书\"] } ] //准备插入的信息 dbase.collection(\"students\").insertMany(mydata, function (err, res) { //插入到student数据库的students表中 if (err) throw err console.log(\"信息插入成功\"); db.close() })}); 插入完成后我们就可以看到这些数据了 12345&gt; db.students.find(){ \"_id\" : ObjectId(\"5d44f690ac657d32f06318cd\"), \"name\" : \"zhongyuehui\", \"age\" : 20, \"hobby\" : [ \"看电影\", \"听音乐\", \"敲代码\" ] }{ \"_id\" : ObjectId(\"5d44f690ac657d32f06318ce\"), \"name\" : \"zhangsan\", \"age\" : 13, \"hobby\" : [ \"吃饭\", \"睡觉\", \"打游戏\" ] }{ \"_id\" : ObjectId(\"5d44f690ac657d32f06318cf\"), \"name\" : \"wangmazi\", \"age\" : 15, \"hobby\" : [ \"打牌\", \"看电视\", \"看书\" ] } 查询数据 使用find()来查找数据，find()可以返回匹配条件的所有数据,如果未指定匹配条件，则返回集合内的所有数据无条件查询 不使用条件查询，查询所有数据 123456789101112var MongoClient = require('mongodb').MongoClient; //调用mongodb模块var url = \"mongodb://localhost:27017/\"; //使用数据库地址和端口号以及数据库名MongoClient.connect(url, { useNewUrlParser: true }, function (err, db) { //连数据库 if (err) throw err; //如果错误 抛出错误 var dbase = db.db('student') //要查询信息的数据库 dbase.collection(\"students\").find({}).toArray(function (err, res) { //从student数据库的students表中查询 if (err) throw err console.log(res); db.close() })}); 条件查询 使用匹配条件查询数据 12345678910111213var MongoClient = require('mongodb').MongoClient; //调用mongodb模块var url = \"mongodb://localhost:27017/\"; //使用数据库地址和端口号以及数据库名MongoClient.connect(url, { useNewUrlParser: true }, function (err, db) { //连数据库 if (err) throw err; //如果错误 抛出错误 var dbase = db.db('student') //要查询信息的数据库 var selectdata = { \"name\": \"zhongyuehui\" } //准备查询的信息 dbase.collection(\"students\").find(selectdata).toArray(function (err, res) { //从student数据库的students表中查询 if (err) throw err console.log(res); db.close() })}); 更新数据更新一条数据 我们也可以对数据库的数据进行修改，使用updateOne()以下实例将name为&quot;zhongyuehui的age改为22 1234567891011121314var MongoClient = require('mongodb').MongoClient; //调用mongodb模块var url = \"mongodb://localhost:27017/\"; //使用数据库地址和端口号以及数据库名MongoClient.connect(url, { useNewUrlParser: true }, function (err, db) { //连数据库 if (err) throw err; //如果错误 抛出错误 var dbase = db.db('student') //要查询信息的数据库 var updateWhere = { \"naem\": \"zhongyuehui\" } //更新的条件 var UpdateData = { $set: { \"age\": 22 } } dbase.collection(\"students\").updateOne(updateWhere, UpdateData, function (err, res) { //从student数据库的students表中查询 if (err) throw err console.log(\"数据更新成功\"); db.close() })}); 更新多条数据 使用updateMany()，将name为zhangsan的age全部更改为30 1234567891011121314var MongoClient = require('mongodb').MongoClient; //调用mongodb模块var url = \"mongodb://localhost:27017/\"; //使用数据库地址和端口号以及数据库名MongoClient.connect(url, { useNewUrlParser: true }, function (err, db) { //连数据库 if (err) throw err; //如果错误 抛出错误 var dbase = db.db('student') //要查询信息的数据库 var updateWhere = { \"name\": \"zhangsan\" } //更新的条件 var UpdateData = { $set: { \"age\": 23 } } dbase.collection(\"students\").updateMany(updateWhere, UpdateData, function (err, res) { //从student数据库的students表中查询 if (err) throw err console.log(\"数据更新成功,更新了\" + res.result.nModified + \"条数据\"); db.close() })}); 由于我插入了两条数据为’zhansan’所以结果如下 12c:\\Users\\Mr zhong\\Desktop\\Nodejs\\Nodejs-MongoDb&gt;node insertdata.js数据更新成功,更新了2条数据 删除数据删除一条数据 使用deleteOne()删除一条数据,我们删除name为&quot;zhangsan&quot;的数据，就算此时有两条数据为zhangsan，他只会删除一条 12345678910111213var MongoClient = require('mongodb').MongoClient; //调用mongodb模块var url = \"mongodb://localhost:27017/\"; //使用数据库地址和端口号以及数据库名MongoClient.connect(url, { useNewUrlParser: true }, function (err, db) { //连数据库 if (err) throw err; //如果错误 抛出错误 var dbase = db.db('student') //要删除信息的数据库 var deleteWhere = { \"name\": \"zhangsan\" } //删除的条件 dbase.collection(\"students\").deleteOne(deleteWhere, function (err, res) { //从student数据库的students表中删除 if (err) throw err console.log(\"数据删除成功\"); db.close() })}); 查看数据表中的信息,只剩下一条name为&quot;zhangsan&quot; 12345&gt; db.students.find(){ \"_id\" : ObjectId(\"5d44f690ac657d32f06318cd\"), \"name\" : \"zhongyuehui\", \"age\" : 20, \"hobby\" : [ \"看电影\", \"听音乐\", \"敲代码\" ] }{ \"_id\" : ObjectId(\"5d44f690ac657d32f06318cf\"), \"name\" : \"wangmazi\", \"age\" : 15, \"hobby\" : [ \"打牌\", \"看电视\", \"看书\" ] }{ \"_id\" : ObjectId(\"5d44fc033805a3045ceb41bb\"), \"name\" : \"zhangsan\", \"age\" : 23 } 删除多条数据 使用deleteMany()删除多条数据,我们删除name为&quot;zhangsan&quot;的数据，我已经准备好两条name为zhangsan的数据 12345678910111213var MongoClient = require('mongodb').MongoClient; //调用mongodb模块var url = \"mongodb://localhost:27017/\"; //使用数据库地址和端口号以及数据库名MongoClient.connect(url, { useNewUrlParser: true }, function (err, db) { //连数据库 if (err) throw err; //如果错误 抛出错误 var dbase = db.db('student') //要删除信息的数据库 var deleteWhere = { \"name\": \"zhangsan\" } //删除的条件 dbase.collection(\"students\").deleteMany(deleteWhere, function (err, res) { //从student数据库的students表中删除 if (err) throw err console.log(\"数据删除成功\"); db.close() })}); 这个时候我们再查看结果，都已经删除完毕 1234&gt; db.students.find(){ \"_id\" : ObjectId(\"5d44f690ac657d32f06318cd\"), \"name\" : \"zhongyuehui\", \"age\" : 20, \"hobby\" : [ \"看电影\", \"听音乐\", \"敲代码\" ] }{ \"_id\" : ObjectId(\"5d44f690ac657d32f06318cf\"), \"name\" : \"wangmazi\", \"age\" : 15, \"hobby\" : [ \"打牌\", \"看电视\", \"看书\" ] } 排序 排序 使用 sort() 方法，该方法接受一个参数，规定是升序(1)还是降序(-1)。 12345678910111213var MongoClient = require('mongodb').MongoClient; //调用mongodb模块 var url = \"mongodb://localhost:27017/\"; //使用数据库地址和端口号以及数据库名 MongoClient.connect(url, { useNewUrlParser: true }, function (err, db) { //连数据库 if (err) throw err; //如果错误 抛出错误 var dbase = db.db('student') var mysort = { \"age\": -1 } //按照age进行降序 dbase.collection(\"students\").find().sort(mysort).toArray(function (err, res) { if (err) throw err console.log(res); db.close() }) }); 注意：一般地我们排序时使用数字进行排序 查询分页 如果要设置指定的返回条数可以使用 limit() 方法，该方法只接受一个参数，指定了返回的条数。 我们需要读取两条数据 123456789101112var MongoClient = require('mongodb').MongoClient; //调用mongodb模块var url = \"mongodb://localhost:27017/\"; //使用数据库地址和端口号以及数据库名MongoClient.connect(url, { useNewUrlParser: true }, function (err, db) { //连数据库 if (err) throw err; //如果错误 抛出错误 var dbase = db.db('student') dbase.collection(\"students\").find().limit(2).toArray(function (err, res) { if (err) throw err console.log(res); db.close() })}); 如果要指定跳过的条数，可以使用skip()方法。比如我们跳过第一条取第二条 123456789101112var MongoClient = require('mongodb').MongoClient; //调用mongodb模块var url = \"mongodb://localhost:27017/\"; //使用数据库地址和端口号以及数据库名MongoClient.connect(url, { useNewUrlParser: true }, function (err, db) { //连数据库 if (err) throw err; //如果错误 抛出错误 var dbase = db.db('student') dbase.collection(\"students\").find().skip(1).limit(1).toArray(function (err, res) { if (err) throw err console.log(res); db.close() })}); 如果我们需要分页查询，让skip((页数-1)*每页的条数).limit(每页的条数)就可以了 连接操作 mongoDB 不是一个关系型数据库，但我们可以使用$lookup来实现左连接,就是相当于MySQL中的多表连接 例如我们新建一个数据表(集合)orders添加以下信息 123[{ _id: 1, product_id: 154, status: 1 }] 再建立一个数据表products添加以下信息 12345[ { _id: 154, name: '笔记本电脑' }, { _id: 155, name: '耳机' }, { _id: 156, name: '台式电脑' }] 实现左连接 12345678910111213141516171819202122var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://127.0.0.1:27017/\";MongoClient.connect(url, { useNewUrlParser: true }, function (err, db) { if (err) throw err; var dbo = db.db(\"student\"); dbo.collection('orders').aggregate([ { $lookup: { from: 'products', // 右集合 localField: 'product_id', // 左集合 join 字段 foreignField: '_id', // 右集合 join 字段 as: 'orderdetails' // 新生成字段（类型array） } } ]).toArray(function (err, res) { if (err) throw err; console.log(JSON.stringify(res)); db.close(); });}); 结果： 1[{\"_id\":1,\"product_id\":154,\"status\":1,\"orderdetails\":[{\"_id\":154,\"name\":\"笔记本电脑\"}]}] 删除集合 使用drop()删除集合 123456789101112var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://127.0.0.1:27017/\";MongoClient.connect(url, { useNewUrlParser: true }, function (err, db) { if (err) throw err; var dbo = db.db(\"User\"); dbo.collection('info').drop(function (err, delOK) { if (err) throw err console.log(delOK); db.close() })});","link":"/2019/08/04/Nodejs连接并操作MongoDB数据库/"},{"title":"Express中的中间件","text":"在Nodejs中的Express框架来说，中间件是一个比较抽象的概念，但是对于理解Nodejs的请求原理是非常重要的，这里简单的介绍了Nodejs中Express框架的中间件原理 中间件的原理 就是相当于水经过一系列处理到用户的过程，中间不能跳过某些步骤或者调换某些步骤 Express中间件 Express是一个自身功能极简，完全是由路由和中间件构成的一个web开发框架，从本质来说，一个Express应用就是在调用各种中间件 中间件(Middlewaew)是一个函数，它可以访问请求对象(request object(req))，响应对象(response(res))和web应用中处理数据请求-响应循环流程中的中间件，一般命名为next的变量 中间件的功能: 执行任何代码 修改请求和响应对象 终结请求-响应循环 调用堆栈中的下一个中间件 如果我的get、post回调函数中，没有next参数，那么匹配上第一个路由，就不会往下匹配，如果需要匹配，就需要写next() Express应用可使用如下几种中间件 应用级中间件 路由中间件应用级中间件 例如：我们需要在匹配路由前打印以下时间 12345678910111213141516171819const express = require('express')const app = express()const port = 3000app.use('/public/', express.static('./public'))app.set(\"View engine\", \"ejs\")/*中间件 应用级中间件 这里表示匹配任何路由*/app.use(function (req, res, next) { console.log(new Date()) //到这里时路由不会继续往下匹配，因为匹配成功了一个，如果需要继续匹配加入next() next()})app.get('/', (req, res) =&gt; {//同样的如果这里匹配成功了还需要继续往下匹配，那么这里也需要使用next() res.render('index.ejs')})app.listen(port, () =&gt; console.log(`Example app listening on port port!`)) 一般地应用级中间件用来做权限的判断，比如没有登陆不能访问某些页面，这个时候我们可以使用这个中间件进行处理 路由中间件 路由中间件用来匹配路由规则，如果匹配成功做出对应的处理，但是如果没有next同样的路由，只能执行一次不会往下执行 12345678910111213141516171819202122const express = require('express')const app = express()const port = 3000app.use('/public/', express.static('./public'))app.set(\"View engine\", \"ejs\")app.get('/', (req, res) =&gt; { res.render('index.ejs')})//路由中间件app.get('/news', (req, res, next) =&gt; { console.log('news'); next()})app.get('/news', (req, res) =&gt; { res.render('news.ejs')})app.listen(port, () =&gt; console.log(`Example app listening on port port!`)) 当然，应用级中间件也可以匹配路由 1234app.use('/news', function (req, res, next) {console.log(\"use --news\");next()}) 配置错误处理中间件 由于中间件和路由执行顺序都是从上往下的，如果以上路由都没有匹配成功，我们将应用级中间件放到最后面，这样前面的路由没有匹配成功就会进入这个中间件处理 12345678910111213141516171819202122const express = require('express')const app = express()const port = 3000app.use('/public/', express.static('./public'))app.set(\"View engine\", \"ejs\")app.get('/', (req, res) =&gt; { res.render('index.ejs')})app.get('/news', (req, res) =&gt; { res.render('news.ejs')})//配置错误处理中间件app.use(function (req, res) { //status表示改变状态。200为请求成功，304为缓存，404为请求失败 res.status(404).send('Not Found 404') //当然，在这里也可以使用render一个错误页面})app.listen(port, () =&gt; console.log(`Example app listening on port port!`)) 这个时候，我们除了请求/和/news，其他的路由都会进入404，因为前面无法匹配 内置中间件 之前学习的app.use(express.static('/public'))就是内置的一个中间件，用来托管静态公共资源的，因为我们使用app.use('/static',express.static('/public'))用过/static/也能获取到public里面的资源 使用body-parser第三方中间件 因为express并没有提供post的方式，所以我们需要借助于第三方的中间件来进行post操作 最简单的使用方式，将通用JSON和URL编码的解析器添加为顶级中间件，它将解析所有传入请求的主体。这是最简单的设置。 123456789101112131415var express = require('express')var bodyParser = require('body-parser') var app = express() // parse application/x-www-form-urlencodedapp.use(bodyParser.urlencoded({ extended: false })) // parse application/jsonapp.use(bodyParser.json())app.use(function (req, res) { res.setHeader('Content-Type', 'text/plain') res.write('you posted:\\n') res.end(JSON.stringify(req.body, null, 2))}) 将如body解析器专门添加到需要它们的路由中。通常，这是在Express中使用body-parser的最佳方法。 1234567891011121314151617181920var express = require('express')var bodyParser = require('body-parser') var app = express() // create application/json parservar jsonParser = bodyParser.json() // create application/x-www-form-urlencoded parservar urlencodedParser = bodyParser.urlencoded({ extended: false }) // POST /login gets urlencoded bodiesapp.post('/login', urlencodedParser, function (req, res) { res.send('welcome, ' + req.body.username)}) // POST /api/users gets JSON bodiesapp.post('/api/users', jsonParser, function (req, res) { // create user in req.body}) 所有解析器都接受一个类型选项，允许您更改中间件将解析的Content-Type 12345678910111213var express = require('express')var bodyParser = require('body-parser') var app = express() // parse various different custom JSON types as JSONapp.use(bodyParser.json({ type: 'application/*+json' })) // parse some custom thing into a Bufferapp.use(bodyParser.raw({ type: 'application/vnd.custom-type' })) // parse an HTML body into a stringapp.use(bodyParser.text({ type: 'text/html' })) 使用body-parser中间件处理表单post请求，并使用req.body获取传递的值 1234567891011121314151617181920212223242526272829303132333435363738394041const express = require('express')//引入body-parserconst bodyParser = require('body-parser')const app = express()//配置body-parserapp.use(bodyParser.urlencoded({ extended: false }))// parse application/jsonapp.use(bodyParser.json())const port = 3000app.use('/public/', express.static('./public'))//配置ejs模板app.set(\"View engine\", \"ejs\")app.get('/', (req, res) =&gt; { res.render('index.ejs')})app.get('/news', (req, res) =&gt; { res.render('news.ejs')})//配置表单数据路由app.get('/login', (req, res) =&gt; { res.render('login.ejs')})//配置表单提交路由app.post('/login', (req, res) =&gt; { res.send(req.body) //使用req获取请求的数据，就是表单提交的数据})//配置错误处理中间件app.use(function (req, res) { //status表示改变状态。200为请求成功，304为缓存，404为请求失败 res.status(404).send('Not Found 404') //当然，在这里也可以使用render一个错误页面})app.listen(port, () =&gt; console.log(`Example app listening on port port!`)) login.ejs页面 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"\" method=\"post\"&gt; &lt;label for=\"username\"&gt; 用户名: &lt;input type=\"text\" name=\"username\" id=\"username\"&gt; &lt;/label&gt;&lt;br&gt;&lt;br&gt; &lt;label for=\"password\"&gt; 密 码: &lt;input type=\"password\" name=\"password\" id=\"password\"&gt; &lt;/label&gt;&lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2019/08/04/express中的中间件/"},{"title":"Redux的一些小技巧","text":"Redux的一些小技巧，可以帮助我们更好的上手Redux. Redux的一些小技巧action中的type抽离 在redux中，我们需要操作store的话，都需要使用action帮助我们进行操作，但是action如果很多的话，type属性也会增多，我们在实践中发现，如果你的方法中设置的type属性和reducer中的type时不一致时，例如: 12345678 //TodoLIst.jsx deleteItem(index) { const action = { type: \"deleteaItem\", //如果这里多写少写一个字母 index }; store.dispatch(action);} 1234567reducer.jsif (action.type === 'deleteItem') { const newState = JSON.parse(JSON.stringify(state)) //根据传递的下标实现删除对应的数组 newState.list.splice(action.index, 1) return newState} 这种错误不会报错，但是你的代码就是执行不了，控制台也一切正常，这个时候你可能会花费很多时间在排错，这就降低了效率，所以我们将action的type单独抽离出一个actionTypoes.js文件，用来保存这些属性名 1234//actionTypoes.jsexport const CHANGE_INPUT = \"changeInput\"export const ADD_ITEM = \"addItem\"export const DELETE_ITEM = \"deleteItem\" 然后在需要使用的地方导入这个文件按需引入一下就可以了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import React, { Component } from \"react\";import { Input, List, Button } from \"antd\";//引入storeimport store from \"../store/index\";//引入actionTypeimport { ADD_ITEM, CHANGE_INPUT, DELETE_ITEM } from \"../store/actionTypes\";class TodoList extends Component { constructor(props) { super(props); //使用getstore()方法可以获取store的数据，就是存到store的数据 this.state = store.getState(); this.changeValue = this.changeValue.bind(this); this.storeChange = this.storeChange.bind(this); //订阅state，调用storeChange这个方法 store.subscribe(this.storeChange); this.addList = this.addList.bind(this); } render() { return ( &lt;div style={{ width: 500, margin: 20 }}&gt; &lt;div&gt; &lt;Input type=\"primary\" style={{ width: 200 }} placeholder={this.state.inputValue} value={this.state.inputValue} onChange={this.changeValue} /&gt; &lt;Button onClick={this.addList}&gt;增加&lt;/Button&gt; &lt;/div&gt; &lt;div style={{ width: 200, marginTop: 20 }}&gt; &lt;List //使用store的数据进行渲染 dataSource={this.state.list} bordered renderItem={(item, index) =&gt; ( //因为在这里使用()的方式会执行这个函数，所以我们传递参数时可以使用bind，因为bind可以传递参数 // &lt;List.Item onClick={this.deleteItem.bind(this, index)}&gt; //也可以使用这种箭头函数的方式 &lt;List.Item onClick={() =&gt; this.deleteItem(index)}&gt; {item} &lt;/List.Item&gt; )} /&gt; &lt;/div&gt; &lt;/div&gt; ); } changeValue(e) { const action = { //修改store需要使用action type: CHANGE_INPUT, value: e.target.value }; store.dispatch(action); //使用dispatch方法将action传递过去store就可以接收到值了,store接收到得值会直接发送到reducer中 } storeChange() { //重新设置state为最新的store this.setState(store.getState()); } //点击增加按钮，增加数据到列表中 addList() { const action = { type: ADD_ITEM }; store.dispatch(action); } //点击列表项进行删除 deleteItem(index) { const action = { type: DELETE_ITEM, index }; store.dispatch(action); }}export default TodoList; reducer.js 123456789101112131415161718192021222324252627282930313233343536373839import { ADD_ITEM, CHANGE_INPUT, DELETE_ITEM } from \"./actionTypes\";const defaultValue = { inputValue: 'Writing Something', list: [\"今天的心情真好\", \"代码问题解决了\", \"以后要多重启\"]}export default (state = defaultValue, action) =&gt; { //此时已经可以接收到TodoList中发送得值，那么我们就需要处理一些发送过来的数据 //注意:reducer不能直接state中的值，只能通过action来生成新的值，然后返回，store自己会监听值发生改变而变化 // console.log(state, action);//如果是action的type是changInput，做这步操作if (action.type === CHANGE_INPUT) { //深度克隆原数据 const newState = JSON.parse(JSON.stringify(state)) //修改inputValue newState.inputValue = action.value console.log(newState); //返回新的state return newState}//如果是action的type是addItem，做这步操作if (action.type === ADD_ITEM) { //深度克隆原数据 const newState = JSON.parse(JSON.stringify(state)) newState.list.push(newState.inputValue) //push完成后将输入框清空,因为在上面的时候store已经被订阅了 newState.inputValue = '' return newState}if (action.type === DELETE_ITEM) { const newState = JSON.parse(JSON.stringify(state)) //根据传递的下标实现删除对应的数组 newState.list.splice(action.index, 1) return newState}return state} 这样，如果你的属性名出现了问题，直接会告诉你哪行错误，快速定位，节约时间，而且如果你使用复制属性名的话一般不会出错 action数据抽离 在上面的代码中，我们可以看到每一个方法的action都写在Todolist中，这样如果太多的话不利于管理，所以我们需要将这个抽离出去，在store新建一个文件actionCreators.js 12345678910111213//actionCreators.jsimport { ADD_ITEM, CHANGE_INPUT, DELETE_ITEM } from './actionTypes'export const changeInput = (value) =&gt; ({ type: CHANGE_INPUT, value})export const addItem = () =&gt; ({ type: ADD_ITEM,})export const deleteItem = (index) =&gt; ({ type: DELETE_ITEM, index}) 这样我们就实现了action的抽离，只需要调用引用actionCreators暴露出来的方法就行，而且不需要引用actionTypes.js了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//TodoList.jsximport React, { Component } from \"react\";import { Input, List, Button } from \"antd\";//引入storeimport store from \"../store/index\";//引入actionCreatros.jsimport { changeInput, deleteItem, addItem } from \"../store/actionCreatros\";class TodoList extends Component { constructor(props) { super(props); //使用getstore()方法可以获取store的数据，就是存到store的数据 this.state = store.getState(); this.changeValue = this.changeValue.bind(this); this.storeChange = this.storeChange.bind(this); //订阅state，调用storeChange这个方法 store.subscribe(this.storeChange); this.addList = this.addList.bind(this); } render() { return ( &lt;div style={{ width: 500, margin: 20 }}&gt; &lt;div&gt; &lt;Input type=\"primary\" style={{ width: 200 }} placeholder={this.state.inputValue} value={this.state.inputValue} onChange={this.changeValue} /&gt; &lt;Button onClick={this.addList}&gt;增加&lt;/Button&gt; &lt;/div&gt; &lt;div style={{ width: 200, marginTop: 20 }}&gt; &lt;List //使用store的数据进行渲染 dataSource={this.state.list} bordered renderItem={(item, index) =&gt; ( //因为在这里使用()的方式会执行这个函数，所以我们传递参数时可以使用bind，因为bind可以传递参数 // &lt;List.Item onClick={this.deleteItem.bind(this, index)}&gt; //也可以使用这种箭头函数的方式 &lt;List.Item onClick={() =&gt; this.deleteItem(index)}&gt; {item} &lt;/List.Item&gt; )} /&gt; &lt;/div&gt; &lt;/div&gt; ); } storeChange() { //重新设置state为最新的store this.setState(store.getState()); } changeValue(e) { const action = changeInput(e.target.value); store.dispatch(action); //使用dispatch方法将action传递过去store就可以接收到值了,store接收到得值会直接发送到reducer中 } //点击增加按钮，增加数据到列表中 addList() { const action = addItem(); store.dispatch(action); } //点击列表项进行删除 deleteItem(index) { const action = deleteItem(index); store.dispatch(action); }}export default TodoList; 其实就相当于一个返回了一个函数 1234567891011const deleteItem = (index) =&gt; ({type: DELETE_ITEM,index})----&gt;const deleteItem= function(index){ return{ type: DELETE_ITEM, index }} 我们在使用的时候就是调用这个函数，然后它会返回这些数据，这是ES6箭头函数的用法 1234567891011121314151617//ES6const test=(index)=&gt;(index)//ES5test=function test(index){ return index}//当然一个参数可以省略()，默认会返回，但是如果第一个参数是一个对象的话，就不能省略，因为它不知道你是传递参数还写代码//如果不写()const test = ()=&gt; {name:'zs',age:12}//根本没有返回值，如果要返回对象需要加()表示传递的参数是一个对象function test(index){ name:'zs',age:12}","link":"/2019/08/04/Redux的一些小技巧/"},{"title":"git的使用","text":"git是什么？Git(读音为/gɪt/。)是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理 前言 我们在平时的项目开发中，难免会用到一些托管工具来托管自己的代码，这样可以更好的和别人和分享自己项目和合作开发项目，这里就简单介绍一下git的使用。 git的使用Git基本操作 上传本地文件(工作区)到暂存区 git status先初始化项目(状态)，检查是否在工作区域还是暂存区 git add 文件名将文件上传到暂存区 将暂存区的文件上传到git仓库中 git status初始化暂存区的项目，查看是否含有相同的内容 git commit -m &quot;提交的描述&quot;，项目的说明 git status 查看文件状态 注意：使用 git commit -m '' 是一次性将文件放到分支，使用git add是将文件添加到暂存区(Stage), git是版本控制工具，并不是文件控制工具，我们只有使用git add添加到暂存区的文件，再使用git commit -m ''才能将文件提交到分支，如果你修改了文件直接提交到分支，这个是不能修改的，不信你可以使用git diff HEAD -- '文件名'查看工作区和版面本库中最新版本的区别 ，没有使用git add '' 的文件内容没有并没有添加到版本库(commit)中 基本流程 基本流程图 基本设置 设置用户名:git config --global user.name 'GitHub的用户名' 设置用户名的邮箱：git config --global user.email '设置用户名的邮箱' 初始化新的git仓库 创建新的文件夹 也可以在命令行 mkdir 文件夹名字进行创建 进入文件夹 ，命令行cd 文件夹名 初始化仓库, 命令行 git init ，会生成一个.git的文件夹，若没有在文件夹下点击查看，打开显示隐藏的项目 项目的管理 上传文件项目(使用流程) 在项目文件夹中，创建文件，也可以在命令行中使用touch 文件名 注意：需要带后缀名 然后使用 git status可以查看文件是否在暂存区域中(没有是红色) 如果没有，使用git add '文件名'即可将文件名上传到暂存区中 git status查看文件是否已经存在于暂存区(存在是绿色) 修改文件 命令行直接 vi/vim 文件名即可输入内容，也可以鼠标右键编辑 修改后 git status，发现文件更改后，又变成红色，需要重新提交 git diff可以查看修改了什么内容 git add 文件名提交即可 git status发现没有文件可以提交，则提交成功 撤销修改(例如撤回reademe.txt文件的修改) 我们再修改文件时可能由于出错误修改，我们可以及时的将文件返回到上一个未修改的版本，修改文件后 git status也可以发现git会提示你使用git checkout -- &lt;file&gt;可以丢弃工作区的修改 当然，命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 删除文件 在命令行rm -rf 文件名(强制删除，不建议使用)或者rm 文件名(普通删除),rm -l 文件名(删除三个以上提示),rm -i 文件名(删除前提示，可以确认删除文件是否选择正确)，或者在鼠标右键删除 注意：上面的步骤是在工作区删除 git rm 文件名:是在git中删除文件 git commit -m '提交描述'，如果需要删除某个文件，则需要rm 文件 再 git rm 文件 再 git commit -m '提交描述',这样就可以完整的删除这个文件了 注意：使用git log 可以查看每次版本的修改历史，如果你嫌弃信息过多眼花缭乱，也可以使用git log --pretty=oneline查看，其中一大串的只是commit id(版本号)而已 回退版本 在git中，使用HEAD表示当前的版本，上个版本使用 (HEAD^)表示，上上版本使用 (HEAD^^)表示，如果是多个可以使用 (HEAD~N)表示 使用 git reset --hard HEAD^表示回退上一个版本，但是我们使用git log已经查看不到之前我们跳转过来的历史了，但是如果我们想还原，也还是有办法的，只要我们不关闭命令行窗口，找到之前的commit id,就可以回到未来的指定版本 使用git reset --hard commit id 后，可以查看是否回到上个版本了 注意： 使用commit id 时不需要全部填写 但是要精确到git能找到该文件 如果我们回退到上一个版本后已经关闭了命令行又想回到最新版本怎么办？ 在git中，提供了一个命令git reflog可以记录你的每一条命令 git远程仓库 添加远程仓库(如：test) 准备工作 创建ssh（如果已经创建关联请忽略） 在命令行下ssh-keygen -t rsa -C &quot;898542119@qq.com&quot;,然后一路回车即可 在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人 登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容即可，这样我们的关联就已经做好了 远程添加文件到仓库中 登陆GitHub，点击 “Create a new repo”，在Repository name 填入仓库名称，其他的默认即可 在你本地的仓库中运行如下：git remote add origin git@github.com:ZhongYueHui/test.git其中ZhongYueHui是GitHub的名字,test仓库的名字 然后使用 git push -u origin master就可以将文件提交到GitHub上了，其实就是将本地分支 master 推送到远程，这样远程的仓库和本地就一样了 从现在开始，只要你对文件做了修改，就可以使用git push origin master将最新的修改提交到版本库了 注意：如果第一次clone或者push会弹出如下警告,输入yes即可 123The authenticity of host 'github.com (xx.xx.xx.xx)' can't be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)? 从远程克隆仓库 在命令行输入git clone git@github.com:ZhongYueHui/gitskills.git即可克隆gitskills仓库 注意：要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆,Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快 分支管理 创建和合并分支 创建分支:git checkout -b 分支名称，git checkout -b dev相当于创建新分支并切换，相当于如下两条命令 12git branch dev //创建分支git checkout dev //切换分支 查看分支:git branch,会列出所有的分支，当前的分支会使用*标记 我们在dev分支下修改的文件在切换到master分支查看，发现并未修改，但是我们可以使用git merge dev将dev分支合并到当前的分支上(master) 合并完之后，我们就可以将dev分支删除了:git branch -d dev，使用git branch查看分支就只有master 了 小结： 1234567891011查看分支：git branch创建分支：git branch &lt;name&gt;切换分支：git checkout &lt;name&gt;创建+切换分支：git checkout -b &lt;name&gt;合并某分支到当前分支：git merge &lt;name&gt;删除分支：git branch -d &lt;name&gt; 分支之间的冲突 假设我们在创建了一个分支feature1，我们在feature1上修改reademe.txt文件，然后git add reademe.txt和git commit -m ''，然后切换到master中同样对reademe.txt做出修改，然后git add reademe.txt和`git commit -m 这样，我们想合并feature1分支就会出异常，Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改自己想要的内容和删除标记后保存：这个时候我们需要将内容统一到和feature1，然后git add reademe.txt和git commit -m即可 我们还可以使用git log --graph --pretty=oneline --abbrev-commit查看分支合并情况分支管理策略 合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fastforward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息 假设我们在创建了一个分支feature1，我们在feature1上修改reademe.txt文件，然后git add reademe.txt和git commit -m ''，然后切换到master中,准备合并feature1，使用=&gt;git merge --no-ff -m &quot;merge with no-ff&quot; dev进行合并，注意 --no-ff表示的是禁用Fast forward git log --graph --pretty=oneline --abbrev-commit查看分支历史123456 * e1e9c68 (HEAD -&gt; master) merge with no-ff|\\ | * f52c633 (dev) add merge|/ * cf810e4 conflict fixed ... BUG分支 我们可能在开发中出现一些紧急的BUG需要及时修复，你可能马上想创建一个BUG修复的文件，但是你突然发现自己手中的 工作还没做完，无法提交，这时候就需要用到Git提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作 我们使用git stash来暂停自己的工作现场，然后创建自己的bug修复分区，然后git add '',git commit -m ''后合并到master分区中，这样BUG修复完毕了，删除bug修复分区即可（git merge --no-ff -m &quot;删除描述&quot; 分区名） 修复完后就可以切换到自己原来的分区继续工作了，但是我们需要使用git stash list查看，使用git status查看是干净的，然后我们可以使用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；另一种方式是用git stash pop，恢复的同时把stash内容(就是暂停的记录)也删了,再使用git stash list就是干净的了 1stash@{0}: WIP on master: 54a255b git tracks changes 你可以多次使用git stash list，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：git stash apply stash@{0} Feature分支 用于实验的项目功能，不能直接用于主分支，容易乱掉，所以最好新建一个分支进行实验性测试 新建一个分区后，新建一个增加功能的文件，git add '',git commit -m ''后git checkout dev合并到dev中，如果此时想删除这个功能文件，我们此时就应该删除该文件git branch -d feature-vulcan，如果提示还没有合并，那么直接将-d换成-D即可强制删除该分区 12error: The branch 'feature-vulcan' is not fully merged.If you are sure you want to delete it, run 'git branch -D feature-vulcan'. 远程同步分支 当我们需要多个人同时开发项目时，我们应该将本地的分支推送到远程分支上 当我们从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。要查看远程库的信息，用git remote或者git remote -v 12origin git@github.com:ZhongYueHui/learngit.git (fetch)origin git@github.com:ZhongYueHui/learngit.git (push) 推送分支 git push origin master将本地分支推送到远程分支上 如果推送dev这个分区，git push origin dev即可 说明： 并不是每个分支都需要被推送， master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步 bug分支只用于在本地修复bug，就没必要推到远程了，除非上级要求 feature分支是否推到远程，取决于你是否和你的项目伙伴抓取分支 如果你和你的团队再开发一个项目时，你的一个伙伴推送文件到dev分支上，并且推送到远程上，这个时候如果你也推送(push)dev到远程，这个是时候就会出错，解决办法也是和分支之间的冲突一样处理 小结： 首先，可以试图用git push origin 推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;rebase 我们在多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的伙伴不得不先pull，在本地合并，然后才能push成功。每次合并再push后，分支变成的很乱 使用git rebase可以解决这个问题，帮我们把分支整理成一条直线标签管理 方便我们查找，虽然git有 commit，但是这个东西是一堆进制数，不方便我们查找，所以我们设置标签的形式，方便查找 在你想要创建标签的分支上,输入git tag &lt;name&gt;添加标签，使用git tag可以查看所有标签给git 如果之前忘记了添加标签，找到历史的commit id打上就可以，git log --pretty=oneline --abbrev-commit 比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令：git tag v0.9 f52c633 查看所有的书签：git show &lt;tagname&gt; 命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息； 命令git tag可以查看所有标签操作书签 修改书签：git tag -d v0.1 将标签推送到远程：git push origin &lt;tagname&gt;或者git push origin --tags一次性将推送未推送的书签 删除远程的书签： 先删除本地的书签：git tag -d v0.9 再从远程删除：git push origin :refs/tags/v0.9 总结： 命令git push origin &lt;tagname&gt;可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d &lt;tagname&gt;可以删除一个本地标签； 命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签","link":"/2019/07/01/git的使用/"}],"tags":[{"name":"Angular","slug":"Angular","link":"/tags/Angular/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"ES7","slug":"ES7","link":"/tags/ES7/"},{"name":"Express","slug":"Express","link":"/tags/Express/"},{"name":"Koa","slug":"Koa","link":"/tags/Koa/"},{"name":"koa","slug":"koa","link":"/tags/koa/"},{"name":"ionic","slug":"ionic","link":"/tags/ionic/"},{"name":"Nodejs","slug":"Nodejs","link":"/tags/Nodejs/"},{"name":"MongoDB","slug":"MongoDB","link":"/tags/MongoDB/"},{"name":"React-native","slug":"React-native","link":"/tags/React-native/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"Redux","slug":"Redux","link":"/tags/Redux/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"vuex","slug":"vuex","link":"/tags/vuex/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"vs code","slug":"vs-code","link":"/tags/vs-code/"}],"categories":[{"name":"Angular","slug":"Angular","link":"/categories/Angular/"},{"name":"ES6","slug":"ES6","link":"/categories/ES6/"},{"name":"ES7","slug":"ES7","link":"/categories/ES7/"},{"name":"Nodejs","slug":"Nodejs","link":"/categories/Nodejs/"},{"name":"ionic","slug":"ionic","link":"/categories/ionic/"},{"name":"MongoDB","slug":"MongoDB","link":"/categories/MongoDB/"},{"name":"React-native","slug":"React-native","link":"/categories/React-native/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"Redux","slug":"Redux","link":"/categories/Redux/"},{"name":"TypeScript","slug":"TypeScript","link":"/categories/TypeScript/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"开发工具","slug":"开发工具","link":"/categories/开发工具/"}]}