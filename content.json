{"pages":[{"title":"关于我","text":"一个专注技术的修行者.","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"express中的中间件","text":"在Nodejs中的Express框架来说，中间件是一个比较抽象的概念，但是对于理解Nodejs的请求原理是非常重要的，这里简单的介绍了Nodejs中Express框架的中间件原理 中间件的原理 就是相当于水经过一系列处理到用户的过程，中间不能跳过某些步骤或者调换某些步骤 下面使用一个代码来帮助我们更好的理解中间件的概念 1234567891011121314151617181920212223242526272829const express = require('express')const app = express()const port = 3000//这个就是中间件，中间件就是一个函数，函数有三个参数//request 请求数据//respone 响应数据// next 表示继续执行下一个中间件，如果没有使用这个方法，那么下面就算有符合匹配项，都不会被执行//这个表示所有请求都会经过这里,但是请求到这里时会停留，如果想要继续执行需要调用next方法app.use(function(request, respone, next) { console.log('a') next() //需要继续执行})app.use(function(request, respone, next) { console.log('b') next() }) //这个表示所有的get请求并且路径为 / 的请求会经过这个中间件app.get('/', (req, res, next) =&gt; { console.log('Hello World!') //如果此时不使用next方法，那么下面的get函数不会 被执行 next()})app.get('/', (req, res, next) =&gt; { res.send('Hello World!')})app.listen(port, () =&gt; console.log(`Example app listening on port port!`)) 所以，我们在使用中间件时，都应该遵循这些规则，这样可以帮助我们更好的编写程序","link":"/2019/06/24/express中的中间件/"},{"title":"webpack打包图片","text":"在webpack中，我们使用其打包一些项目的时候，经常会遇到图片，但是如果直接打包图片则会抛出异常，以下是打包图片的一些详细配置文件和步骤 使用webpack打包图片 在平常中，我们在设置style中使用background:url 可以引入背景图片，在前面我们已经学会如何打包css、less、scss文件 安装url-loader和其依赖file-loader cnpm install url-loader file-loader -D 使用file-loader进行图片的打包 在webpack.config.js中配置，在与其他配置下添加如下即可 1234{ test: /\\.jpg|png|gif|bmp|jpeg/, //配置图片 use: ['file-loader'] } 可以简写成如下： 1234{ test: /\\.(jpg|png|gif|bmp|jpeg)/, //配置图片打包的格式 loader: 'file-loader' } 如果想要打包出来的图片不改变名字和格式，只需添加options即可 123456{ test: /\\.(jpg|png|gif|bmp|jpeg)/, //配置图片打包的格式 loader: 'file-loader' options: { //[name]表示名字,[ext]表示格式，而name属性其实就是图片打包后的路径 name: 'images/[name].[ext]' } 除了使用file-loader对图片进行打包处理外，我们同样也可以使用url-loader代替，另外我们还可以对小于某个大小的图片进行base64格式的转化处理。 使用url-loader打包 12345678{ test: /\\.(png|jpg|gif|svg)$/, loader: 'url-loader', options: { name: './images/[name].[ext]', limit: 8192 }} 这里limit属性的作用就是将小于8192B（8.192K）大小的图片转成base64格式，而大于这个大小的图片将会以file-loader的方式进行打包处理 注意：如果不写limit属性，那么url-loader就会默认将所有图片转成base64 这样打包出来的图片会自动转换成base64,但是我们多数是将小图片转成base64，而大图片不进行转换 而对于有些图片在不同路径下，但是文件名字一样时，我们需要在name:属性中增加hash值：定义[hash:8]定义 8位hash值最多32位，这样图片就不会存在不同 123456789{ test: /\\.(jpg|png|gif|bmp|jpeg)/, //配置图片 loader: 'url-loader', //在这里时，只有一个我们可以简化 loader，使用use则会报错 options: { limit: 2000, //limit 的值单位是 Byte ，如果图片小于limit的值，则转成base64格式的字符串，如果大于，则不转 name: '[hash:8]-[name].[ext]' //这是将文件名原样输出[name]指的是图片名，[ext]是图片格式， //[hash:8]表示生成8位hash值，否则在不同文件夹下同名图片会失效，用来区分 } }","link":"/2019/06/22/webpack打包图片/"},{"title":"webpack中引入vue","text":"在webpack使用vue，我们会遇到一些打包的问题，这个使用我们要使用打包工具来解决这个问题，以下是具体的一些说明和使用。 两者区别 在webpack中，我们需要将所有的包在main.js这个入口文件中导入，在在我们安装vue(npm i vue -D)到本地时，我们在main.js导入这个包 1import Vue from \"vue\" 会爆出以下异常： You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build. 以下的问题解释是：在webpack中使用 import Vue from “vue” 引入的 vue构造函数 功能是不完整的，它只提供了runtime-only 的方式，并没有提供 像网页中使用 script引入的那些功能 解决方式一： 使用：import Vue from &quot;../node_modules/vue/dist/vue&quot;这种引入方式 解决方式二： 配置webpack.config.js文件，新增一个属性:resolve，在里面中还有一个属性:alias，配置如下 123456resolve: { alias: { 'vue$': 'vue/dist/vue.esm.js' }} 这样使用import Vue from &quot;vue&quot;引入也不会报错了 说明 由于webpack是使用Node架构的，所以合法的Node语法都支持，当然，引入包的规则也是一致的 如下： Nodejs中包的查找规则: 找项目根目录中是否有安装 node_modules 的文件夹 在node_modules 中根据包名，找对应的 vue 文件夹 在 vue中，找到一个叫packahe.json的配置文件 在package.json 文件夹中，查找一个 main 属性，这个属性指定了这个包被加载时的入口文件","link":"/2019/06/23/webpack中引入vue/"},{"title":"webpack配置的一些总结","text":"在配置webpack打包项目时，有些必要的插件安装与配置，才能保证项目完整的被打包，这里总结了一些基础的webpack配置，可以满足基础的打包运行要求。 全局安装webpack npm install webpack -g 生成package.json npm init -y 安装webpack-dev-server到本地 npm install webpack-dev-server -D 仍然需要在本地安装webpack作为webpack-dev-server的依赖 npm install webpack -D 配置webpack.config.js文件 创建webpack.config.js文件 配置文件出入口 1234567891011121314151617181920212223//由于webpack是由Nodejs构建的，所以任何的Nodejs语法都支持//引入路径模块var path = require('path')//当以命令形式运行webpack或者webpack-dev-server的时候，工具会发现，我们没用提供要打包的文件入口和出口命令//此时，就会检查项目根目录中的配置文件 webpack.config.js 并读取这个文件，就拿到了导出的这个配置对象，然后根据对象进行打包//向外暴露出这个对象module.exports = { entry: path.join(__dirname, './src/main.js') //入口文件，需要打包的文件 , output: { //出口文件，需要打包到哪里去 path: path.join(__dirname, './dist/bundle.js') //输出路径 , filename: 'bundle.js' }, mode: 'development', //设置mode，在4.0新增 } 配置一些功能：在webpack.config.js中配置 123456 devServer: { //配置webpack-dev-server open: true, //是否打开浏览器 contentBase: 'src', //指定托管的目录 hot: true, //是否启用热更新 port: 6000 //代理的端口}, 在package.json中配置 123\"script\":{\"start:dev\": \"webpack --open --port 3000 --contentBase src --hot\"} 需要将打包好的文件从虚拟内存中传入过来 安装html-webpack-plugin npm install html-webpack-plugin -D 在webpack.config.js中配置这个插件 作用： 在内存中，根据只当的模板页面，生成一份内存中的首页，同时把打包好的bundle.js注入到页面底部 如果需要配置插件，需要在导出的对象中挂载一个 plugins:[] 注意：所有的第三方插件都在 plugins:[]中配置 与entry、output同级1234567plugins: [ new htmlWebpackPlugin({ template: path.join(__dirname, './src/index.html'), //指定模板文件的目录 filename: 'index.html' //设置生成的页面名称 }) ] 配置css-loader、less-loader、sass-loader 在main.js中引入css文件 import ‘./css/style.css’ 安装css-loader插件：npm install css-loader style-loader --save-dev import ‘./css/style.less’ 安装css-loader插件：npm install less-loader less --save-dev import ‘./css/style.sass’ 安装css-loader插件：npm install sass-loader node-sass --save-dev 配置文件 在webpack.config.js配置sass 注意：使用npm命令时安装node-sass可能会报错，无法打包，此时建议切换成cnpm 切换方法 cmd运行nrm ls查看,然后切换nrm use cnpm即可，但是前提应该先在全局中安装nrm 12345678910111213module.exports = { ... module: { rules: [{ test: /\\.scss$/, use: [ \"style-loader\", // creates style nodes from JS strings \"css-loader\", // translates CSS into CommonJS \"sass-loader\" // compiles Sass to CSS, using Node Sass by default ] }] }}; 在webpack.config.js配置css 12345678910module.exports = {module: { rules: [ { test: /\\.css$/i, use: ['style-loader', 'css-loader'], }, ],},}; 在webpack.config.js配置less 12345678910module.exports = {module: { rules: [ { test: /\\.less$/, loader: 'less-loader', // compiles Less to CSS }, ],},}; 配置好基本的webpack.config.js文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//由于webpack是由Nodejs构建的，所以任何的Nodejs语法都支持//引入路径模块var path = require('path')//在内存中，根据只当的模板页面，生成一份内存中的首页，同时把打包好的bundle.js注入到页面底部//如果需要配置插件，需要在导出的对象中挂载一个 plugins:[]const htmlWebpackPlugin = require('html-webpack-plugin')//当以命令形式运行webpack或者webpack-dev-server的时候，工具会发现，我们没用提供要打包的文件入口和出口命令//此时，就会检查项目根目录中的配置文件 webpack.config.js 并读取这个文件，就拿到了导出的这个配置对象，然后根据对象进行打包//向外暴露出这个对象module.exports = { entry: path.join(__dirname, './src/main.js') //入口文件，需要打包的文件 , output: { //出口文件，需要打包到哪里去 path: path.join(__dirname, './dist') //输出路径 , filename: 'bundle.js' }, module: { rules: [{ test: /\\.css$/i, //配置css use: ['style-loader', 'css-loader'], }, { test: /\\.less$/i, //配置less use: ['style-loader', 'css-loader', 'less-loader'] }, { test: /\\.scss$/i, //配置sass use: ['style-loader', 'css-loader', 'sass-loader'] }], }, devServer: { //配置webpack-dev-server open: true, //是否打开浏览器 contentBase: 'src', //指定托管的目录 hot: true, //是否启用热更新 port: 2000 //代理的端口 }, mode: 'development', plugins: [ new htmlWebpackPlugin({ template: path.join(__dirname, './src/index.html'), //指定模板文件的目录 filename: 'index.html' //设置生成的页面名称 }) ]} 注意事项： 在webpack4.0以后，webpack新增了mode属性 打包命令有所变化 webpack 要打包的文件 -o 打包生成存放文件的路径 而且在package.json文件中，需要配置如下代码： 1234\"scripts\": { \"dev\": \"webpack --mode development\", // 开发环境 \"build\": \"webpack --mode production\", // 生产环境 }, 在webpack.config.js中，同样需要配置如下代码：1mode: 'development' // 设置mode 如果需要下载指定版本，输入以下命令： npm i -D webpack@3 // 3： webpack版本3最新","link":"/2019/06/22/webpack配置的一些总结/"},{"title":"git的使用","text":"前言 我们在平时的项目开发中，难免会用到一些托管工具来托管自己的代码，这样可以更好的和别人和分享自己项目和合作开发项目，这里就简单介绍一下git的使用。 Git基本操作 上传本地文件(工作区)到暂存区 git status先初始化项目(状态)，检查是否在工作区域还是暂存区 git add 文件名将文件上传到暂存区 将暂存区的文件上传到git仓库中 git status初始化暂存区的项目，查看是否含有相同的内容 git commit -m &quot;提交的描述&quot;，项目的说明 git status 查看文件状态 注意：使用 git commit -m '' 是一次性将文件放到分支，使用git add是将文件添加到暂存区(Stage), git是版本控制工具，并不是文件控制工具，我们只有使用git add添加到暂存区的文件，再使用git commit -m ''才能将文件提交到分支，如果你修改了文件直接提交到分支，这个是不能修改的，不信你可以使用git diff HEAD -- '文件名'查看工作区和版面本库中最新版本的区别 ，没有使用git add '' 的文件内容没有并没有添加到版本库(commit)中 基本流程 基本流程图 基本设置 设置用户名:git config --global user.name 'GitHub的用户名' 设置用户名的邮箱：git config --global user.email '设置用户名的邮箱'初始化新的git仓库 创建新的文件夹 也可以在命令行 mkdir 文件夹名字进行创建 进入文件夹 ，命令行cd 文件夹名 初始化仓库, 命令行 git init ，会生成一个.git的文件夹，若没有在文件夹下点击查看，打开显示隐藏的项目 项目的管理 上传文件项目(使用流程) 在项目文件夹中，创建文件，也可以在命令行中使用touch 文件名 注意：需要带后缀名 然后使用 git status可以查看文件是否在暂存区域中(没有是红色) 如果没有，使用git add '文件名'即可将文件名上传到暂存区中 git status查看文件是否已经存在于暂存区(存在是绿色) 修改文件 命令行直接 vi/vim 文件名即可输入内容，也可以鼠标右键编辑 修改后 git status，发现文件更改后，又变成红色，需要重新提交 git diff可以查看修改了什么内容 git add 文件名提交即可 git status发现没有文件可以提交，则提交成功 撤销修改(例如撤回reademe.txt文件的修改) 我们再修改文件时可能由于出错误修改，我们可以及时的将文件返回到上一个未修改的版本，修改文件后 git status也可以发现git会提示你使用git checkout -- &lt;file&gt;可以丢弃工作区的修改 当然，命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 删除文件 在命令行rm -rf 文件名(强制删除，不建议使用)或者rm 文件名(普通删除),rm -l 文件名(删除三个以上提示),rm -i 文件名(删除前提示，可以确认删除文件是否选择正确)，或者在鼠标右键删除 注意：上面的步骤是在工作区删除 git rm 文件名:是在git中删除文件 git commit -m '提交描述'，如果需要删除某个文件，则需要rm 文件 再 git rm 文件 再 git commit -m '提交描述',这样就可以完整的删除这个文件了 注意：使用git log 可以查看每次版本的修改历史，如果你嫌弃信息过多眼花缭乱，也可以使用git log --pretty=oneline查看，其中一大串的只是commit id(版本号)而已 回退版本 在git中，使用HEAD表示当前的版本，上个版本使用 (HEAD^)表示，上上版本使用 (HEAD^^)表示，如果是多个可以使用 (HEAD~N)表示 使用 git reset --hard HEAD^表示回退上一个版本，但是我们使用git log已经查看不到之前我们跳转过来的历史了，但是如果我们想还原，也还是有办法的，只要我们不关闭命令行窗口，找到之前的commit id,就可以回到未来的指定版本 使用git reset --hard commit id 后，可以查看是否回到上个版本了 注意： 使用commit id 时不需要全部填写 但是要精确到git能找到该文件 如果我们回退到上一个版本后已经关闭了命令行又想回到最新版本怎么办？ 在git中，提供了一个命令git reflog可以记录你的每一条命令 git远程仓库 添加远程仓库(如：test) 准备工作 创建ssh（如果已经创建关联请忽略） 在命令行下ssh-keygen -t rsa -C &quot;898542119@qq.com&quot;,然后一路回车即可 在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人 登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容即可，这样我们的关联就已经做好了 远程添加文件到仓库中 登陆GitHub，点击 “Create a new repo”，在Repository name 填入仓库名称，其他的默认即可 在你本地的仓库中运行如下：git remote add origin git@github.com:ZhongYueHui/test.git其中ZhongYueHui是GitHub的名字,test仓库的名字 然后使用 git push -u origin master就可以将文件提交到GitHub上了，其实就是将本地分支 master 推送到远程，这样远程的仓库和本地就一样了 从现在开始，只要你对文件做了修改，就可以使用git push origin master将最新的修改提交到版本库了 注意：如果第一次clone或者push会弹出如下警告,输入yes即可 123The authenticity of host 'github.com (xx.xx.xx.xx)' can't be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)? 从远程克隆仓库 在命令行输入git clone git@github.com:ZhongYueHui/gitskills.git即可克隆gitskills仓库 注意：要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆,Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快 分支管理 创建和合并分支 创建分支:git checkout -b 分支名称，git checkout -b dev相当于创建新分支并切换，相当于如下两条命令 12git branch dev //创建分支git checkout dev //切换分支 查看分支:git branch,会列出所有的分支，当前的分支会使用*标记 我们在dev分支下修改的文件在切换到master分支查看，发现并未修改，但是我们可以使用git merge dev将dev分支合并到当前的分支上(master) 合并完之后，我们就可以将dev分支删除了:git branch -d dev，使用git branch查看分支就只有master 了 小结： 1234567891011查看分支：git branch创建分支：git branch &lt;name&gt;切换分支：git checkout &lt;name&gt;创建+切换分支：git checkout -b &lt;name&gt;合并某分支到当前分支：git merge &lt;name&gt;删除分支：git branch -d &lt;name&gt; 分支之间的冲突 假设我们在创建了一个分支feature1，我们在feature1上修改reademe.txt文件，然后git add reademe.txt和git commit -m ''，然后切换到master中同样对reademe.txt做出修改，然后git add reademe.txt和`git commit -m 这样，我们想合并feature1分支就会出异常，Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改自己想要的内容和删除标记后保存：这个时候我们需要将内容统一到和feature1，然后git add reademe.txt和git commit -m即可 我们还可以使用git log --graph --pretty=oneline --abbrev-commit查看分支合并情况分支管理策略 合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fastforward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息 假设我们在创建了一个分支feature1，我们在feature1上修改reademe.txt文件，然后git add reademe.txt和git commit -m ''，然后切换到master中,准备合并feature1，使用=&gt;git merge --no-ff -m &quot;merge with no-ff&quot; dev进行合并，注意 --no-ff表示的是禁用Fast forward git log --graph --pretty=oneline --abbrev-commit查看分支历史123456 * e1e9c68 (HEAD -&gt; master) merge with no-ff|\\ | * f52c633 (dev) add merge|/ * cf810e4 conflict fixed ... BUG分支 我们可能在开发中出现一些紧急的BUG需要及时修复，你可能马上想创建一个BUG修复的文件，但是你突然发现自己手中的 工作还没做完，无法提交，这时候就需要用到Git提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作 我们使用git stash来暂停自己的工作现场，然后创建自己的bug修复分区，然后git add '',git commit -m ''后合并到master分区中，这样BUG修复完毕了，删除bug修复分区即可（git merge --no-ff -m &quot;删除描述&quot; 分区名） 修复完后就可以切换到自己原来的分区继续工作了，但是我们需要使用git stash list查看，使用git status查看是干净的，然后我们可以使用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；另一种方式是用git stash pop，恢复的同时把stash内容(就是暂停的记录)也删了,再使用git stash list就是干净的了 1stash@{0}: WIP on master: 54a255b git tracks changes 你可以多次使用git stash list，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：git stash apply stash@{0} Feature分支 用于实验的项目功能，不能直接用于主分支，容易乱掉，所以最好新建一个分支进行实验性测试 新建一个分区后，新建一个增加功能的文件，git add '',git commit -m ''后git checkout dev合并到dev中，如果此时想删除这个功能文件，我们此时就应该删除该文件git branch -d feature-vulcan，如果提示还没有合并，那么直接将-d换成-D即可强制删除该分区 12error: The branch 'feature-vulcan' is not fully merged.If you are sure you want to delete it, run 'git branch -D feature-vulcan'. 远程同步分支 当我们需要多个人同时开发项目时，我们应该将本地的分支推送到远程分支上 当我们从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。要查看远程库的信息，用git remote或者git remote -v 12origin git@github.com:ZhongYueHui/learngit.git (fetch)origin git@github.com:ZhongYueHui/learngit.git (push) 推送分支 git push origin master将本地分支推送到远程分支上 如果推送dev这个分区，git push origin dev即可 说明： 并不是每个分支都需要被推送， master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步 bug分支只用于在本地修复bug，就没必要推到远程了，除非上级要求 feature分支是否推到远程，取决于你是否和你的项目伙伴抓取分支 如果你和你的团队再开发一个项目时，你的一个伙伴推送文件到dev分支上，并且推送到远程上，这个时候如果你也推送(push)dev到远程，这个是时候就会出错，解决办法也是和分支之间的冲突一样处理 小结： 首先，可以试图用git push origin 推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;rebase 我们在多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的伙伴不得不先pull，在本地合并，然后才能push成功。每次合并再push后，分支变成的很乱 使用git rebase可以解决这个问题，帮我们把分支整理成一条直线标签管理 方便我们查找，虽然git有 commit，但是这个东西是一堆进制数，不方便我们查找，所以我们设置标签的形式，方便查找 在你想要创建标签的分支上,输入git tag &lt;name&gt;添加标签，使用git tag可以查看所有标签给git 如果之前忘记了添加标签，找到历史的commit id打上就可以，git log --pretty=oneline --abbrev-commit 比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令：git tag v0.9 f52c633 查看所有的书签：git show &lt;tagname&gt; 命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息； 命令git tag可以查看所有标签操作书签 修改书签：git tag -d v0.1 将标签推送到远程：git push origin &lt;tagname&gt;或者git push origin --tags一次性将推送未推送的书签 删除远程的书签： 先删除本地的书签：git tag -d v0.9 再从远程删除：git push origin :refs/tags/v0.9 总结： 命令git push origin &lt;tagname&gt;可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d &lt;tagname&gt;可以删除一个本地标签； 命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签","link":"/2019/07/01/git的使用/"}],"tags":[{"name":"Express","slug":"Express","link":"/tags/Express/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"git","slug":"git","link":"/tags/git/"}],"categories":[{"name":"Nodejs","slug":"Nodejs","link":"/categories/Nodejs/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"Git","slug":"Git","link":"/categories/Git/"}]}