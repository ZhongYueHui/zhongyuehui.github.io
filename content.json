{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"关于我","text":"一个专注技术的修行者.","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"webpack配置的一些总结","text":"全局安装webpack npm install webpack -g 生成package.json npm init -y 安装webpack-dev-server到本地 npm install webpack-dev-server -D 仍然需要在本地安装webpack作为webpack-dev-server的依赖 npm install webpack -D 配置webpack.config.js文件 创建webpack.config.js文件 配置文件出入口 1234567891011121314151617181920212223//由于webpack是由Nodejs构建的，所以任何的Nodejs语法都支持//引入路径模块var path = require('path')//当以命令形式运行webpack或者webpack-dev-server的时候，工具会发现，我们没用提供要打包的文件入口和出口命令//此时，就会检查项目根目录中的配置文件 webpack.config.js 并读取这个文件，就拿到了导出的这个配置对象，然后根据对象进行打包//向外暴露出这个对象module.exports = { entry: path.join(__dirname, './src/main.js') //入口文件，需要打包的文件 , output: { //出口文件，需要打包到哪里去 path: path.join(__dirname, './dist/bundle.js') //输出路径 , filename: 'bundle.js' }, mode: 'development', //设置mode，在4.0新增 } 配置一些功能：在webpack.config.js中配置 123456 devServer: { //配置webpack-dev-server open: true, //是否打开浏览器 contentBase: 'src', //指定托管的目录 hot: true, //是否启用热更新 port: 6000 //代理的端口}, 在package.json中配置 123\"script\":{\"start:dev\": \"webpack --open --port 3000 --contentBase src --hot\"} 需要将打包好的文件从虚拟内存中传入过来安装html-webpack-plugin npm install html-webpack-plugin -D 在webpack.config.js中配置这个插件 作用： 在内存中，根据只当的模板页面，生成一份内存中的首页，同时把打包好的bundle.js注入到页面底部 如果需要配置插件，需要在导出的对象中挂载一个 plugins:[] 注意：所有的第三方插件都在 plugins:[]中配置 与entry、output同级1234567plugins: [ new htmlWebpackPlugin({ template: path.join(__dirname, './src/index.html'), //指定模板文件的目录 filename: 'index.html' //设置生成的页面名称 }) ] 配置css-loader、less-loader、sass-loader 在main.js中引入css文件 import ‘./css/style.css’ 安装css-loader插件：npm install css-loader style-loader --save-dev import ‘./css/style.less’ 安装css-loader插件：npm install less-loader less --save-dev import ‘./css/style.sass’ 安装css-loader插件：npm install sass-loader node-sass --save-dev配置文件 在webpack.config.js配置sass 注意：使用npm命令时安装node-sass可能会报错，无法打包，此时建议切换成cnpm 切换方法 cmd运行nrm ls查看,然后切换nrm use cnpm即可，但是前提应该先在全局中安装nrm 12345678910111213module.exports = { ... module: { rules: [{ test: /\\.scss$/, use: [ \"style-loader\", // creates style nodes from JS strings \"css-loader\", // translates CSS into CommonJS \"sass-loader\" // compiles Sass to CSS, using Node Sass by default ] }] }}; 在webpack.config.js配置css 12345678910module.exports = { module: { rules: [ { test: /\\.css$/i, use: ['style-loader', 'css-loader'], }, ], },}; 在webpack.config.js配置less 12345678910module.exports = { module: { rules: [ { test: /\\.less$/, loader: 'less-loader', // compiles Less to CSS }, ], },}; 配置好基本的webpack.config.js文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//由于webpack是由Nodejs构建的，所以任何的Nodejs语法都支持//引入路径模块var path = require('path')//在内存中，根据只当的模板页面，生成一份内存中的首页，同时把打包好的bundle.js注入到页面底部//如果需要配置插件，需要在导出的对象中挂载一个 plugins:[]const htmlWebpackPlugin = require('html-webpack-plugin')//当以命令形式运行webpack或者webpack-dev-server的时候，工具会发现，我们没用提供要打包的文件入口和出口命令//此时，就会检查项目根目录中的配置文件 webpack.config.js 并读取这个文件，就拿到了导出的这个配置对象，然后根据对象进行打包//向外暴露出这个对象module.exports = { entry: path.join(__dirname, './src/main.js') //入口文件，需要打包的文件 , output: { //出口文件，需要打包到哪里去 path: path.join(__dirname, './dist') //输出路径 , filename: 'bundle.js' }, module: { rules: [{ test: /\\.css$/i, //配置css use: ['style-loader', 'css-loader'], }, { test: /\\.less$/i, //配置less use: ['style-loader', 'css-loader', 'less-loader'] }, { test: /\\.scss$/i, //配置sass use: ['style-loader', 'css-loader', 'sass-loader'] }], }, devServer: { //配置webpack-dev-server open: true, //是否打开浏览器 contentBase: 'src', //指定托管的目录 hot: true, //是否启用热更新 port: 2000 //代理的端口 }, mode: 'development', plugins: [ new htmlWebpackPlugin({ template: path.join(__dirname, './src/index.html'), //指定模板文件的目录 filename: 'index.html' //设置生成的页面名称 }) ]} 注意事项： 在webpack4.0以后，webpack新增了mode属性 打包命令有所变化 webpack 要打包的文件 -o 打包生成存放文件的路径 而且在package.json文件中，需要配置如下代码： 1234\"scripts\": { \"dev\": \"webpack --mode development\", // 开发环境 \"build\": \"webpack --mode production\", // 生产环境 }, 在webpack.config.js中，同样需要配置如下代码：1mode: 'development' // 设置mode 如果需要下载指定版本，输入以下命令： npm i -D webpack@3 // 3： webpack版本3最新","link":"/2019/06/22/webpack配置的一些总结/"},{"title":"webpack打包图片","text":"使用webpack打包图片 在平常中，我们在设置style中使用background:url 可以引入背景图片，在前面我们已经学会如何打包css、less、scss文件 安装url-loader和其依赖file-loader cnpm install url-loader file-loader -D 使用file-loader进行图片的打包 在webpack.config.js中配置，在与其他配置下添加如下即可 1234{ test: /\\.jpg|png|gif|bmp|jpeg/, //配置图片 use: ['file-loader'] } 可以简写成如下： 1234{ test: /\\.(jpg|png|gif|bmp|jpeg)/, //配置图片打包的格式 loader: 'file-loader' } 如果想要打包出来的图片不改变名字和格式，只需添加options即可 123456{ test: /\\.(jpg|png|gif|bmp|jpeg)/, //配置图片打包的格式 loader: 'file-loader' options: { //[name]表示名字,[ext]表示格式，而name属性其实就是图片打包后的路径 name: 'images/[name].[ext]' } 除了使用file-loader对图片进行打包处理外，我们同样也可以使用url-loader代替，另外我们还可以对小于某个大小的图片进行base64格式的转化处理。 使用url-loader打包 12345678{ test: /\\.(png|jpg|gif|svg)$/, loader: 'url-loader', options: { name: './images/[name].[ext]', limit: 8192 }} 这里limit属性的作用就是将小于8192B（8.192K）大小的图片转成base64格式，而大于这个大小的图片将会以file-loader的方式进行打包处理 注意：如果不写limit属性，那么url-loader就会默认将所有图片转成base64 这样打包出来的图片会自动转换成base64,但是我们多数是将小图片转成base64，而大图片不进行转换 而对于有些图片在不同路径下，但是文件名字一样时，我们需要在name:属性中增加hash值： 定义[hash:8]定义 8位hash值最多32位，这样图片就不会存在不同 123456789{ test: /\\.(jpg|png|gif|bmp|jpeg)/, //配置图片 loader: 'url-loader', //在这里时，只有一个我们可以简化 loader，使用use则会报错 options: { limit: 2000, //limit 的值单位是 Byte ，如果图片小于limit的值，则转成base64格式的字符串，如果大于，则不转 name: '[hash:8]-[name].[ext]' //这是将文件名原样输出[name]指的是图片名，[ext]是图片格式， //[hash:8]表示生成8位hash值，否则在不同文件夹下同名图片会失效，用来区分 } }","link":"/2019/06/22/webpack打包图片/"}],"tags":[{"name":"webpack","slug":"webpack","link":"/tags/webpack/"}],"categories":[{"name":"Vue","slug":"Vue","link":"/categories/Vue/"}]}