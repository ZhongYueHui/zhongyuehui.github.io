{"pages":[{"title":"关于我","text":"一个专注技术的修行者.","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Node中的path路径模块","text":"在Node中，有许多的模块,但是Node.js path 模块提供了一些用于处理文件路径的小工具 Path模块 引入 const path = require('path') path的一些方法path.basename(): 只有一个参数时 有两个参数时，且参数的后缀名相同时 有两个参数时，且参数的后缀名不相同时 总结： 一个参数时直接输出带后缀名的文件名 两个参数时第二个参数为第一个参数的后缀名时输出为不带后缀名的文件名 两个参数时第二个参数不是第一个参数的后缀名时输出仍是带后缀名的文件名path.dirname() 只输出目录 path.extname() 只输出后缀名 path.isAbsolute() 判断是否为绝对路径，返回一个布尔值 注意：文件路径前不能有空格 否则直接返回flase 拓展：绝对路径的两种方式 如：c:/a/b/c/index.js ，有磁盘符，相对于磁盘符的绝对路径 如：/a/b/c/index.js ，没有磁盘符，相对于当前磁盘下的绝对路径path.parse() 查看文件的详细信息 path.join() 路径拼接 在Node中，许多时候我们都需要用到路径模块，对文件路径的判断做出相应的响应","link":"/2019/07/07/Node中的path路径模块/"},{"title":"TypeScript中的数据类型","text":"JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。这里主要介绍前五种原始数据类型和一些其他的TypeScript的数据类型。 Typescript中的数据类型布尔类型(boolean)1234&lt;!--在ES5中--&gt;var flag= true flag=123 console.log(flag) //123 12345678&lt;!--在Typescript中--&gt;var flag= true flag=123 //在这里时，编译器已经报错了&lt;!--正确的写法--&gt;var flag:boolean= true flag=false console.log(flag) //false 数字类型(number)、12345678910111213&lt;!--在ES5中--&gt;var num=123 num='aa' console.log(num) //aa&lt;!--在typesctipt--&gt;var num:number=123 num='str'// 编译器报错 &lt;!--正确的写法--&gt;var num:number = 123 num=456 console/log(num) //num 根据前两个我们已经可以看的出来.只要规定了该变量是什么类型或者是第一个赋值该变量的数据是什么类型的,这个变量就是什么类型的数据,并且赋值只能赋值相同的类型数据,否则直接报错字符串类型(string) 1234&lt;!--在typescript中--&gt;let str:string = 'string' str = 'hello' console.log(str) //hello 数组类型(array)定义方式一: 在变量名后面跟上数组的类型 12345let arr:number[]= [12,11]arr=[\"123\",123] //这样就报错了arr=[123,456] //这样是正确的 定义方式二: 在变量名定义数组的时候在&lt;&gt;中定义数组的类型 12let arr:Array&lt;number&gt;=[12,123]console.log(arr) 定义方式三: 在下面有any类型的讲解 12let arr:any[]=['123',456,false]console.log(arr) //输出: [ '123', 456, false ] 元组类型(tuple) 属于数组中的一种,可以定义多种数据类型,但是必须一一对应 12let arr:[number,string]=[123,\"123\"]arr=[\"123\",123] //这样是错误的,值必须与数据类型一一对应 枚举类型(enum) 123456enum Flag{ success=200, error=500}let s:Flag=Flag.successconsole.log(s) //输出:200 如果赋值了那么打印的就是你赋值的数字 123456enum Flag{ success=1, error=2}let s:Flag=Flag.successconsole.log(s) //输出:0 如果没有赋值那么输出的结果就是对应的下标,从 0 开始 1234567enum Flag{ success, 'error'=3, number}let s:Flag=Flag.numberconsole.log(s) //输出: 4,相当于前面的error=3赋值的是数组的下标,后面的值没有定义的话就是默认前面的下标+1 为了详细一点,我们在看一下这个代码就清楚了 12345678910111213141516enum Flag{ 'success'=-1, 'error'=999, number}let s:Flag=Flag.numberconsole.log(s) //输出 1000enum Flag{ 'success'=-10, 'error'=-15, number}let s:Flag=Flag.numberconsole.log(s) //输出 -14 注意: 在这个Flag中定义的名称可以加 ‘ ‘,也可以不加 ‘ ‘,但是值一定不能加‘ ‘,并且只能是数字,否则报错 任意类型(any)123let num:any[]=['123',123]num=['a',45]console.log(num); // 输出: ['a',45] any可以是任意的类型,但是我们在平时定义数据时不要随意使用any,不然其他的数据类型设计就没有意义了 any的正确用法: 12let app = document.getElementById('app')app.style.color= 'red' //报错了,对象可能为空 在Typescript中,并没有Object类型,所以无论定义什么具体类型,都会报错,这个时候我们就需要加入any 12let app:any = document.getElementById('app')app.style.color= 'red' 这样我们就完美的解决了这个错误 null和undefined 其他数据类型的子类型 示例: 12let num:numberconsole.log(num) //报错,在赋值前使用了num 这说明number类型的数据在赋值前都不能使用 12let num:undefinedconsole.log(num) //输出: undedined 有时候我们不管这个存不存在,存在的话就是number类型,不存在就是undefined类型 联合类型 123var num:undefined | number | nullnum=123console.log(num) //输出 123 并且不报错 12var num:undefined | number | nullconsole.log(num) //输出:undefined ,就算是没有赋值也不会报错 123var num:undefined | number | nullnum=nullconsole.log(num) //输出 null 这样就相当于有值就是number类型,没有值就是undefined,赋值为null就是null,因为undefined只能赋值为undefined,null只能赋值为null viod 类型 在typescript中,viod类型表示没有任何类型,一般定义没有返回值的方法 示例: 12345&lt;!--在ES5中--&gt;function run():void{ console.log('hello world')}run() //正常输出 1234function run():undefined{ console.log('aaa');}run() //报错,声明类型如果不是 viod 或者 any ,必须要有返回值 12345function run():undefined{ return null }run() //报错,不能返回数据类型不同的数据 never类型 never类型其他类型(包括了null,undefined)的子类型,代表从来不会出现的值,怎么理解呢? 12345let a:nevera=123 //报错let b:neverb=null //报错 这就说明了它不能是任意我们可以有的值,必须是没有的数据类型 1234let err:nevererr= (()=&gt;{ throw Error('error')})() 当我们使用never定义自执行函数抛出错误时,那么就可以使用never了,但是使用场景并不是很多,很多时候我们使用any来代替 总结的一些问题: 类型的推断 1234let num;num='45',num=123console.log(num) //123 我们可以推断,如果一开始没有给变量赋值,那么我们推断它默认就是 any 类型,可以赋任意值,和变量没有指定数据类型赋值一样,我们推断它是使用第一个赋值的数据类型作为该变量数据类型 在viod类型中,函数如果没有返回值那么使用 viod定义,如果有返回值,那么返回数据类型必须和定义函数的数据类型保持一致","link":"/2019/07/07/TypeScript中的数据类型/"},{"title":"Vs code中Git工具的使用","text":"在一些开发工具中，集成了许多的功能，在我喜欢的vscode中，就集成了git的一些功能，非常方便我们使用 vscode中的Git工具 当我们在对一些推送到远程的项目进行修改时，我们在VS code中发现修改的内容在侧边会有标记 红色的箭头标识表示这里删除了一些东西 绿色标识表示这里修改了一些东西 蓝色标识标识增加了一些东西 当然，我们要说的并不是只有这些，最主要的是我们修改的文件内容后需要推送到远程，再也不需要git add ''、git commit -m '' ，git push了，我们在侧边栏找到这个工具 在这里工具会显示你修改了几个文件，而在更多这里显示你修改了哪些文件，鼠标指针放在修改的文件可以对文件进行一些操作，比如撤回修改 我们继续往下看，在这里有一个 message这里需要添加的是你提交的描述，和git commit -m '' 这里的一致，添加消息后点击 √就可以保存到暂存区了 如果需要推送到远程，点击推送即可、 注意：如果你关联了多个远程，那么直接点击推送可能会报错，因为它不知道你需要推送到哪一个，所以选择推送到...然后选择即可 这样我们在以后的开发中可以减少一点工作量","link":"/2019/07/02/Vs code中Git工具的使用/"},{"title":"Vuex的使用","text":"vuex是什么？Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 前言 我们在进行一些复杂的父子组件之间的传值的时候，尤其是组件嵌套传值时尤其麻烦，读取值不方便，如果有异步操作，还需要对值监听，这样获取一些值得时候对我们开发人员不友好，所以诞生了Vuex Vuex的使用vuex的安装配置 安装:npm install vuex -S 如果使用&lt;script&gt;&lt;/script&gt;标签引入的vue，那么自己会安装有vuex 安装插件： 1234import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex) 配置: 123456789101112// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)const store = new Vuex.Store({ state: { //这个就是相当于 vue中的 data，用来存放数据的 count: 0 }, mutations: { //这个相当于 vue 中的 methods ，存放了些方法 increment (state) { state.count++ } }}) 使用:实现一个小案例，官方也是这个案例来说明的： main.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 入口文件import Vue from 'vue'// 配置vuex的步骤// 1. 运行 cnpm i vuex -S // 2. 导入包import Vuex from 'vuex'// 3. 注册vuex到vue中Vue.use(Vuex) // 4. new Vuex.Store() 实例，得到一个 数据仓储对象var store = new Vuex.Store({ state: { // 大家可以把 state 想象成 组件中的 data ,专门用来存储数据的 // 如果在 组件中，想要访问，store 中的数据，只能通过 this.$store.state.*** 来访问 count: 0 },mutations: { // 注意： 如果要操作 store 中的 state 值，只能通过 调用 mutations 提供的方法，才能操作对应的数据，不推荐直接操作 state 中的数据，因为 万一导致了数据的紊乱，不能快速定位到错误的原因，因为，每个组件都可能有操作数据的方法； increment(state) { state.count++ }, // 注意： 如果组件想要调用 mutations 中的方法，只能使用 this.$store.commit('方法名') // 这种 调用 mutations 方法的格式，和 this.$emit('父组件中方法名') subtract(state, obj) { // 注意： mutations 的 函数参数列表中，最多支持两个参数，其中，参数1： 是 state 状态； 参数2： 通过 commit 提交过来的参数； console.log(obj) state.count -= (obj.c + obj.d) }},getters: { // 注意：这里的 getters， 只负责 对外提供数据，不负责 修改数据，如果想要修改 state 中的数据，请 去找 mutations optCount: function(state) { return '当前最新的count值是：' + state.count } // 经过咱们回顾对比，发现 getters 中的方法， 和组件中的过滤器比较类似，因为 过滤器和 getters 都没有修改原数据， 都是把原数据做了一层包装，提供给了 调用者； // 其次， getters 也和 computed 比较像， 只要 state 中的数据发生变化了，那么，如果 getters 正好也引用了这个数据，那么 就会立即触发 getters 的重新求值； }})import App from './App.vue'const vm = new Vue({ el: '#app', render: h =&gt; h(App), store // 5. 将 vuex 创建的 store 挂载到 VM 实例上， 只要挂载到了 vm 上，任何组件都能使用 store 来存取数据}) counter.vue文件内容 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div&gt; &lt;input type=\"button\" value=\"减少\" @click=\"remove\"&gt; &lt;input type=\"button\" value=\"增加\" @click=\"add\"&gt; &lt;br&gt; &lt;input type=\"text\" v-model=\"$store.state.count\"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { // count: 0 }; }, methods: { add() { // 不要这样使用，不符合 vuex 的设计理念，因为这样直接操作了state // this.$store.state.count++; this.$store.commit(\"increment\"); }, remove() { this.$store.commit(\"subtract\", { c: 3, d: 1 }); } }, computed:{ fullname: { get(){}, set(){} } }};&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt;&lt;/style&gt; amount.vue文件内容： 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;!-- &lt;h3&gt;{{ $store.state.count }}&lt;/h3&gt; --&gt; &lt;h3&gt;{{ $store.getters.optCount }}&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt;&lt;/style&gt; 这样，这两个兄弟节点，就可以通过state读写数据了，不需要进行组件之间的传值 总结： state中的数据，不能直接修改，如果想要修改，必须通过 mutations,不然的话就违背了vuex的设计初衷 如果组件想要直接 从 state 上获取数据： 需要 this.$store.state.*** 如果 组件，想要修改数据，必须使用 mutations 提供的方法，需要通过 this.$store.commit('方法的名称'， 唯一的一个参数) 如果 store 中 state 上的数据， 在对外提供的时候，需要做一层包装，那么 ，推荐使用 getters, 如果需要使用 getters ,则用 this.$store.getters.***","link":"/2019/07/05/Vuex的使用/"},{"title":"express中的中间件","text":"在Nodejs中的Express框架来说，中间件是一个比较抽象的概念，但是对于理解Nodejs的请求原理是非常重要的，这里简单的介绍了Nodejs中Express框架的中间件原理 中间件的原理 就是相当于水经过一系列处理到用户的过程，中间不能跳过某些步骤或者调换某些步骤 下面使用一个代码来帮助我们更好的理解中间件的概念 1234567891011121314151617181920212223242526272829const express = require('express')const app = express()const port = 3000//这个就是中间件，中间件就是一个函数，函数有三个参数//request 请求数据//respone 响应数据// next 表示继续执行下一个中间件，如果没有使用这个方法，那么下面就算有符合匹配项，都不会被执行//这个表示所有请求都会经过这里,但是请求到这里时会停留，如果想要继续执行需要调用next方法app.use(function(request, respone, next) { console.log('a') next() //需要继续执行})app.use(function(request, respone, next) { console.log('b') next() }) //这个表示所有的get请求并且路径为 / 的请求会经过这个中间件app.get('/', (req, res, next) =&gt; { console.log('Hello World!') //如果此时不使用next方法，那么下面的get函数不会 被执行 next()})app.get('/', (req, res, next) =&gt; { res.send('Hello World!')})app.listen(port, () =&gt; console.log(`Example app listening on port port!`)) 所以，我们在使用中间件时，都应该遵循这些规则，这样可以帮助我们更好的编写程序","link":"/2019/06/24/express中的中间件/"},{"title":"webpack中引入vue","text":"在webpack使用vue，我们会遇到一些打包的问题，这个使用我们要使用打包工具来解决这个问题，以下是具体的一些说明和使用。 两者区别 在webpack中，我们需要将所有的包在main.js这个入口文件中导入，在在我们安装vue(npm i vue -D)到本地时，我们在main.js导入这个包 1import Vue from \"vue\" 会爆出以下异常： You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build. 以下的问题解释是：在webpack中使用 import Vue from “vue” 引入的 vue构造函数 功能是不完整的，它只提供了runtime-only 的方式，并没有提供 像网页中使用 script引入的那些功能 解决方式一： 使用：import Vue from &quot;../node_modules/vue/dist/vue&quot;这种引入方式 解决方式二： 配置webpack.config.js文件，新增一个属性:resolve，在里面中还有一个属性:alias，配置如下 123456resolve: { alias: { 'vue$': 'vue/dist/vue.esm.js' }} 这样使用import Vue from &quot;vue&quot;引入也不会报错了 说明 由于webpack是使用Node架构的，所以合法的Node语法都支持，当然，引入包的规则也是一致的 如下： Nodejs中包的查找规则: 找项目根目录中是否有安装 node_modules 的文件夹 在node_modules 中根据包名，找对应的 vue 文件夹 在 vue中，找到一个叫packahe.json的配置文件 在package.json 文件夹中，查找一个 main 属性，这个属性指定了这个包被加载时的入口文件","link":"/2019/06/23/webpack中引入vue/"},{"title":"webpack打包图片","text":"在webpack中，我们使用其打包一些项目的时候，经常会遇到图片，但是如果直接打包图片则会抛出异常，以下是打包图片的一些详细配置文件和步骤 使用webpack打包图片 在平常中，我们在设置style中使用background:url 可以引入背景图片，在前面我们已经学会如何打包css、less、scss文件 安装url-loader和其依赖file-loader cnpm install url-loader file-loader -D 使用file-loader进行图片的打包 在webpack.config.js中配置，在与其他配置下添加如下即可 1234{ test: /\\.jpg|png|gif|bmp|jpeg/, //配置图片 use: ['file-loader'] } 可以简写成如下： 1234{ test: /\\.(jpg|png|gif|bmp|jpeg)/, //配置图片打包的格式 loader: 'file-loader' } 如果想要打包出来的图片不改变名字和格式，只需添加options即可 123456{ test: /\\.(jpg|png|gif|bmp|jpeg)/, //配置图片打包的格式 loader: 'file-loader' options: { //[name]表示名字,[ext]表示格式，而name属性其实就是图片打包后的路径 name: 'images/[name].[ext]' } 除了使用file-loader对图片进行打包处理外，我们同样也可以使用url-loader代替，另外我们还可以对小于某个大小的图片进行base64格式的转化处理。 使用url-loader打包 12345678{ test: /\\.(png|jpg|gif|svg)$/, loader: 'url-loader', options: { name: './images/[name].[ext]', limit: 8192 }} 这里limit属性的作用就是将小于8192B（8.192K）大小的图片转成base64格式，而大于这个大小的图片将会以file-loader的方式进行打包处理 注意：如果不写limit属性，那么url-loader就会默认将所有图片转成base64 这样打包出来的图片会自动转换成base64,但是我们多数是将小图片转成base64，而大图片不进行转换 而对于有些图片在不同路径下，但是文件名字一样时，我们需要在name:属性中增加hash值：定义[hash:8]定义 8位hash值最多32位，这样图片就不会存在不同 123456789{ test: /\\.(jpg|png|gif|bmp|jpeg)/, //配置图片 loader: 'url-loader', //在这里时，只有一个我们可以简化 loader，使用use则会报错 options: { limit: 2000, //limit 的值单位是 Byte ，如果图片小于limit的值，则转成base64格式的字符串，如果大于，则不转 name: '[hash:8]-[name].[ext]' //这是将文件名原样输出[name]指的是图片名，[ext]是图片格式， //[hash:8]表示生成8位hash值，否则在不同文件夹下同名图片会失效，用来区分 } }","link":"/2019/06/22/webpack打包图片/"},{"title":"webpack配置的一些总结","text":"在配置webpack打包项目时，有些必要的插件安装与配置，才能保证项目完整的被打包，这里总结了一些基础的webpack配置，可以满足基础的打包运行要求。 全局安装webpack npm install webpack -g 生成package.json npm init -y 安装webpack-dev-server到本地 npm install webpack-dev-server -D 仍然需要在本地安装webpack作为webpack-dev-server的依赖 npm install webpack -D 配置webpack.config.js文件 创建webpack.config.js文件 配置文件出入口 1234567891011121314151617181920212223//由于webpack是由Nodejs构建的，所以任何的Nodejs语法都支持//引入路径模块var path = require('path')//当以命令形式运行webpack或者webpack-dev-server的时候，工具会发现，我们没用提供要打包的文件入口和出口命令//此时，就会检查项目根目录中的配置文件 webpack.config.js 并读取这个文件，就拿到了导出的这个配置对象，然后根据对象进行打包//向外暴露出这个对象module.exports = { entry: path.join(__dirname, './src/main.js') //入口文件，需要打包的文件 , output: { //出口文件，需要打包到哪里去 path: path.join(__dirname, './dist/bundle.js') //输出路径 , filename: 'bundle.js' }, mode: 'development', //设置mode，在4.0新增 } 配置一些功能：在webpack.config.js中配置 123456 devServer: { //配置webpack-dev-server open: true, //是否打开浏览器 contentBase: 'src', //指定托管的目录 hot: true, //是否启用热更新 port: 6000 //代理的端口}, 在package.json中配置 123\"script\":{\"start:dev\": \"webpack --open --port 3000 --contentBase src --hot\"} 需要将打包好的文件从虚拟内存中传入过来 安装html-webpack-plugin npm install html-webpack-plugin -D 在webpack.config.js中配置这个插件 作用： 在内存中，根据只当的模板页面，生成一份内存中的首页，同时把打包好的bundle.js注入到页面底部 如果需要配置插件，需要在导出的对象中挂载一个 plugins:[] 注意：所有的第三方插件都在 plugins:[]中配置 与entry、output同级1234567plugins: [ new htmlWebpackPlugin({ template: path.join(__dirname, './src/index.html'), //指定模板文件的目录 filename: 'index.html' //设置生成的页面名称 }) ] 配置css-loader、less-loader、sass-loader 在main.js中引入css文件 import ‘./css/style.css’ 安装css-loader插件：npm install css-loader style-loader --save-dev import ‘./css/style.less’ 安装css-loader插件：npm install less-loader less --save-dev import ‘./css/style.sass’ 安装css-loader插件：npm install sass-loader node-sass --save-dev 配置文件 在webpack.config.js配置sass 注意：使用npm命令时安装node-sass可能会报错，无法打包，此时建议切换成cnpm 切换方法 cmd运行nrm ls查看,然后切换nrm use cnpm即可，但是前提应该先在全局中安装nrm 12345678910111213module.exports = { ... module: { rules: [{ test: /\\.scss$/, use: [ \"style-loader\", // creates style nodes from JS strings \"css-loader\", // translates CSS into CommonJS \"sass-loader\" // compiles Sass to CSS, using Node Sass by default ] }] }}; 在webpack.config.js配置css 12345678910module.exports = {module: { rules: [ { test: /\\.css$/i, use: ['style-loader', 'css-loader'], }, ],},}; 在webpack.config.js配置less 12345678910module.exports = {module: { rules: [ { test: /\\.less$/, loader: 'less-loader', // compiles Less to CSS }, ],},}; 配置好基本的webpack.config.js文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//由于webpack是由Nodejs构建的，所以任何的Nodejs语法都支持//引入路径模块var path = require('path')//在内存中，根据只当的模板页面，生成一份内存中的首页，同时把打包好的bundle.js注入到页面底部//如果需要配置插件，需要在导出的对象中挂载一个 plugins:[]const htmlWebpackPlugin = require('html-webpack-plugin')//当以命令形式运行webpack或者webpack-dev-server的时候，工具会发现，我们没用提供要打包的文件入口和出口命令//此时，就会检查项目根目录中的配置文件 webpack.config.js 并读取这个文件，就拿到了导出的这个配置对象，然后根据对象进行打包//向外暴露出这个对象module.exports = { entry: path.join(__dirname, './src/main.js') //入口文件，需要打包的文件 , output: { //出口文件，需要打包到哪里去 path: path.join(__dirname, './dist') //输出路径 , filename: 'bundle.js' }, module: { rules: [{ test: /\\.css$/i, //配置css use: ['style-loader', 'css-loader'], }, { test: /\\.less$/i, //配置less use: ['style-loader', 'css-loader', 'less-loader'] }, { test: /\\.scss$/i, //配置sass use: ['style-loader', 'css-loader', 'sass-loader'] }], }, devServer: { //配置webpack-dev-server open: true, //是否打开浏览器 contentBase: 'src', //指定托管的目录 hot: true, //是否启用热更新 port: 2000 //代理的端口 }, mode: 'development', plugins: [ new htmlWebpackPlugin({ template: path.join(__dirname, './src/index.html'), //指定模板文件的目录 filename: 'index.html' //设置生成的页面名称 }) ]} 注意事项： 在webpack4.0以后，webpack新增了mode属性 打包命令有所变化 webpack 要打包的文件 -o 打包生成存放文件的路径 而且在package.json文件中，需要配置如下代码： 1234\"scripts\": { \"dev\": \"webpack --mode development\", // 开发环境 \"build\": \"webpack --mode production\", // 生产环境 }, 在webpack.config.js中，同样需要配置如下代码：1mode: 'development' // 设置mode 如果需要下载指定版本，输入以下命令： npm i -D webpack@3 // 3： webpack版本3最新","link":"/2019/06/22/webpack配置的一些总结/"},{"title":"关联多个远程仓库","text":"我们在日常的开发中，由于GitHub是外国的服务器，所以上传速度较慢，但是我们国内也有托管的网站，比如码云 前言 在实际的开发过程中，团队协作开发项目是必不可少的，我们将项目托管到远程仓库上，就是为了解决多人合作开发和代码托管备份的作用，而有时候我们需要将一个项目托管到多个仓库中，现在我们就一起来学习一下如何操作 使用码云 要想使用码云现需要注册 注册成功后在个人中心，配置ssh，因为我们在github中，已经生成了ssh，所以我们直接拿公钥即可 然后在个人中心旁边有个 + 号 新建仓库即可关联github和码云 在git的使用我们已经详细的简述了如何托管到GitHub中，现在我们讲述一下托管到GitHub和码云中 git remote rm origin；先删除已经关联的origin远程仓库 git remote add github git@github.com:ZhongYueHui/vue-001.git 注意：，远程仓库名是github了不是origin了 接着关联码云的仓库 git remote add gitee git@gitee.com:zhongyuehui/vue-001.git 注意：，远程仓库名是gitee了不是origin了 现在我们使用git remote -v就可以查看到远程库的信息了 1234gitee git@gitee.com:zhongyuehui/vue-001.git (fetch)gitee git@gitee.com:zhongyuehui/vue-001.git (push)github git@github.com:ZhongYueHui/vue-001.git (fetch)github git@github.com:ZhongYueHui/vue-001.git (push) 推送到GitHub和码云 推送到GitHub：git push github master 推送到码云:git push gitee master 这样，我们的项目将就分别在git和码云中了","link":"/2019/07/02/关联多个远程仓库/"},{"title":"git的使用","text":"git是什么？Git(读音为/gɪt/。)是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 前言 我们在平时的项目开发中，难免会用到一些托管工具来托管自己的代码，这样可以更好的和别人和分享自己项目和合作开发项目，这里就简单介绍一下git的使用。 git的使用Git基本操作 上传本地文件(工作区)到暂存区 git status先初始化项目(状态)，检查是否在工作区域还是暂存区 git add 文件名将文件上传到暂存区 将暂存区的文件上传到git仓库中 git status初始化暂存区的项目，查看是否含有相同的内容 git commit -m &quot;提交的描述&quot;，项目的说明 git status 查看文件状态 注意：使用 git commit -m '' 是一次性将文件放到分支，使用git add是将文件添加到暂存区(Stage), git是版本控制工具，并不是文件控制工具，我们只有使用git add添加到暂存区的文件，再使用git commit -m ''才能将文件提交到分支，如果你修改了文件直接提交到分支，这个是不能修改的，不信你可以使用git diff HEAD -- '文件名'查看工作区和版面本库中最新版本的区别 ，没有使用git add '' 的文件内容没有并没有添加到版本库(commit)中 基本流程 基本流程图 基本设置 设置用户名:git config --global user.name 'GitHub的用户名' 设置用户名的邮箱：git config --global user.email '设置用户名的邮箱' 初始化新的git仓库 创建新的文件夹 也可以在命令行 mkdir 文件夹名字进行创建 进入文件夹 ，命令行cd 文件夹名 初始化仓库, 命令行 git init ，会生成一个.git的文件夹，若没有在文件夹下点击查看，打开显示隐藏的项目 项目的管理 上传文件项目(使用流程) 在项目文件夹中，创建文件，也可以在命令行中使用touch 文件名 注意：需要带后缀名 然后使用 git status可以查看文件是否在暂存区域中(没有是红色) 如果没有，使用git add '文件名'即可将文件名上传到暂存区中 git status查看文件是否已经存在于暂存区(存在是绿色) 修改文件 命令行直接 vi/vim 文件名即可输入内容，也可以鼠标右键编辑 修改后 git status，发现文件更改后，又变成红色，需要重新提交 git diff可以查看修改了什么内容 git add 文件名提交即可 git status发现没有文件可以提交，则提交成功 撤销修改(例如撤回reademe.txt文件的修改) 我们再修改文件时可能由于出错误修改，我们可以及时的将文件返回到上一个未修改的版本，修改文件后 git status也可以发现git会提示你使用git checkout -- &lt;file&gt;可以丢弃工作区的修改 当然，命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 删除文件 在命令行rm -rf 文件名(强制删除，不建议使用)或者rm 文件名(普通删除),rm -l 文件名(删除三个以上提示),rm -i 文件名(删除前提示，可以确认删除文件是否选择正确)，或者在鼠标右键删除 注意：上面的步骤是在工作区删除 git rm 文件名:是在git中删除文件 git commit -m '提交描述'，如果需要删除某个文件，则需要rm 文件 再 git rm 文件 再 git commit -m '提交描述',这样就可以完整的删除这个文件了 注意：使用git log 可以查看每次版本的修改历史，如果你嫌弃信息过多眼花缭乱，也可以使用git log --pretty=oneline查看，其中一大串的只是commit id(版本号)而已 回退版本 在git中，使用HEAD表示当前的版本，上个版本使用 (HEAD^)表示，上上版本使用 (HEAD^^)表示，如果是多个可以使用 (HEAD~N)表示 使用 git reset --hard HEAD^表示回退上一个版本，但是我们使用git log已经查看不到之前我们跳转过来的历史了，但是如果我们想还原，也还是有办法的，只要我们不关闭命令行窗口，找到之前的commit id,就可以回到未来的指定版本 使用git reset --hard commit id 后，可以查看是否回到上个版本了 注意： 使用commit id 时不需要全部填写 但是要精确到git能找到该文件 如果我们回退到上一个版本后已经关闭了命令行又想回到最新版本怎么办？ 在git中，提供了一个命令git reflog可以记录你的每一条命令 git远程仓库 添加远程仓库(如：test) 准备工作 创建ssh（如果已经创建关联请忽略） 在命令行下ssh-keygen -t rsa -C &quot;898542119@qq.com&quot;,然后一路回车即可 在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人 登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容即可，这样我们的关联就已经做好了 远程添加文件到仓库中 登陆GitHub，点击 “Create a new repo”，在Repository name 填入仓库名称，其他的默认即可 在你本地的仓库中运行如下：git remote add origin git@github.com:ZhongYueHui/test.git其中ZhongYueHui是GitHub的名字,test仓库的名字 然后使用 git push -u origin master就可以将文件提交到GitHub上了，其实就是将本地分支 master 推送到远程，这样远程的仓库和本地就一样了 从现在开始，只要你对文件做了修改，就可以使用git push origin master将最新的修改提交到版本库了 注意：如果第一次clone或者push会弹出如下警告,输入yes即可 123The authenticity of host 'github.com (xx.xx.xx.xx)' can't be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)? 从远程克隆仓库 在命令行输入git clone git@github.com:ZhongYueHui/gitskills.git即可克隆gitskills仓库 注意：要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆,Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快 分支管理 创建和合并分支 创建分支:git checkout -b 分支名称，git checkout -b dev相当于创建新分支并切换，相当于如下两条命令 12git branch dev //创建分支git checkout dev //切换分支 查看分支:git branch,会列出所有的分支，当前的分支会使用*标记 我们在dev分支下修改的文件在切换到master分支查看，发现并未修改，但是我们可以使用git merge dev将dev分支合并到当前的分支上(master) 合并完之后，我们就可以将dev分支删除了:git branch -d dev，使用git branch查看分支就只有master 了 小结： 1234567891011查看分支：git branch创建分支：git branch &lt;name&gt;切换分支：git checkout &lt;name&gt;创建+切换分支：git checkout -b &lt;name&gt;合并某分支到当前分支：git merge &lt;name&gt;删除分支：git branch -d &lt;name&gt; 分支之间的冲突 假设我们在创建了一个分支feature1，我们在feature1上修改reademe.txt文件，然后git add reademe.txt和git commit -m ''，然后切换到master中同样对reademe.txt做出修改，然后git add reademe.txt和`git commit -m 这样，我们想合并feature1分支就会出异常，Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改自己想要的内容和删除标记后保存：这个时候我们需要将内容统一到和feature1，然后git add reademe.txt和git commit -m即可 我们还可以使用git log --graph --pretty=oneline --abbrev-commit查看分支合并情况分支管理策略 合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fastforward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息 假设我们在创建了一个分支feature1，我们在feature1上修改reademe.txt文件，然后git add reademe.txt和git commit -m ''，然后切换到master中,准备合并feature1，使用=&gt;git merge --no-ff -m &quot;merge with no-ff&quot; dev进行合并，注意 --no-ff表示的是禁用Fast forward git log --graph --pretty=oneline --abbrev-commit查看分支历史123456 * e1e9c68 (HEAD -&gt; master) merge with no-ff|\\ | * f52c633 (dev) add merge|/ * cf810e4 conflict fixed ... BUG分支 我们可能在开发中出现一些紧急的BUG需要及时修复，你可能马上想创建一个BUG修复的文件，但是你突然发现自己手中的 工作还没做完，无法提交，这时候就需要用到Git提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作 我们使用git stash来暂停自己的工作现场，然后创建自己的bug修复分区，然后git add '',git commit -m ''后合并到master分区中，这样BUG修复完毕了，删除bug修复分区即可（git merge --no-ff -m &quot;删除描述&quot; 分区名） 修复完后就可以切换到自己原来的分区继续工作了，但是我们需要使用git stash list查看，使用git status查看是干净的，然后我们可以使用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；另一种方式是用git stash pop，恢复的同时把stash内容(就是暂停的记录)也删了,再使用git stash list就是干净的了 1stash@{0}: WIP on master: 54a255b git tracks changes 你可以多次使用git stash list，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：git stash apply stash@{0} Feature分支 用于实验的项目功能，不能直接用于主分支，容易乱掉，所以最好新建一个分支进行实验性测试 新建一个分区后，新建一个增加功能的文件，git add '',git commit -m ''后git checkout dev合并到dev中，如果此时想删除这个功能文件，我们此时就应该删除该文件git branch -d feature-vulcan，如果提示还没有合并，那么直接将-d换成-D即可强制删除该分区 12error: The branch 'feature-vulcan' is not fully merged.If you are sure you want to delete it, run 'git branch -D feature-vulcan'. 远程同步分支 当我们需要多个人同时开发项目时，我们应该将本地的分支推送到远程分支上 当我们从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。要查看远程库的信息，用git remote或者git remote -v 12origin git@github.com:ZhongYueHui/learngit.git (fetch)origin git@github.com:ZhongYueHui/learngit.git (push) 推送分支 git push origin master将本地分支推送到远程分支上 如果推送dev这个分区，git push origin dev即可 说明： 并不是每个分支都需要被推送， master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步 bug分支只用于在本地修复bug，就没必要推到远程了，除非上级要求 feature分支是否推到远程，取决于你是否和你的项目伙伴抓取分支 如果你和你的团队再开发一个项目时，你的一个伙伴推送文件到dev分支上，并且推送到远程上，这个时候如果你也推送(push)dev到远程，这个是时候就会出错，解决办法也是和分支之间的冲突一样处理 小结： 首先，可以试图用git push origin 推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;rebase 我们在多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的伙伴不得不先pull，在本地合并，然后才能push成功。每次合并再push后，分支变成的很乱 使用git rebase可以解决这个问题，帮我们把分支整理成一条直线标签管理 方便我们查找，虽然git有 commit，但是这个东西是一堆进制数，不方便我们查找，所以我们设置标签的形式，方便查找 在你想要创建标签的分支上,输入git tag &lt;name&gt;添加标签，使用git tag可以查看所有标签给git 如果之前忘记了添加标签，找到历史的commit id打上就可以，git log --pretty=oneline --abbrev-commit 比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令：git tag v0.9 f52c633 查看所有的书签：git show &lt;tagname&gt; 命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息； 命令git tag可以查看所有标签操作书签 修改书签：git tag -d v0.1 将标签推送到远程：git push origin &lt;tagname&gt;或者git push origin --tags一次性将推送未推送的书签 删除远程的书签： 先删除本地的书签：git tag -d v0.9 再从远程删除：git push origin :refs/tags/v0.9 总结： 命令git push origin &lt;tagname&gt;可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d &lt;tagname&gt;可以删除一个本地标签； 命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签","link":"/2019/07/01/git的使用/"}],"tags":[{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"vs code","slug":"vs-code","link":"/tags/vs-code/"},{"name":"vuex","slug":"vuex","link":"/tags/vuex/"},{"name":"Express","slug":"Express","link":"/tags/Express/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"git","slug":"git","link":"/tags/git/"}],"categories":[{"name":"Nodejs","slug":"Nodejs","link":"/categories/Nodejs/"},{"name":"TypeScript","slug":"TypeScript","link":"/categories/TypeScript/"},{"name":"开发工具","slug":"开发工具","link":"/categories/开发工具/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"Git","slug":"Git","link":"/categories/Git/"}]}